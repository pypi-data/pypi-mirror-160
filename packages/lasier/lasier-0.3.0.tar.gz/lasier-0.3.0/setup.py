# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['lasier',
 'lasier.adapters',
 'lasier.adapters.caches',
 'lasier.circuit_breaker',
 'lasier.circuit_breaker.rules']

package_data = \
{'': ['*']}

setup_kwargs = {
    'name': 'lasier',
    'version': '0.3.0',
    'description': 'A sync/async circuit breaker implementation',
    'long_description': "# Lasier\nA sync/async circuit breaker implementation\n\n[![Build Status](https://github.com/luizalabs/lasier/actions/workflows/main.yaml/badge.svg)](https://github.com/luizalabs/lasier/actions)\n\nAccording to Nygard on your masterpiece book [Release It!](http://pragprog.com/titles/mnee/release-it):\n\n> [...] circuit breakers protect overeager gadget hounds from burning their houses down. The principle is the same: detect excess usage, fail first, and open the circuit. More abstractly, the circuit breaker exists to allow one subsystem (an electrical circuit) to fail (excessive current draw, possibly from a short circuit) without destroying the entire system (the house). Furthermore, once the danger has passed, the circuit breaker can be reset to restore full function to the system.\n\n## Requirements\n* Python >= 3.7\n\n## Instalation\nUsing `pip`:\n\n```\npip install lasier\n```\n\n## Usage\nTo use lasier circuit breaker you'll need a `rule` and a `cache` (the circuit state storage) instance\n\n### Rule\nA `Rule` is the mechanism that define where circuit will open or close.\n\n#### MaxFailuresRule\nRule to open circuit based on maximum number of failures\n\n```python\nfrom lasier.circuit_breaker.rules import MaxFailuresRule\n\nrule = MaxFailuresRule(\n    max_failures=500,\n    failure_cache_key='my_cb'\n)\n```\n\n##### Arguments\n| Argument | Definition |\n|----------|------------|\n| max\\_failures | Maximum number of errors |\n| failure\\_cache\\_key | Cache key where the number of errors is incremented |\n\n#### PercentageFailuresRule\nRule to open circuit based on a percentage of failures\n\n```python\nfrom lasier.circuit_breaker.rules import PercentageFailuresRule\n\nrule = PercentageFailuresRule(\n    max_failures_percentage=60,\n    failure_cache_key='my_cb',\n    min_accepted_requests=100,\n    request_cache_key='my_cb_request'\n)\n```\n\n##### Arguments\n| Argument | Definition |\n|----------|------------|\n| max\\_failures\\_percentage | Maximum percentage of errors |\n| failure\\_cache\\_key | Cache key where the number of errors is incremented |\n| min\\_accepted\\_requests | Minimum number of requests accepted to not open circuit breaker |\n| request\\_cache\\_key | Cache key where the number of requests is incremented |\n\n### Circuit Breaker\nYou can use the Lasier circuit breaker with a *context\\_manager* f.ex:\n\n```python\nfrom lasier.circuit_breaker.sync import CircuitBreaker\n\n...\n\ndef some_protected_func():\n    with CircuitBreaker(\n        rule=rule,\n        cache=cache,\n        failure_exception=ValueError,\n        catch_exceptions=(KeyError, TypeError)\n    ):\n        # some process\n```\nOr a _decorator_, f.ex:\n\n```python\nfrom lasier.circuit_breaker.asyncio import circuit_breaker\n\n...\n\n@circuit_breaker(\n    rule=rule,\n    cache=cache,\n    failure_exception=ValueError,\n    catch_exceptions=(KeyError, TypeError)\n)\nasync def some_protected_func():\n    # some process\n```\n\nThe **sync** and **async** implementations follow the same interface, so you only need to change the import path:\n\n* `lasier.circuit_breaker.sync`: for sync implementataion\n* `lasier.circuit_breaker.asyncio`: for async implementataion\n\n##### Arguments\n| Argument | Definition |\n|----------|------------|\n| rule | Instance of class [rule](https://github.com/luizalabs/lasier#rule). |\n| cache | Instance of the circuit breaker [state storage](https://github.com/luizalabs/lasier#circuit-state-storage). |\n| failure\\_exception | Exception to be raised when it exceeds the maximum number of errors and when the circuit is open. |\n| failure\\_timeout | This value is set on first error. It is used to validate the number of errors by time. (seconds, default 60) |\n| circuit\\_timeout | Time that the circuit will be open. (seconds, default 60) |\n| catch\\_exceptions | List of exceptions catched to increase the number of errors. |\n\n> **WARNING**: The args `failure_timeout` and `circuit_timeout` will be used on state storage commands so if you'll use libs that expects milliseconds instead of seconds on `timeout` arguments maybe you'll get yourself in trouble\n\n## Circuit state storage\nLasier works with a storage to register the current state of the circuit, number of failures, etc. That storage respects the follow interface:\n\n```python\nfrom lasier.types import Timeout  # Timeout = Optional[Union[int, float]]\n\n\nclass Storage:\n\n    def add(self, key: str, value: int, timeout: Timeout = None) -> None:\n        pass\n\n    def set(self, key: str, value: int, timeout: Timeout = None) -> None:\n        pass\n\n    def incr(self, key: str) -> int:\n        pass\n\n    def get(self, key: str) -> int:\n        pass\n\n    def expire(key: str, timeout: Timeout = None) -> None:\n        pass\n\n    def delete(self, key: str) -> None:\n        pass\n\n    def flushdb(self) -> None:\n        pass\n```\n\n> For `async` circuit breaker, lasier works with that same interface however with async syntax, f.ex: `async def set(self, key=str, value=int, timeout=Optional[int])`\n\nSo you can use any cache/storage that respects that interface.\n\n### Adapters\nIf you'll use Lasier with [redis-py](https://github.com/andymccurdy/redis-py) as cache, you can use `lasier.adapters.caches.redis.RedisAdapter`\n\n```python\nfrom lasier.adapters.caches import RedisAdapter\nfrom redis import Redis\n\ncache = RedisAdapter(Redis(host='localhost', port=6479, db=0))\n```\n\n#### Implemented Adapters\n| Lib                | Adapter                                       |\n|--------------------| --------------------------------------------- |\n| redis-py           | `lasier.adapters.caches.RedisAdapter`         |\n| django-cache       | `lasier.adapters.caches.DjangoAdapter`        |\n| django-cache-async | `lasier.adapters.caches.DjangoAsyncAdapter`   |\n| aiocache           | `lasier.adapters.caches.AiocacheAdapter`      |\n",
    'author': 'LuizaLabs',
    'author_email': 'pypi@luizalabs.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/luizalabs/lasier',
    'packages': packages,
    'package_data': package_data,
    'python_requires': '>=3.8,<4.0',
}


setup(**setup_kwargs)
