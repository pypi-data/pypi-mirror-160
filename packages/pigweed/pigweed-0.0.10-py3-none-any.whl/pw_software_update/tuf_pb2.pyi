"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class HashFunction(_HashFunction, metaclass=_HashFunctionEnumTypeWrapper):
    pass
class _HashFunction:
    V = typing.NewType('V', builtins.int)
class _HashFunctionEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_HashFunction.V], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
    # Never use this in any TUF metadata.
    UNKNOWN_HASH_FUNCTION = HashFunction.V(0)
    SHA256 = HashFunction.V(1)

# Never use this in any TUF metadata.
UNKNOWN_HASH_FUNCTION = HashFunction.V(0)
SHA256 = HashFunction.V(1)
global___HashFunction = HashFunction


class KeyType(_KeyType, metaclass=_KeyTypeEnumTypeWrapper):
    pass
class _KeyType:
    V = typing.NewType('V', builtins.int)
class _KeyTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_KeyType.V], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
    # Never use this in any TUF metadata.
    UNKNOWN_KEY_TYPE = KeyType.V(0)
    RSA = KeyType.V(1)
    ED25519 = KeyType.V(2)
    ECDSA_SHA2_NISTP256 = KeyType.V(3)

# Never use this in any TUF metadata.
UNKNOWN_KEY_TYPE = KeyType.V(0)
RSA = KeyType.V(1)
ED25519 = KeyType.V(2)
ECDSA_SHA2_NISTP256 = KeyType.V(3)
global___KeyType = KeyType


class KeyScheme(_KeyScheme, metaclass=_KeySchemeEnumTypeWrapper):
    pass
class _KeyScheme:
    V = typing.NewType('V', builtins.int)
class _KeySchemeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_KeyScheme.V], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
    # Never use this in any TUF metadata.
    UNKNOWN_KEY_SCHEME = KeyScheme.V(0)
    # RSA Probabilistic signature scheme with appendix.
    # The underlying hash function is SHA256.
    # In TUF Specification, this is referred to as "rsassa-pss-sha256".
    RSASSA_PSS_SHA256_SCHEME = KeyScheme.V(1)
    # Elliptic Curve digital signature algorithm based on Twisted Edwards curves.
    # See https://ed25519.cr.yp.to/.
    # In TUF Specification, it is referred to as "ed25519".
    ED25519_SCHEME = KeyScheme.V(2)
    # Elliptic Curve Digital Signature Algorithm with NIST P-256 curve signing
    # and SHA-256 hashing. See
    # https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm In
    # TUF Specification, it is referred to as "ecdsa-sha2-nistp256".
    ECDSA_SHA2_NISTP256_SCHEME = KeyScheme.V(3)

# Never use this in any TUF metadata.
UNKNOWN_KEY_SCHEME = KeyScheme.V(0)
# RSA Probabilistic signature scheme with appendix.
# The underlying hash function is SHA256.
# In TUF Specification, this is referred to as "rsassa-pss-sha256".
RSASSA_PSS_SHA256_SCHEME = KeyScheme.V(1)
# Elliptic Curve digital signature algorithm based on Twisted Edwards curves.
# See https://ed25519.cr.yp.to/.
# In TUF Specification, it is referred to as "ed25519".
ED25519_SCHEME = KeyScheme.V(2)
# Elliptic Curve Digital Signature Algorithm with NIST P-256 curve signing
# and SHA-256 hashing. See
# https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm In
# TUF Specification, it is referred to as "ecdsa-sha2-nistp256".
ECDSA_SHA2_NISTP256_SCHEME = KeyScheme.V(3)
global___KeyScheme = KeyScheme


# Metadata for a particular TUF role (e.g. targets metadata).
# Was TufMetadata
class SignedRootMetadata(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SERIALIZED_ROOT_METADATA_FIELD_NUMBER: builtins.int
    SIGNATURES_FIELD_NUMBER: builtins.int
    # Serialized RootMetadata message that is the data portion of the metadata.
    serialized_root_metadata: builtins.bytes = ...
    # Signature of the canonical form of the role's serialized metadata
    # (serialized_root_metadata).
    @property
    def signatures(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Signature]: ...
    def __init__(self,
        *,
        serialized_root_metadata : builtins.bytes = ...,
        signatures : typing.Optional[typing.Iterable[global___Signature]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"serialized_root_metadata",b"serialized_root_metadata",u"signatures",b"signatures"]) -> None: ...
global___SignedRootMetadata = SignedRootMetadata

class SignedTimestampMetadata(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SERIALIZED_TIMESTAMP_METADATA_FIELD_NUMBER: builtins.int
    SIGNATURES_FIELD_NUMBER: builtins.int
    # Serialized TimestampMetadata message that is the data portion of the
    # metadata.
    serialized_timestamp_metadata: builtins.bytes = ...
    # Signature of the canonical form of the role's serialized metadata
    # (serialized_timestamp_metadata).
    @property
    def signatures(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Signature]: ...
    def __init__(self,
        *,
        serialized_timestamp_metadata : builtins.bytes = ...,
        signatures : typing.Optional[typing.Iterable[global___Signature]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"serialized_timestamp_metadata",b"serialized_timestamp_metadata",u"signatures",b"signatures"]) -> None: ...
global___SignedTimestampMetadata = SignedTimestampMetadata

class SignedSnapshotMetadata(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SERIALIZED_SNAPSHOT_METADATA_FIELD_NUMBER: builtins.int
    SIGNATURES_FIELD_NUMBER: builtins.int
    # Serialized SnapshotMetadata message that is the data portion of the
    # metadata.
    serialized_snapshot_metadata: builtins.bytes = ...
    # Signature of the canonical form of the role's serialized metadata
    # (serialized_snapshot_metadata).
    @property
    def signatures(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Signature]: ...
    def __init__(self,
        *,
        serialized_snapshot_metadata : builtins.bytes = ...,
        signatures : typing.Optional[typing.Iterable[global___Signature]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"serialized_snapshot_metadata",b"serialized_snapshot_metadata",u"signatures",b"signatures"]) -> None: ...
global___SignedSnapshotMetadata = SignedSnapshotMetadata

class SignedTargetsMetadata(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SERIALIZED_TARGETS_METADATA_FIELD_NUMBER: builtins.int
    SIGNATURES_FIELD_NUMBER: builtins.int
    # Serialized TargetsMetadata message that is the data portion of the
    # metadata.
    serialized_targets_metadata: builtins.bytes = ...
    # Signature of the canonical form of the role's serialized metadata
    # (serialized_targets_metadata).
    @property
    def signatures(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Signature]: ...
    def __init__(self,
        *,
        serialized_targets_metadata : builtins.bytes = ...,
        signatures : typing.Optional[typing.Iterable[global___Signature]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"serialized_targets_metadata",b"serialized_targets_metadata",u"signatures",b"signatures"]) -> None: ...
global___SignedTargetsMetadata = SignedTargetsMetadata

class CommonMetadata(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SPEC_VERSION_FIELD_NUMBER: builtins.int
    VERSION_FIELD_NUMBER: builtins.int
    EXPIRES_FIELD_NUMBER: builtins.int
    ROLE_FIELD_NUMBER: builtins.int
    # Version number of the TUF Specification.
    # Follows the Semantic Versioning 2.0.0 (semver) format. Metadata is
    # written according to this version, and clients MUST verify that
    # "spec_version" matches the expected version number.
    # E.g. "1.0.0".
    spec_version: typing.Text = ...
    # Metadata file version.
    # Clients MUST NOT replace a metadata file with a version number less than
    # the one currently trusted.
    version: builtins.int = ...
    # Expiration time for the metadata.
    # Indicates when this metadata should be considered expired and no longer
    # trusted by clients. Notice the TUF Specification defines this as a JSON
    # string following the ISO 8601 standard. The expected format of the date and
    # time string is "YYYY-MM-DDTHH:MM:SSZ". Time is always in UTC, and the "Z"
    # time zone designator is attached to indicate a zero UTC offset.
    # E.g. "2030-08-26T16:48:27Z".
    @property
    def expires(self) -> google.protobuf.timestamp_pb2.Timestamp: ...
    # Role type for the metadata.
    # Indicates the type of the metadata. Valid values are 'root', 'targets',
    # 'snapshot' and 'timestamp' as defined in the TUF spec, though we don't
    # plan to support 'mirrors'.
    #
    # This field serves as a "magic code" that identifies a particular type of
    # a metadata. During verification, the client is expected to check this
    # field against the expected role type immediately after verifying the
    # signatures of a metadata. This can be considered a "confidence booster"
    # in the absence of canonical protobuf -- i.e. it makes the various
    # `serialized_x_metadata` fields more tamper resistant.
    role: typing.Text = ...
    def __init__(self,
        *,
        spec_version : typing.Text = ...,
        version : builtins.int = ...,
        expires : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        role : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"_expires",b"_expires",u"_role",b"_role",u"expires",b"expires",u"role",b"role"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"_expires",b"_expires",u"_role",b"_role",u"expires",b"expires",u"role",b"role",u"spec_version",b"spec_version",u"version",b"version"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"_expires",b"_expires"]) -> typing.Optional[typing_extensions.Literal["expires"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"_role",b"_role"]) -> typing.Optional[typing_extensions.Literal["role"]]: ...
global___CommonMetadata = CommonMetadata

# This content is signed.
class RootMetadata(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    COMMON_METADATA_FIELD_NUMBER: builtins.int
    CONSISTENT_SNAPSHOT_FIELD_NUMBER: builtins.int
    KEYS_FIELD_NUMBER: builtins.int
    ROOT_SIGNATURE_REQUIREMENT_FIELD_NUMBER: builtins.int
    TIMESTAMP_SIGNATURE_REQUIREMENT_FIELD_NUMBER: builtins.int
    SNAPSHOT_SIGNATURE_REQUIREMENT_FIELD_NUMBER: builtins.int
    TARGETS_SIGNATURE_REQUIREMENT_FIELD_NUMBER: builtins.int
    @property
    def common_metadata(self) -> global___CommonMetadata: ...
    # Whether the repo supports consistent snapshots. If the repo has frequent
    # updates, you should set this to true.
    consistent_snapshot: builtins.bool = ...
    # Map from Keyid to Key.
    # Keyid is a unique identifier that identifies a cryptographic key.
    # Contains all of cryptographic keys used by this repository.
    @property
    def keys(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___KeyMapping]: ...
    # KeyConfig is the list of keys use for a particular role and the threshold.
    # Threshold is number of keys of that role whose signatures are required in
    # order to consider a file as being properly signed by that role.
    @property
    def root_signature_requirement(self) -> global___SignatureRequirement: ...
    @property
    def timestamp_signature_requirement(self) -> global___SignatureRequirement: ...
    @property
    def snapshot_signature_requirement(self) -> global___SignatureRequirement: ...
    @property
    def targets_signature_requirement(self) -> global___SignatureRequirement: ...
    def __init__(self,
        *,
        common_metadata : typing.Optional[global___CommonMetadata] = ...,
        consistent_snapshot : builtins.bool = ...,
        keys : typing.Optional[typing.Iterable[global___KeyMapping]] = ...,
        root_signature_requirement : typing.Optional[global___SignatureRequirement] = ...,
        timestamp_signature_requirement : typing.Optional[global___SignatureRequirement] = ...,
        snapshot_signature_requirement : typing.Optional[global___SignatureRequirement] = ...,
        targets_signature_requirement : typing.Optional[global___SignatureRequirement] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"common_metadata",b"common_metadata",u"root_signature_requirement",b"root_signature_requirement",u"snapshot_signature_requirement",b"snapshot_signature_requirement",u"targets_signature_requirement",b"targets_signature_requirement",u"timestamp_signature_requirement",b"timestamp_signature_requirement"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"common_metadata",b"common_metadata",u"consistent_snapshot",b"consistent_snapshot",u"keys",b"keys",u"root_signature_requirement",b"root_signature_requirement",u"snapshot_signature_requirement",b"snapshot_signature_requirement",u"targets_signature_requirement",b"targets_signature_requirement",u"timestamp_signature_requirement",b"timestamp_signature_requirement"]) -> None: ...
global___RootMetadata = RootMetadata

# The timestamp role is used for freshness check of the snapshot. Any
# project-specific update metadata should go in the top-level targets_metadata
# or with the TargetFile information
class TimestampMetadata(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    COMMON_METADATA_FIELD_NUMBER: builtins.int
    SNAPSHOT_METADATA_FIELD_NUMBER: builtins.int
    @property
    def common_metadata(self) -> global___CommonMetadata: ...
    # Only one snapshot_metadata is used per timestamp.
    @property
    def snapshot_metadata(self) -> global___MetadataFile: ...
    def __init__(self,
        *,
        common_metadata : typing.Optional[global___CommonMetadata] = ...,
        snapshot_metadata : typing.Optional[global___MetadataFile] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"common_metadata",b"common_metadata",u"snapshot_metadata",b"snapshot_metadata"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"common_metadata",b"common_metadata",u"snapshot_metadata",b"snapshot_metadata"]) -> None: ...
global___TimestampMetadata = TimestampMetadata

# The snapshot role is used to ensure that the collection of targets_metadata
# files is securely consistent (no target metadata mix and match). Any
# project-specific update metadata should go in the top-level targets_metadata
# or with the TargetFile information
class SnapshotMetadata(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    COMMON_METADATA_FIELD_NUMBER: builtins.int
    TARGETS_METADATA_FIELD_NUMBER: builtins.int
    @property
    def common_metadata(self) -> global___CommonMetadata: ...
    # Map from Target metadata file name to MetadataFile.
    # File name can be an arbitrary name or a full file name with relative path.
    # This map should contain an entry for the top level targets role and all
    # delegated roles.
    @property
    def targets_metadata(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___MetadataFile]: ...
    def __init__(self,
        *,
        common_metadata : typing.Optional[global___CommonMetadata] = ...,
        targets_metadata : typing.Optional[typing.Iterable[global___MetadataFile]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"common_metadata",b"common_metadata"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"common_metadata",b"common_metadata",u"targets_metadata",b"targets_metadata"]) -> None: ...
global___SnapshotMetadata = SnapshotMetadata

# The targets role describes the target files that comprise the software
# update. Targets metadata is organized in to a top-level targets metadata file
# and optional multiple deligated targets metadata files
#
# The top-level targets metatdata is the correct place to put any
# project-specific build version information, including build ID, hardware rev,
# etc.
class TargetsMetadata(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    COMMON_METADATA_FIELD_NUMBER: builtins.int
    TARGET_FILES_FIELD_NUMBER: builtins.int
    @property
    def common_metadata(self) -> global___CommonMetadata: ...
    # Collection of target file information
    # Target file name can be an arbitrary name or a path that describes where
    # the file lives relative to the base directory of the repository, e.g.
    # "path/to/amber_tools/0".
    @property
    def target_files(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___TargetFile]: ...
    def __init__(self,
        *,
        common_metadata : typing.Optional[global___CommonMetadata] = ...,
        target_files : typing.Optional[typing.Iterable[global___TargetFile]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"common_metadata",b"common_metadata"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"common_metadata",b"common_metadata",u"target_files",b"target_files"]) -> None: ...
global___TargetsMetadata = TargetsMetadata

class Signature(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    KEY_ID_FIELD_NUMBER: builtins.int
    SIG_FIELD_NUMBER: builtins.int
    # Identifier of the key, which is bytes of the SHA-256 hash of the
    # canonical form of the key.
    key_id: builtins.bytes = ...
    # The signature of the canonical form of the role's serialized metadata
    # (serialized_{root,timestamp,snapshot,targets}_metadata).
    sig: builtins.bytes = ...
    def __init__(self,
        *,
        key_id : builtins.bytes = ...,
        sig : builtins.bytes = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"key_id",b"key_id",u"sig",b"sig"]) -> None: ...
global___Signature = Signature

class KeyMapping(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    KEY_ID_FIELD_NUMBER: builtins.int
    KEY_FIELD_NUMBER: builtins.int
    # Identifier of the key, which is bytes of the SHA-256 hash of the
    # canonical form of the key.
    key_id: builtins.bytes = ...
    # Cryptographic key
    @property
    def key(self) -> global___Key: ...
    def __init__(self,
        *,
        key_id : builtins.bytes = ...,
        key : typing.Optional[global___Key] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"key",b"key"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"key",b"key",u"key_id",b"key_id"]) -> None: ...
global___KeyMapping = KeyMapping

# Identifies an asymmetric cryptographic key.
class Key(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    KEY_TYPE_FIELD_NUMBER: builtins.int
    SCHEME_FIELD_NUMBER: builtins.int
    KEYVAL_FIELD_NUMBER: builtins.int
    # Denotes a public key signature system, such as RSA or ECDSA.
    key_type: global___KeyType.V = ...
    # Denotes the signature scheme corresponding to the key type. For example:
    # "rsassa-pss-sha256" or "ecdsa-sha2-nistp256".
    scheme: global___KeyScheme.V = ...
    # Stores the serialized public key for this cryptographic algorithm.
    keyval: builtins.bytes = ...
    def __init__(self,
        *,
        key_type : global___KeyType.V = ...,
        scheme : global___KeyScheme.V = ...,
        keyval : builtins.bytes = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"key_type",b"key_type",u"keyval",b"keyval",u"scheme",b"scheme"]) -> None: ...
global___Key = Key

# The set of cryptographic keys used by a specific role. For example, list of
# key_ids used by the top level role "root".
class SignatureRequirement(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    KEY_IDS_FIELD_NUMBER: builtins.int
    THRESHOLD_FIELD_NUMBER: builtins.int
    # Set of Keyid's.
    # Keyid is a unique identifier that identifies a cryptographic key.
    # E.g. "f2d5020d08aea06a0a9192eb6a4f549e17032ebefa1aa9ac167c1e3e727930d6".
    @property
    def key_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.bytes]: ...
    # Threshold of signatures required to trust given file.
    # In other words; the number of keys of that role whose signatures are
    # required in order to consider a file as being properly signed by that role.
    threshold: builtins.int = ...
    def __init__(self,
        *,
        key_ids : typing.Optional[typing.Iterable[builtins.bytes]] = ...,
        threshold : builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"key_ids",b"key_ids",u"threshold",b"threshold"]) -> None: ...
global___SignatureRequirement = SignatureRequirement

class Hash(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    FUNCTION_FIELD_NUMBER: builtins.int
    HASH_FIELD_NUMBER: builtins.int
    function: global___HashFunction.V = ...
    # Digest of the cryptographic hash function computed on the target file.
    hash: builtins.bytes = ...
    def __init__(self,
        *,
        function : global___HashFunction.V = ...,
        hash : builtins.bytes = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"function",b"function",u"hash",b"hash"]) -> None: ...
global___Hash = Hash

# Descriptor for a file stored in this repository. Linked to from target
# metadata.
class TargetFile(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    FILE_NAME_FIELD_NUMBER: builtins.int
    LENGTH_FIELD_NUMBER: builtins.int
    HASHES_FIELD_NUMBER: builtins.int
    # Target file name can be an arbitrary name or a path that describes where
    # the file lives relative to the base directory of the repository, e.g.
    # "path/to/amber_tools/0".
    file_name: typing.Text = ...
    # Size of the target file (element payload) in bytes. This the size as stored
    # in the bundle. The final applied size can be different due to optional
    # compression.
    length: builtins.int = ...
    # Map from algorithm name to Hash.
    # Algorithm name is the name of a cryptographic hash function. E.g. "sha256".
    # The Hash string is the hex digest of the cryptographic function computed on
    # the target file. E.g.
    # "65b8c67f51c993d898250f40aa57a317d854900b3a04895464313e48785440da".
    @property
    def hashes(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Hash]: ...
    def __init__(self,
        *,
        file_name : typing.Text = ...,
        length : builtins.int = ...,
        hashes : typing.Optional[typing.Iterable[global___Hash]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"file_name",b"file_name",u"hashes",b"hashes",u"length",b"length"]) -> None: ...
global___TargetFile = TargetFile

class MetadataFile(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    FILE_NAME_FIELD_NUMBER: builtins.int
    VERSION_FIELD_NUMBER: builtins.int
    LENGTH_FIELD_NUMBER: builtins.int
    HASHES_FIELD_NUMBER: builtins.int
    # Target file name can be an arbitrary name or a path that describes where
    # the file lives relative to the base directory of the repository, e.g.
    # "path/to/target/0".
    file_name: typing.Text = ...
    # Metadata file version. E.g. 3.
    version: builtins.int = ...
    # Size of the target file in bytes.
    length: builtins.int = ...
    # Map from algorithm name to Hash.
    # Algorithm name is the name of a cryptographic hash function. E.g. "sha256".
    # The Hash is the hex digest of the cryptographic function computed on the
    # target file. E.g.
    # "65b8c67f51c993d898250f40aa57a317d854900b3a04895464313e48785440da".
    @property
    def hashes(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Hash]: ...
    def __init__(self,
        *,
        file_name : typing.Text = ...,
        version : builtins.int = ...,
        length : builtins.int = ...,
        hashes : typing.Optional[typing.Iterable[global___Hash]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"_file_name",b"_file_name",u"_length",b"_length",u"file_name",b"file_name",u"length",b"length"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"_file_name",b"_file_name",u"_length",b"_length",u"file_name",b"file_name",u"hashes",b"hashes",u"length",b"length",u"version",b"version"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"_file_name",b"_file_name"]) -> typing.Optional[typing_extensions.Literal["file_name"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"_length",b"_length"]) -> typing.Optional[typing_extensions.Literal["length"]]: ...
global___MetadataFile = MetadataFile
