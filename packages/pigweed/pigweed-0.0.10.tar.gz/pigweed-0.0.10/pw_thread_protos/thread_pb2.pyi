"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class ThreadState(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class Enum(_Enum, metaclass=_EnumEnumTypeWrapper):
        pass
    class _Enum:
        V = typing.NewType('V', builtins.int)
    class _EnumEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Enum.V], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        # Thread state is invalid or cannot be expressed by this enum.
        UNKNOWN = ThreadState.Enum.V(0)
        # Interrupt handling is often done on a stack that isn't associated with a
        # true RTOS thread. This state indicates the provided thread info is for an
        # interrupt handler.
        INTERRUPT_HANDLER = ThreadState.Enum.V(1)
        # This is the currently active thread as marked by the RTOS. In crashes in
        # interrupt contexts, this isn’t necessarily the thread that crashed.
        RUNNING = ThreadState.Enum.V(2)
        # Thread is ready to run, but isn’t currently running.
        READY = ThreadState.Enum.V(3)
        # The thread is not ready to run, and will not be ready to run until it is
        # explicitly resumed.
        SUSPENDED = ThreadState.Enum.V(4)
        # The thread is waiting on something before it can run again.
        BLOCKED = ThreadState.Enum.V(5)
        # The thread is either not yet initialized, or has terminated. In other
        # words, this thread is a suspended thread that cannot be unsuspended.
        INACTIVE = ThreadState.Enum.V(6)

    # Thread state is invalid or cannot be expressed by this enum.
    UNKNOWN = ThreadState.Enum.V(0)
    # Interrupt handling is often done on a stack that isn't associated with a
    # true RTOS thread. This state indicates the provided thread info is for an
    # interrupt handler.
    INTERRUPT_HANDLER = ThreadState.Enum.V(1)
    # This is the currently active thread as marked by the RTOS. In crashes in
    # interrupt contexts, this isn’t necessarily the thread that crashed.
    RUNNING = ThreadState.Enum.V(2)
    # Thread is ready to run, but isn’t currently running.
    READY = ThreadState.Enum.V(3)
    # The thread is not ready to run, and will not be ready to run until it is
    # explicitly resumed.
    SUSPENDED = ThreadState.Enum.V(4)
    # The thread is waiting on something before it can run again.
    BLOCKED = ThreadState.Enum.V(5)
    # The thread is either not yet initialized, or has terminated. In other
    # words, this thread is a suspended thread that cannot be unsuspended.
    INACTIVE = ThreadState.Enum.V(6)

    def __init__(self,
        ) -> None: ...
global___ThreadState = ThreadState

class Thread(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    ACTIVE_FIELD_NUMBER: builtins.int
    STATE_FIELD_NUMBER: builtins.int
    RAW_BACKTRACE_FIELD_NUMBER: builtins.int
    SYMBOLIZED_BACKTRACE_FIELD_NUMBER: builtins.int
    RAW_STACK_FIELD_NUMBER: builtins.int
    STACK_START_POINTER_FIELD_NUMBER: builtins.int
    STACK_END_POINTER_FIELD_NUMBER: builtins.int
    STACK_POINTER_FIELD_NUMBER: builtins.int
    CPU_USAGE_HUNDREDTHS_FIELD_NUMBER: builtins.int
    STACK_POINTER_EST_PEAK_FIELD_NUMBER: builtins.int
    # Thread names must be unique; this allows extensions of Snapshot to augment
    # threads with additional data. This should either be human readable text, or
    # tokenized data (e.g. base-64 encoded or binary data).
    name: builtins.bytes = ...
    # This field has been deprecatdin favor of using the state enum to report
    # RUNNING or INTERRUPT_CONTEXT to mark them as active.
    #
    # Whether or not this thread is the thread is the currently active context
    # at the time of capture. For multi-thread dumps, this field should only be
    # set on ONE thread.
    active: builtins.bool = ...
    # A summarized thread state. RTOS-specific extensions of the Thread message
    # may provide more specific thread state information.
    state: global___ThreadState.Enum.V = ...
    # Contents of a stack trace. It is expected that this stack is pre-walked,
    # and contains addresses. Most recent stack events are at the beginning of
    # the captured stack trace.
    @property
    def raw_backtrace(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]: ...
    # Results of symbolizing stack_entries. This is usually not provided by the
    # device, but instead by server/host side processing.
    @property
    def symbolized_backtrace(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]: ...
    # This should contain the raw contents of the thread's stack. This might not
    # match stack_size. It can be larger due to a stack overflow, or smaller due
    # to the implementation deciding to only capture a portion of the stack.
    # Partial stack captures are typically a result of storage/memory
    # limitations.
    raw_stack: builtins.bytes = ...
    # The address this thread's stack pointer began at. For descending stacks,
    # this is the highest address of the stack bounds. For ascending stacks, this
    # is the lowest address of the stack bounds.
    stack_start_pointer: builtins.int = ...
    # The furthest permitted address from where this thread's stack pointer
    # began. For descending stacks, this is the lowest address of the stack
    # bounds. For ascending stacks, this is the highest address of the stack
    # bounds.
    stack_end_pointer: builtins.int = ...
    # The current stack pointer of this thread.
    stack_pointer: builtins.int = ...
    # CPU usage info. This is the percentage of CPU time the thread has been
    # active in hundredths of a percent. (e.g. 5.00% = 500u)
    cpu_usage_hundredths: builtins.int = ...
    # The address of highest estimated currently used in the thread stack.
    # Percentage of bytes used can be calculated by:
    # (stack_estimate_max_addr-stack_start_pointer) /
    # (stack_end_pointer-stack_start_pointer) * 100%
    stack_pointer_est_peak: builtins.int = ...
    def __init__(self,
        *,
        name : builtins.bytes = ...,
        active : builtins.bool = ...,
        state : global___ThreadState.Enum.V = ...,
        raw_backtrace : typing.Optional[typing.Iterable[builtins.int]] = ...,
        symbolized_backtrace : typing.Optional[typing.Iterable[typing.Text]] = ...,
        raw_stack : builtins.bytes = ...,
        stack_start_pointer : builtins.int = ...,
        stack_end_pointer : builtins.int = ...,
        stack_pointer : builtins.int = ...,
        cpu_usage_hundredths : builtins.int = ...,
        stack_pointer_est_peak : builtins.int = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"_cpu_usage_hundredths",b"_cpu_usage_hundredths",u"_stack_end_pointer",b"_stack_end_pointer",u"_stack_pointer",b"_stack_pointer",u"_stack_pointer_est_peak",b"_stack_pointer_est_peak",u"_stack_start_pointer",b"_stack_start_pointer",u"cpu_usage_hundredths",b"cpu_usage_hundredths",u"stack_end_pointer",b"stack_end_pointer",u"stack_pointer",b"stack_pointer",u"stack_pointer_est_peak",b"stack_pointer_est_peak",u"stack_start_pointer",b"stack_start_pointer"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"_cpu_usage_hundredths",b"_cpu_usage_hundredths",u"_stack_end_pointer",b"_stack_end_pointer",u"_stack_pointer",b"_stack_pointer",u"_stack_pointer_est_peak",b"_stack_pointer_est_peak",u"_stack_start_pointer",b"_stack_start_pointer",u"active",b"active",u"cpu_usage_hundredths",b"cpu_usage_hundredths",u"name",b"name",u"raw_backtrace",b"raw_backtrace",u"raw_stack",b"raw_stack",u"stack_end_pointer",b"stack_end_pointer",u"stack_pointer",b"stack_pointer",u"stack_pointer_est_peak",b"stack_pointer_est_peak",u"stack_start_pointer",b"stack_start_pointer",u"state",b"state",u"symbolized_backtrace",b"symbolized_backtrace"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"_cpu_usage_hundredths",b"_cpu_usage_hundredths"]) -> typing.Optional[typing_extensions.Literal["cpu_usage_hundredths"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"_stack_end_pointer",b"_stack_end_pointer"]) -> typing.Optional[typing_extensions.Literal["stack_end_pointer"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"_stack_pointer",b"_stack_pointer"]) -> typing.Optional[typing_extensions.Literal["stack_pointer"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"_stack_pointer_est_peak",b"_stack_pointer_est_peak"]) -> typing.Optional[typing_extensions.Literal["stack_pointer_est_peak"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"_stack_start_pointer",b"_stack_start_pointer"]) -> typing.Optional[typing_extensions.Literal["stack_start_pointer"]]: ...
global___Thread = Thread

# This message overlays the pw.snapshot.Snapshot proto. It's valid to encode
# this message to the same sink that a Snapshot proto is being written to.
class SnapshotThreadInfo(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    THREADS_FIELD_NUMBER: builtins.int
    @property
    def threads(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Thread]: ...
    def __init__(self,
        *,
        threads : typing.Optional[typing.Iterable[global___Thread]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"threads",b"threads"]) -> None: ...
global___SnapshotThreadInfo = SnapshotThreadInfo
