import abc
from .. import humanize as humanize, utils as utils
from ..utils import mapping_repr as mapping_repr
from _typeshed import Incomplete
from abc import abstractmethod
from aioworkers.http import URL as URL
from aioworkers.net.uri import URI as URI
from typing import Callable, Iterator, Mapping, MutableMapping

logger: Incomplete

class MergeDict(dict):
    def __init__(self, iterable: Incomplete | None = ..., **kwargs) -> None: ...
    def __getattr__(self, item): ...
    def __setattr__(self, key, value) -> None: ...
    def __setitem__(self, key, value) -> None: ...
    def update(self, d, *args, **kwargs) -> None: ...
    def get(self, key, default: Incomplete | None = ...): ...
    def __getitem__(self, item): ...
    def __contains__(self, key): ...
    def __call__(self, *args, **kwargs) -> None: ...
    def __dir__(self): ...
    def copy(self): ...

def merge(source: Mapping, destination: MutableMapping): ...

class ConfigFileLoader(metaclass=abc.ABCMeta):
    extensions: tuple
    mime_types: tuple
    @abstractmethod
    def load_str(self, s): ...
    def load_bytes(self, b): ...
    def load_fd(self, fd): ...
    def load_path(self, path): ...
    def load_url(self, url): ...

class YamlLoader(ConfigFileLoader):
    extensions: Incomplete
    def __init__(self, *args, **kwargs): ...
    def load_str(self, s): ...

class JsonLoader(ConfigFileLoader):
    extensions: Incomplete
    mime_types: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def load_str(self, s): ...

class ValueMatcher(metaclass=abc.ABCMeta):
    fn: Callable
    def __init__(self, value) -> None: ...
    @abstractmethod
    def match(cls, value): ...
    @abstractmethod
    def get_value(self): ...

class IntValueMatcher(ValueMatcher):
    fn: Incomplete
    @classmethod
    def match(cls, value): ...
    def get_value(self): ...

class BooleanValueMatcher(IntValueMatcher):
    true: Incomplete
    false: Incomplete
    @classmethod
    def fn(cls, value): ...

class FloatValueMatcher(IntValueMatcher):
    fn: Incomplete

class MultilineValueMatcher(ValueMatcher):
    re: Incomplete
    @classmethod
    def match(cls, value): ...
    def get_value(self): ...

class ListValueMatcher(ValueMatcher):
    @classmethod
    def match(cls, value): ...
    def get_value(self): ...

class StringReplaceLoader(ConfigFileLoader, metaclass=abc.ABCMeta):
    matchers: Incomplete

class IniLoader(StringReplaceLoader):
    extensions: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def new_configparser(self, **kwargs): ...
    def load_fd(self, fd): ...
    def load_path(self, path): ...
    def load_str(self, string): ...

class Registry(dict):
    def __call__(self, cls) -> None: ...
    def get(self, key): ...

registry: Incomplete
extractors: Incomplete

class ValueExtractor(Mapping):
    def __init__(self, mapping) -> None: ...
    def __setattr__(self, key, value) -> None: ...
    def new_child(self, *mappings, **kwargs) -> ValueExtractor: ...
    def new_parent(self, *mappings, **kwargs) -> ValueExtractor: ...
    def __getitem__(self, item): ...
    def get(self, item, default: Incomplete | None = ...): ...
    def __contains__(self, item): ...
    def __getattr__(self, item): ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator: ...

class Config(ValueExtractor):
    env: Incomplete
    logging: Incomplete
    search_dirs: Incomplete
    uris: Incomplete
    def __init__(self, search_dirs=..., **kwargs) -> None: ...
    def load_conf(self, fd, *, path: Incomplete | None = ..., mime_type: Incomplete | None = ..., response: Incomplete | None = ...): ...
    def load(self, *filenames, base: Incomplete | None = ...): ...
    def update(self, *mappings, **kwargs) -> None: ...
    def load_plugins(self, *modules, force: bool = ...): ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator: ...
    def __getitem__(self, item): ...
    def __contains__(self, item): ...
