# Generated from _qpd_antlr/sql.g4 by ANTLR 4.10.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,297,2997,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,
        7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,
        13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,
        20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,
        26,2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,
        33,7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,
        39,2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,
        46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,
        52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,
        59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,
        65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,2,71,7,71,2,
        72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,77,2,78,7,
        78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,84,2,
        85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,7,
        91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,
        98,7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,
        2,104,7,104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,
        7,109,2,110,7,110,2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,
        2,115,7,115,2,116,7,116,2,117,7,117,2,118,7,118,2,119,7,119,2,120,
        7,120,2,121,7,121,2,122,7,122,2,123,7,123,2,124,7,124,2,125,7,125,
        2,126,7,126,2,127,7,127,2,128,7,128,2,129,7,129,2,130,7,130,2,131,
        7,131,2,132,7,132,2,133,7,133,2,134,7,134,2,135,7,135,2,136,7,136,
        1,0,1,0,5,0,277,8,0,10,0,12,0,280,9,0,1,0,1,0,1,1,1,1,1,1,1,2,1,
        2,1,2,1,3,1,3,1,3,1,4,1,4,1,4,1,5,1,5,1,5,1,6,1,6,1,6,1,7,1,7,3,
        7,304,8,7,1,7,1,7,1,7,3,7,309,8,7,1,7,1,7,1,7,1,7,1,7,1,7,3,7,317,
        8,7,1,7,1,7,1,7,1,7,1,7,1,7,5,7,325,8,7,10,7,12,7,328,9,7,1,7,1,
        7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,3,
        7,347,8,7,1,7,1,7,3,7,351,8,7,1,7,1,7,1,7,1,7,3,7,357,8,7,1,7,3,
        7,360,8,7,1,7,3,7,363,8,7,1,7,1,7,1,7,1,7,1,7,3,7,370,8,7,1,7,1,
        7,1,7,3,7,375,8,7,1,7,3,7,378,8,7,1,7,1,7,1,7,1,7,1,7,3,7,385,8,
        7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,3,7,397,8,7,1,7,1,7,1,
        7,1,7,1,7,1,7,1,7,5,7,406,8,7,10,7,12,7,409,9,7,1,7,3,7,412,8,7,
        1,7,3,7,415,8,7,1,7,1,7,1,7,1,7,1,7,3,7,422,8,7,1,7,1,7,1,7,1,7,
        1,7,1,7,1,7,1,7,1,7,5,7,433,8,7,10,7,12,7,436,9,7,1,7,1,7,1,7,1,
        7,1,7,3,7,443,8,7,1,7,1,7,1,7,3,7,448,8,7,1,7,3,7,451,8,7,1,7,1,
        7,1,7,1,7,3,7,457,8,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,3,7,468,
        8,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,
        1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,
        1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,
        1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,3,7,
        532,8,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,3,7,541,8,7,1,7,1,7,3,7,545,
        8,7,1,7,1,7,1,7,1,7,3,7,551,8,7,1,7,1,7,3,7,555,8,7,1,7,1,7,1,7,
        3,7,560,8,7,1,7,1,7,1,7,1,7,3,7,566,8,7,1,7,1,7,1,7,1,7,1,7,1,7,
        1,7,1,7,1,7,1,7,3,7,578,8,7,1,7,1,7,1,7,1,7,1,7,1,7,3,7,586,8,7,
        1,7,1,7,1,7,1,7,3,7,592,8,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,
        1,7,1,7,3,7,605,8,7,1,7,4,7,608,8,7,11,7,12,7,609,1,7,1,7,1,7,1,
        7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,3,7,626,8,7,1,7,1,7,1,
        7,5,7,631,8,7,10,7,12,7,634,9,7,1,7,3,7,637,8,7,1,7,1,7,1,7,1,7,
        3,7,643,8,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,
        3,7,658,8,7,1,7,1,7,3,7,662,8,7,1,7,1,7,1,7,1,7,3,7,668,8,7,1,7,
        1,7,1,7,1,7,3,7,674,8,7,1,7,3,7,677,8,7,1,7,3,7,680,8,7,1,7,1,7,
        1,7,1,7,3,7,686,8,7,1,7,1,7,3,7,690,8,7,1,7,1,7,1,7,1,7,1,7,1,7,
        5,7,698,8,7,10,7,12,7,701,9,7,1,7,1,7,1,7,1,7,1,7,1,7,3,7,709,8,
        7,1,7,3,7,712,8,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,3,7,721,8,7,1,7,1,
        7,1,7,3,7,726,8,7,1,7,1,7,1,7,1,7,3,7,732,8,7,1,7,1,7,1,7,1,7,1,
        7,3,7,739,8,7,1,7,3,7,742,8,7,1,7,1,7,1,7,1,7,3,7,748,8,7,1,7,1,
        7,1,7,1,7,1,7,1,7,1,7,5,7,757,8,7,10,7,12,7,760,9,7,3,7,762,8,7,
        1,7,1,7,3,7,766,8,7,1,7,1,7,1,7,3,7,771,8,7,1,7,1,7,1,7,3,7,776,
        8,7,1,7,1,7,1,7,1,7,1,7,3,7,783,8,7,1,7,3,7,786,8,7,1,7,3,7,789,
        8,7,1,7,1,7,1,7,1,7,1,7,3,7,796,8,7,1,7,1,7,1,7,3,7,801,8,7,1,7,
        1,7,1,7,1,7,1,7,1,7,1,7,3,7,810,8,7,1,7,1,7,1,7,1,7,1,7,1,7,3,7,
        818,8,7,1,7,1,7,1,7,1,7,3,7,824,8,7,1,7,3,7,827,8,7,1,7,3,7,830,
        8,7,1,7,1,7,1,7,1,7,3,7,836,8,7,1,7,1,7,3,7,840,8,7,1,7,1,7,3,7,
        844,8,7,1,7,1,7,3,7,848,8,7,3,7,850,8,7,1,7,1,7,1,7,1,7,1,7,1,7,
        3,7,858,8,7,1,7,1,7,1,7,1,7,1,7,1,7,3,7,866,8,7,1,7,1,7,1,7,1,7,
        3,7,872,8,7,1,7,1,7,1,7,1,7,3,7,878,8,7,1,7,3,7,881,8,7,1,7,1,7,
        3,7,885,8,7,1,7,3,7,888,8,7,1,7,1,7,3,7,892,8,7,1,7,1,7,1,7,1,7,
        1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,
        1,7,5,7,915,8,7,10,7,12,7,918,9,7,3,7,920,8,7,1,7,1,7,3,7,924,8,
        7,1,7,1,7,1,7,1,7,3,7,930,8,7,1,7,3,7,933,8,7,1,7,3,7,936,8,7,1,
        7,1,7,1,7,1,7,3,7,942,8,7,1,7,1,7,1,7,1,7,1,7,1,7,3,7,950,8,7,1,
        7,1,7,1,7,3,7,955,8,7,1,7,1,7,1,7,1,7,3,7,961,8,7,1,7,1,7,1,7,1,
        7,3,7,967,8,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,5,7,977,8,7,10,7,12,
        7,980,9,7,3,7,982,8,7,1,7,1,7,1,7,5,7,987,8,7,10,7,12,7,990,9,7,
        1,7,1,7,5,7,994,8,7,10,7,12,7,997,9,7,1,7,1,7,1,7,5,7,1002,8,7,10,
        7,12,7,1005,9,7,3,7,1007,8,7,1,8,1,8,1,8,1,8,1,8,1,8,3,8,1015,8,
        8,1,8,1,8,3,8,1019,8,8,1,8,1,8,1,8,1,8,1,8,3,8,1026,8,8,1,8,1,8,
        1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,
        1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,
        1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,
        1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,
        1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,
        1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,
        1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,
        3,8,1142,8,8,1,8,1,8,1,8,1,8,1,8,1,8,3,8,1150,8,8,1,8,1,8,1,8,1,
        8,1,8,1,8,3,8,1158,8,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,3,8,1167,8,8,
        1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,3,8,1177,8,8,1,9,1,9,3,9,1181,8,
        9,1,9,3,9,1184,8,9,1,9,1,9,1,9,1,9,3,9,1190,8,9,1,9,1,9,1,10,1,10,
        3,10,1196,8,10,1,10,1,10,1,10,1,10,1,11,1,11,1,11,1,11,1,11,1,11,
        3,11,1208,8,11,1,11,1,11,1,11,1,11,1,12,1,12,1,12,1,12,1,12,1,12,
        3,12,1220,8,12,1,12,1,12,1,12,3,12,1225,8,12,1,13,1,13,1,13,1,14,
        1,14,1,14,1,15,3,15,1234,8,15,1,15,1,15,1,15,1,16,1,16,1,16,3,16,
        1242,8,16,1,16,1,16,1,16,1,16,1,16,3,16,1249,8,16,3,16,1251,8,16,
        1,16,1,16,1,16,3,16,1256,8,16,1,16,1,16,3,16,1260,8,16,1,16,1,16,
        1,16,3,16,1265,8,16,1,16,1,16,1,16,3,16,1270,8,16,1,16,1,16,1,16,
        3,16,1275,8,16,1,16,3,16,1278,8,16,1,16,1,16,1,16,3,16,1283,8,16,
        1,16,1,16,3,16,1287,8,16,1,16,1,16,1,16,3,16,1292,8,16,3,16,1294,
        8,16,1,17,1,17,3,17,1298,8,17,1,18,1,18,1,18,1,18,1,18,5,18,1305,
        8,18,10,18,12,18,1308,9,18,1,18,1,18,1,19,1,19,1,19,3,19,1315,8,
        19,1,20,1,20,1,21,1,21,1,21,1,21,1,21,3,21,1324,8,21,1,22,1,22,1,
        22,5,22,1329,8,22,10,22,12,22,1332,9,22,1,23,1,23,1,23,1,23,5,23,
        1338,8,23,10,23,12,23,1341,9,23,1,24,1,24,3,24,1345,8,24,1,24,3,
        24,1348,8,24,1,24,1,24,1,24,1,24,1,25,1,25,1,25,1,26,1,26,1,26,1,
        26,1,26,1,26,1,26,1,26,1,26,1,26,5,26,1367,8,26,10,26,12,26,1370,
        9,26,1,27,1,27,1,27,1,27,5,27,1376,8,27,10,27,12,27,1379,9,27,1,
        27,1,27,1,28,1,28,3,28,1385,8,28,1,28,3,28,1388,8,28,1,29,1,29,1,
        29,5,29,1393,8,29,10,29,12,29,1396,9,29,1,29,3,29,1399,8,29,1,30,
        1,30,1,30,1,30,3,30,1405,8,30,1,31,1,31,1,31,1,31,5,31,1411,8,31,
        10,31,12,31,1414,9,31,1,31,1,31,1,32,1,32,1,32,1,32,5,32,1422,8,
        32,10,32,12,32,1425,9,32,1,32,1,32,1,33,1,33,1,33,1,33,1,33,1,33,
        3,33,1435,8,33,1,34,1,34,1,34,1,34,1,34,3,34,1442,8,34,1,35,1,35,
        1,35,1,35,3,35,1448,8,35,1,36,1,36,1,36,1,37,1,37,1,37,1,37,1,37,
        1,37,4,37,1459,8,37,11,37,12,37,1460,1,37,1,37,1,37,1,37,1,37,3,
        37,1468,8,37,1,37,1,37,1,37,1,37,1,37,3,37,1475,8,37,1,37,1,37,1,
        37,1,37,1,37,1,37,1,37,1,37,1,37,1,37,3,37,1487,8,37,1,37,1,37,1,
        37,1,37,5,37,1493,8,37,10,37,12,37,1496,9,37,1,37,5,37,1499,8,37,
        10,37,12,37,1502,9,37,3,37,1504,8,37,1,38,1,38,1,38,1,38,1,38,5,
        38,1511,8,38,10,38,12,38,1514,9,38,3,38,1516,8,38,1,38,1,38,1,38,
        1,38,1,38,5,38,1523,8,38,10,38,12,38,1526,9,38,3,38,1528,8,38,1,
        38,1,38,1,38,1,38,1,38,5,38,1535,8,38,10,38,12,38,1538,9,38,3,38,
        1540,8,38,1,38,1,38,1,38,1,38,1,38,5,38,1547,8,38,10,38,12,38,1550,
        9,38,3,38,1552,8,38,1,38,3,38,1555,8,38,1,38,1,38,1,38,3,38,1560,
        8,38,3,38,1562,8,38,1,39,1,39,1,39,1,40,1,40,1,40,1,40,1,40,1,40,
        1,40,3,40,1574,8,40,1,40,1,40,1,40,1,40,1,40,3,40,1581,8,40,1,40,
        1,40,1,40,1,40,1,40,3,40,1588,8,40,1,40,5,40,1591,8,40,10,40,12,
        40,1594,9,40,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,3,41,1605,
        8,41,1,42,1,42,3,42,1609,8,42,1,42,1,42,3,42,1613,8,42,1,43,1,43,
        4,43,1617,8,43,11,43,12,43,1618,1,44,1,44,3,44,1623,8,44,1,44,1,
        44,1,44,1,44,5,44,1629,8,44,10,44,12,44,1632,9,44,1,44,3,44,1635,
        8,44,1,44,3,44,1638,8,44,1,44,3,44,1641,8,44,1,44,3,44,1644,8,44,
        1,44,1,44,3,44,1648,8,44,1,45,1,45,3,45,1652,8,45,1,45,3,45,1655,
        8,45,1,45,1,45,3,45,1659,8,45,1,45,5,45,1662,8,45,10,45,12,45,1665,
        9,45,1,45,3,45,1668,8,45,1,45,3,45,1671,8,45,1,45,3,45,1674,8,45,
        1,45,3,45,1677,8,45,3,45,1679,8,45,1,46,1,46,1,46,1,46,1,46,1,46,
        1,46,1,46,1,46,1,46,3,46,1691,8,46,1,46,3,46,1694,8,46,1,46,1,46,
        3,46,1698,8,46,1,46,1,46,1,46,1,46,1,46,1,46,1,46,1,46,3,46,1708,
        8,46,1,46,1,46,3,46,1712,8,46,3,46,1714,8,46,1,46,3,46,1717,8,46,
        1,46,1,46,3,46,1721,8,46,1,47,1,47,5,47,1725,8,47,10,47,12,47,1728,
        9,47,1,47,3,47,1731,8,47,1,47,1,47,1,48,1,48,1,48,1,49,1,49,1,49,
        1,49,3,49,1742,8,49,1,49,1,49,1,49,1,50,1,50,1,50,1,50,1,50,3,50,
        1752,8,50,1,50,1,50,1,50,1,51,1,51,1,51,1,51,1,51,1,51,1,51,3,51,
        1764,8,51,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,1,52,
        5,52,1777,8,52,10,52,12,52,1780,9,52,1,52,1,52,3,52,1784,8,52,1,
        53,1,53,1,53,5,53,1789,8,53,10,53,12,53,1792,9,53,1,54,1,54,1,54,
        1,54,1,55,1,55,1,55,1,56,1,56,1,56,1,57,1,57,1,57,3,57,1807,8,57,
        1,57,5,57,1810,8,57,10,57,12,57,1813,9,57,1,57,1,57,1,58,1,58,1,
        58,1,58,1,58,1,58,5,58,1823,8,58,10,58,12,58,1826,9,58,1,58,1,58,
        3,58,1830,8,58,1,59,1,59,1,59,1,59,5,59,1836,8,59,10,59,12,59,1839,
        9,59,1,59,5,59,1842,8,59,10,59,12,59,1845,9,59,1,59,3,59,1848,8,
        59,1,60,1,60,1,60,1,60,1,60,5,60,1855,8,60,10,60,12,60,1858,9,60,
        1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,1,60,5,60,1870,8,60,
        10,60,12,60,1873,9,60,1,60,1,60,3,60,1877,8,60,1,60,1,60,1,60,1,
        60,1,60,1,60,1,60,1,60,5,60,1887,8,60,10,60,12,60,1890,9,60,1,60,
        1,60,3,60,1894,8,60,1,61,1,61,1,61,1,61,5,61,1900,8,61,10,61,12,
        61,1903,9,61,3,61,1905,8,61,1,61,1,61,3,61,1909,8,61,1,62,1,62,1,
        62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,5,62,1921,8,62,10,62,12,62,
        1924,9,62,1,62,1,62,1,62,1,63,1,63,1,63,1,63,1,63,5,63,1934,8,63,
        10,63,12,63,1937,9,63,1,63,1,63,3,63,1941,8,63,1,64,1,64,3,64,1945,
        8,64,1,64,3,64,1948,8,64,1,65,1,65,1,65,3,65,1953,8,65,1,65,1,65,
        1,65,1,65,1,65,5,65,1960,8,65,10,65,12,65,1963,9,65,3,65,1965,8,
        65,1,65,1,65,1,65,3,65,1970,8,65,1,65,1,65,1,65,5,65,1975,8,65,10,
        65,12,65,1978,9,65,3,65,1980,8,65,1,66,1,66,1,67,1,67,5,67,1986,
        8,67,10,67,12,67,1989,9,67,1,68,1,68,1,68,1,68,3,68,1995,8,68,1,
        68,1,68,1,68,1,68,1,68,3,68,2002,8,68,1,69,3,69,2005,8,69,1,69,1,
        69,1,69,3,69,2010,8,69,1,69,3,69,2013,8,69,1,69,1,69,1,69,3,69,2018,
        8,69,1,69,1,69,3,69,2022,8,69,1,69,3,69,2025,8,69,1,69,3,69,2028,
        8,69,1,70,1,70,1,70,1,70,3,70,2034,8,70,1,71,1,71,1,71,3,71,2039,
        8,71,1,71,1,71,1,72,3,72,2044,8,72,1,72,1,72,1,72,1,72,1,72,1,72,
        1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,3,72,2062,8,72,
        3,72,2064,8,72,1,72,3,72,2067,8,72,1,73,1,73,1,73,1,73,1,74,1,74,
        1,74,5,74,2076,8,74,10,74,12,74,2079,9,74,1,75,1,75,1,75,1,75,5,
        75,2085,8,75,10,75,12,75,2088,9,75,1,75,1,75,1,76,1,76,3,76,2094,
        8,76,1,77,1,77,1,77,1,77,5,77,2100,8,77,10,77,12,77,2103,9,77,1,
        77,1,77,1,78,1,78,3,78,2109,8,78,1,79,1,79,3,79,2113,8,79,1,79,1,
        79,1,79,1,79,1,79,1,79,3,79,2121,8,79,1,79,1,79,1,79,1,79,1,79,1,
        79,3,79,2129,8,79,1,79,1,79,3,79,2133,8,79,1,80,1,80,1,80,1,80,5,
        80,2139,8,80,10,80,12,80,2142,9,80,1,80,1,80,1,81,1,81,1,81,1,81,
        1,81,5,81,2151,8,81,10,81,12,81,2154,9,81,3,81,2156,8,81,1,81,1,
        81,1,81,1,82,3,82,2162,8,82,1,82,1,82,3,82,2166,8,82,3,82,2168,8,
        82,1,83,1,83,1,83,1,83,1,83,1,83,1,83,3,83,2177,8,83,1,83,1,83,1,
        83,1,83,1,83,1,83,1,83,1,83,1,83,1,83,3,83,2189,8,83,3,83,2191,8,
        83,1,83,1,83,1,83,1,83,1,83,3,83,2198,8,83,1,83,1,83,1,83,1,83,1,
        83,3,83,2205,8,83,1,83,1,83,1,83,1,83,3,83,2211,8,83,1,83,1,83,1,
        83,1,83,3,83,2217,8,83,3,83,2219,8,83,1,84,1,84,1,84,5,84,2224,8,
        84,10,84,12,84,2227,9,84,1,85,1,85,1,85,5,85,2232,8,85,10,85,12,
        85,2235,9,85,1,86,1,86,1,86,3,86,2240,8,86,1,86,1,86,1,87,1,87,1,
        87,3,87,2247,8,87,1,87,1,87,1,88,1,88,3,88,2253,8,88,1,88,1,88,3,
        88,2257,8,88,3,88,2259,8,88,1,89,1,89,1,89,5,89,2264,8,89,10,89,
        12,89,2267,9,89,1,90,1,90,1,90,1,90,5,90,2273,8,90,10,90,12,90,2276,
        9,90,1,90,1,90,1,91,1,91,1,91,1,91,1,91,1,91,5,91,2286,8,91,10,91,
        12,91,2289,9,91,1,91,1,91,3,91,2293,8,91,1,92,1,92,3,92,2297,8,92,
        1,93,1,93,1,94,1,94,1,94,1,94,1,94,1,94,1,94,1,94,1,94,1,94,3,94,
        2311,8,94,3,94,2313,8,94,1,94,1,94,1,94,1,94,1,94,1,94,5,94,2321,
        8,94,10,94,12,94,2324,9,94,1,95,3,95,2327,8,95,1,95,1,95,1,95,1,
        95,1,95,1,95,3,95,2335,8,95,1,95,1,95,1,95,1,95,1,95,5,95,2342,8,
        95,10,95,12,95,2345,9,95,1,95,1,95,1,95,3,95,2350,8,95,1,95,1,95,
        1,95,1,95,1,95,1,95,3,95,2358,8,95,1,95,1,95,1,95,3,95,2363,8,95,
        1,95,1,95,1,95,1,95,1,95,1,95,1,95,1,95,5,95,2373,8,95,10,95,12,
        95,2376,9,95,1,95,1,95,3,95,2380,8,95,1,95,3,95,2383,8,95,1,95,1,
        95,1,95,1,95,3,95,2389,8,95,1,95,1,95,3,95,2393,8,95,1,95,1,95,1,
        95,3,95,2398,8,95,1,95,1,95,1,95,3,95,2403,8,95,1,95,1,95,1,95,3,
        95,2408,8,95,1,96,1,96,1,96,1,96,3,96,2414,8,96,1,96,1,96,1,96,1,
        96,1,96,1,96,1,96,1,96,1,96,1,96,1,96,1,96,1,96,1,96,1,96,1,96,1,
        96,1,96,1,96,5,96,2435,8,96,10,96,12,96,2438,9,96,1,97,1,97,1,97,
        1,97,4,97,2444,8,97,11,97,12,97,2445,1,97,1,97,3,97,2450,8,97,1,
        97,1,97,1,97,1,97,1,97,4,97,2457,8,97,11,97,12,97,2458,1,97,1,97,
        3,97,2463,8,97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,
        1,97,1,97,1,97,1,97,5,97,2479,8,97,10,97,12,97,2482,9,97,3,97,2484,
        8,97,1,97,1,97,1,97,1,97,1,97,1,97,3,97,2492,8,97,1,97,1,97,1,97,
        1,97,1,97,1,97,1,97,3,97,2501,8,97,1,97,1,97,1,97,1,97,1,97,1,97,
        1,97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,
        4,97,2522,8,97,11,97,12,97,2523,1,97,1,97,1,97,1,97,1,97,1,97,1,
        97,1,97,1,97,3,97,2535,8,97,1,97,1,97,1,97,5,97,2540,8,97,10,97,
        12,97,2543,9,97,3,97,2545,8,97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,
        3,97,2554,8,97,1,97,1,97,3,97,2558,8,97,1,97,1,97,1,97,1,97,1,97,
        1,97,1,97,1,97,4,97,2568,8,97,11,97,12,97,2569,1,97,1,97,1,97,1,
        97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,1,
        97,1,97,1,97,1,97,1,97,1,97,1,97,3,97,2595,8,97,1,97,1,97,1,97,1,
        97,1,97,3,97,2602,8,97,1,97,3,97,2605,8,97,1,97,1,97,1,97,1,97,1,
        97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,3,97,2620,8,97,1,97,1,
        97,3,97,2624,8,97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,1,97,5,97,2634,
        8,97,10,97,12,97,2637,9,97,1,98,1,98,1,98,1,98,1,98,1,98,1,98,1,
        98,4,98,2647,8,98,11,98,12,98,2648,3,98,2651,8,98,1,99,1,99,1,100,
        1,100,1,101,1,101,1,102,1,102,1,103,1,103,1,103,3,103,2664,8,103,
        1,104,1,104,3,104,2668,8,104,1,105,1,105,1,105,4,105,2673,8,105,
        11,105,12,105,2674,1,106,1,106,1,106,3,106,2680,8,106,1,107,1,107,
        1,107,1,107,1,107,1,108,3,108,2688,8,108,1,108,1,108,3,108,2692,
        8,108,1,109,1,109,1,109,1,109,1,109,1,109,1,109,3,109,2701,8,109,
        1,110,1,110,1,110,3,110,2706,8,110,1,111,1,111,1,111,1,111,1,111,
        1,111,1,111,1,111,1,111,1,111,1,111,1,111,1,111,1,111,1,111,3,111,
        2723,8,111,1,111,1,111,3,111,2727,8,111,1,111,1,111,1,111,1,111,
        1,111,5,111,2734,8,111,10,111,12,111,2737,9,111,1,111,3,111,2740,
        8,111,3,111,2742,8,111,1,112,1,112,1,112,5,112,2747,8,112,10,112,
        12,112,2750,9,112,1,113,1,113,1,113,1,113,3,113,2756,8,113,1,113,
        3,113,2759,8,113,1,113,3,113,2762,8,113,1,114,1,114,1,114,5,114,
        2767,8,114,10,114,12,114,2770,9,114,1,115,1,115,1,115,1,115,3,115,
        2776,8,115,1,115,3,115,2779,8,115,1,116,1,116,1,116,5,116,2784,8,
        116,10,116,12,116,2787,9,116,1,117,1,117,1,117,1,117,1,117,3,117,
        2794,8,117,1,117,3,117,2797,8,117,1,118,1,118,1,118,1,118,1,118,
        1,119,1,119,1,119,1,119,5,119,2808,8,119,10,119,12,119,2811,9,119,
        1,120,1,120,1,120,1,120,1,121,1,121,1,121,1,121,1,121,1,121,1,121,
        1,121,1,121,1,121,1,121,5,121,2828,8,121,10,121,12,121,2831,9,121,
        1,121,1,121,1,121,1,121,1,121,5,121,2838,8,121,10,121,12,121,2841,
        9,121,3,121,2843,8,121,1,121,1,121,1,121,1,121,1,121,5,121,2850,
        8,121,10,121,12,121,2853,9,121,3,121,2855,8,121,3,121,2857,8,121,
        1,121,3,121,2860,8,121,1,121,3,121,2863,8,121,1,122,1,122,1,122,
        1,122,1,122,1,122,1,122,1,122,1,122,1,122,1,122,1,122,1,122,1,122,
        1,122,1,122,3,122,2881,8,122,1,123,1,123,1,123,1,123,1,123,1,123,
        1,123,3,123,2890,8,123,1,124,1,124,1,124,5,124,2895,8,124,10,124,
        12,124,2898,9,124,1,125,1,125,1,125,1,125,3,125,2904,8,125,1,126,
        1,126,1,126,5,126,2909,8,126,10,126,12,126,2912,9,126,1,127,1,127,
        1,127,1,128,1,128,4,128,2919,8,128,11,128,12,128,2920,1,128,3,128,
        2924,8,128,1,129,1,129,1,129,3,129,2929,8,129,1,130,1,130,1,130,
        1,130,1,130,1,130,3,130,2937,8,130,1,131,1,131,1,132,1,132,3,132,
        2943,8,132,1,132,1,132,1,132,3,132,2948,8,132,1,132,1,132,1,132,
        3,132,2953,8,132,1,132,1,132,3,132,2957,8,132,1,132,1,132,3,132,
        2961,8,132,1,132,1,132,3,132,2965,8,132,1,132,1,132,3,132,2969,8,
        132,1,132,1,132,3,132,2973,8,132,1,132,1,132,3,132,2977,8,132,1,
        132,3,132,2980,8,132,1,133,1,133,1,133,1,133,1,133,1,133,1,133,3,
        133,2989,8,133,1,134,1,134,1,135,1,135,1,136,1,136,1,136,5,916,978,
        988,995,1003,4,80,188,192,194,137,0,2,4,6,8,10,12,14,16,18,20,22,
        24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,
        68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,
        108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,
        140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,
        172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,
        204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,
        236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,
        268,270,272,0,42,2,0,65,65,180,180,2,0,32,32,194,194,2,0,63,63,150,
        150,2,0,100,100,113,113,1,0,43,44,2,0,227,227,257,257,2,0,15,15,
        35,35,5,0,40,40,52,52,86,86,99,99,141,141,1,0,69,70,2,0,86,86,99,
        99,2,0,154,154,283,283,2,0,12,12,135,135,3,0,62,62,149,149,204,204,
        4,0,81,81,120,120,213,213,247,247,3,0,81,81,213,213,247,247,2,0,
        23,23,69,69,2,0,94,94,127,127,2,0,14,14,74,74,2,0,287,287,289,289,
        3,0,14,14,19,19,217,217,3,0,89,89,241,241,249,249,2,0,272,273,278,
        278,1,0,274,277,2,0,272,273,281,281,2,0,57,57,59,59,1,0,225,226,
        2,0,4,4,100,100,2,0,4,4,96,96,3,0,27,27,130,130,236,236,1,0,264,
        271,1,0,272,282,4,0,17,17,113,113,153,153,161,161,2,0,89,89,241,
        241,1,0,272,273,2,0,75,75,170,170,2,0,162,162,218,218,2,0,95,95,
        177,177,1,0,288,289,2,0,76,76,212,212,51,0,12,13,15,16,20,21,23,
        24,26,26,28,32,35,35,37,40,42,42,44,50,52,52,55,56,61,63,65,73,75,
        76,80,80,82,88,91,91,93,95,98,99,102,104,107,107,110,112,114,115,
        117,119,121,121,124,124,126,129,132,145,148,150,152,152,155,156,
        159,160,163,163,165,166,168,177,179,187,189,195,197,204,208,210,
        212,212,214,216,218,226,228,232,235,235,237,242,244,246,250,253,
        256,258,261,261,277,277,15,0,18,18,54,54,81,81,101,101,116,116,120,
        120,125,125,131,131,151,151,157,157,196,196,207,207,213,213,247,
        247,255,255,17,0,12,17,19,53,55,80,82,100,102,115,117,119,121,124,
        126,130,132,150,152,156,158,195,197,206,208,212,214,246,248,254,
        256,263,277,277,3462,0,274,1,0,0,0,2,283,1,0,0,0,4,286,1,0,0,0,6,
        289,1,0,0,0,8,292,1,0,0,0,10,295,1,0,0,0,12,298,1,0,0,0,14,1006,
        1,0,0,0,16,1176,1,0,0,0,18,1178,1,0,0,0,20,1195,1,0,0,0,22,1201,
        1,0,0,0,24,1213,1,0,0,0,26,1226,1,0,0,0,28,1229,1,0,0,0,30,1233,
        1,0,0,0,32,1293,1,0,0,0,34,1295,1,0,0,0,36,1299,1,0,0,0,38,1311,
        1,0,0,0,40,1316,1,0,0,0,42,1323,1,0,0,0,44,1325,1,0,0,0,46,1333,
        1,0,0,0,48,1342,1,0,0,0,50,1353,1,0,0,0,52,1368,1,0,0,0,54,1371,
        1,0,0,0,56,1382,1,0,0,0,58,1398,1,0,0,0,60,1404,1,0,0,0,62,1406,
        1,0,0,0,64,1417,1,0,0,0,66,1434,1,0,0,0,68,1441,1,0,0,0,70,1443,
        1,0,0,0,72,1449,1,0,0,0,74,1503,1,0,0,0,76,1515,1,0,0,0,78,1563,
        1,0,0,0,80,1566,1,0,0,0,82,1604,1,0,0,0,84,1606,1,0,0,0,86,1614,
        1,0,0,0,88,1647,1,0,0,0,90,1678,1,0,0,0,92,1690,1,0,0,0,94,1722,
        1,0,0,0,96,1734,1,0,0,0,98,1737,1,0,0,0,100,1746,1,0,0,0,102,1763,
        1,0,0,0,104,1783,1,0,0,0,106,1785,1,0,0,0,108,1793,1,0,0,0,110,1797,
        1,0,0,0,112,1800,1,0,0,0,114,1803,1,0,0,0,116,1829,1,0,0,0,118,1831,
        1,0,0,0,120,1893,1,0,0,0,122,1908,1,0,0,0,124,1910,1,0,0,0,126,1940,
        1,0,0,0,128,1942,1,0,0,0,130,1949,1,0,0,0,132,1981,1,0,0,0,134,1983,
        1,0,0,0,136,2001,1,0,0,0,138,2027,1,0,0,0,140,2033,1,0,0,0,142,2035,
        1,0,0,0,144,2066,1,0,0,0,146,2068,1,0,0,0,148,2072,1,0,0,0,150,2080,
        1,0,0,0,152,2091,1,0,0,0,154,2095,1,0,0,0,156,2106,1,0,0,0,158,2132,
        1,0,0,0,160,2134,1,0,0,0,162,2145,1,0,0,0,164,2167,1,0,0,0,166,2218,
        1,0,0,0,168,2220,1,0,0,0,170,2228,1,0,0,0,172,2239,1,0,0,0,174,2246,
        1,0,0,0,176,2250,1,0,0,0,178,2260,1,0,0,0,180,2268,1,0,0,0,182,2292,
        1,0,0,0,184,2296,1,0,0,0,186,2298,1,0,0,0,188,2312,1,0,0,0,190,2407,
        1,0,0,0,192,2413,1,0,0,0,194,2623,1,0,0,0,196,2650,1,0,0,0,198,2652,
        1,0,0,0,200,2654,1,0,0,0,202,2656,1,0,0,0,204,2658,1,0,0,0,206,2660,
        1,0,0,0,208,2665,1,0,0,0,210,2672,1,0,0,0,212,2676,1,0,0,0,214,2681,
        1,0,0,0,216,2691,1,0,0,0,218,2700,1,0,0,0,220,2705,1,0,0,0,222,2741,
        1,0,0,0,224,2743,1,0,0,0,226,2751,1,0,0,0,228,2763,1,0,0,0,230,2771,
        1,0,0,0,232,2780,1,0,0,0,234,2788,1,0,0,0,236,2798,1,0,0,0,238,2803,
        1,0,0,0,240,2812,1,0,0,0,242,2862,1,0,0,0,244,2880,1,0,0,0,246,2889,
        1,0,0,0,248,2891,1,0,0,0,250,2903,1,0,0,0,252,2905,1,0,0,0,254,2913,
        1,0,0,0,256,2923,1,0,0,0,258,2928,1,0,0,0,260,2936,1,0,0,0,262,2938,
        1,0,0,0,264,2979,1,0,0,0,266,2988,1,0,0,0,268,2990,1,0,0,0,270,2992,
        1,0,0,0,272,2994,1,0,0,0,274,278,3,14,7,0,275,277,5,1,0,0,276,275,
        1,0,0,0,277,280,1,0,0,0,278,276,1,0,0,0,278,279,1,0,0,0,279,281,
        1,0,0,0,280,278,1,0,0,0,281,282,5,0,0,1,282,1,1,0,0,0,283,284,3,
        176,88,0,284,285,5,0,0,1,285,3,1,0,0,0,286,287,3,172,86,0,287,288,
        5,0,0,1,288,5,1,0,0,0,289,290,3,170,85,0,290,291,5,0,0,1,291,7,1,
        0,0,0,292,293,3,174,87,0,293,294,5,0,0,1,294,9,1,0,0,0,295,296,3,
        222,111,0,296,297,5,0,0,1,297,11,1,0,0,0,298,299,3,228,114,0,299,
        300,5,0,0,1,300,13,1,0,0,0,301,1007,3,30,15,0,302,304,3,46,23,0,
        303,302,1,0,0,0,303,304,1,0,0,0,304,305,1,0,0,0,305,1007,3,74,37,
        0,306,308,5,253,0,0,307,309,5,149,0,0,308,307,1,0,0,0,308,309,1,
        0,0,0,309,310,1,0,0,0,310,1007,3,170,85,0,311,312,5,53,0,0,312,316,
        3,40,20,0,313,314,5,110,0,0,314,315,5,153,0,0,315,317,5,83,0,0,316,
        313,1,0,0,0,316,317,1,0,0,0,317,318,1,0,0,0,318,326,3,170,85,0,319,
        325,3,28,14,0,320,325,3,26,13,0,321,322,5,262,0,0,322,323,7,0,0,
        0,323,325,3,54,27,0,324,319,1,0,0,0,324,320,1,0,0,0,324,321,1,0,
        0,0,325,328,1,0,0,0,326,324,1,0,0,0,326,327,1,0,0,0,327,1007,1,0,
        0,0,328,326,1,0,0,0,329,330,5,15,0,0,330,331,3,40,20,0,331,332,3,
        170,85,0,332,333,5,212,0,0,333,334,7,0,0,0,334,335,3,54,27,0,335,
        1007,1,0,0,0,336,337,5,15,0,0,337,338,3,40,20,0,338,339,3,170,85,
        0,339,340,5,212,0,0,340,341,3,26,13,0,341,1007,1,0,0,0,342,343,5,
        76,0,0,343,346,3,40,20,0,344,345,5,110,0,0,345,347,5,83,0,0,346,
        344,1,0,0,0,346,347,1,0,0,0,347,348,1,0,0,0,348,350,3,170,85,0,349,
        351,7,1,0,0,350,349,1,0,0,0,350,351,1,0,0,0,351,1007,1,0,0,0,352,
        353,5,215,0,0,353,356,7,2,0,0,354,355,7,3,0,0,355,357,3,170,85,0,
        356,354,1,0,0,0,356,357,1,0,0,0,357,362,1,0,0,0,358,360,5,132,0,
        0,359,358,1,0,0,0,359,360,1,0,0,0,360,361,1,0,0,0,361,363,5,283,
        0,0,362,359,1,0,0,0,362,363,1,0,0,0,363,1007,1,0,0,0,364,369,3,18,
        9,0,365,366,5,2,0,0,366,367,3,228,114,0,367,368,5,3,0,0,368,370,
        1,0,0,0,369,365,1,0,0,0,369,370,1,0,0,0,370,371,1,0,0,0,371,372,
        3,50,25,0,372,377,3,52,26,0,373,375,5,22,0,0,374,373,1,0,0,0,374,
        375,1,0,0,0,375,376,1,0,0,0,376,378,3,30,15,0,377,374,1,0,0,0,377,
        378,1,0,0,0,378,1007,1,0,0,0,379,384,3,18,9,0,380,381,5,2,0,0,381,
        382,3,228,114,0,382,383,5,3,0,0,383,385,1,0,0,0,384,380,1,0,0,0,
        384,385,1,0,0,0,385,407,1,0,0,0,386,406,3,28,14,0,387,388,5,171,
        0,0,388,389,5,30,0,0,389,390,5,2,0,0,390,391,3,228,114,0,391,392,
        5,3,0,0,392,397,1,0,0,0,393,394,5,171,0,0,394,395,5,30,0,0,395,397,
        3,146,73,0,396,387,1,0,0,0,396,393,1,0,0,0,397,406,1,0,0,0,398,406,
        3,22,11,0,399,406,3,24,12,0,400,406,3,166,83,0,401,406,3,66,33,0,
        402,406,3,26,13,0,403,404,5,230,0,0,404,406,3,54,27,0,405,386,1,
        0,0,0,405,396,1,0,0,0,405,398,1,0,0,0,405,399,1,0,0,0,405,400,1,
        0,0,0,405,401,1,0,0,0,405,402,1,0,0,0,405,403,1,0,0,0,406,409,1,
        0,0,0,407,405,1,0,0,0,407,408,1,0,0,0,408,414,1,0,0,0,409,407,1,
        0,0,0,410,412,5,22,0,0,411,410,1,0,0,0,411,412,1,0,0,0,412,413,1,
        0,0,0,413,415,3,30,15,0,414,411,1,0,0,0,414,415,1,0,0,0,415,1007,
        1,0,0,0,416,417,5,53,0,0,417,421,5,227,0,0,418,419,5,110,0,0,419,
        420,5,153,0,0,420,422,5,83,0,0,421,418,1,0,0,0,421,422,1,0,0,0,422,
        423,1,0,0,0,423,424,3,172,86,0,424,425,5,132,0,0,425,434,3,172,86,
        0,426,433,3,50,25,0,427,433,3,166,83,0,428,433,3,66,33,0,429,433,
        3,26,13,0,430,431,5,230,0,0,431,433,3,54,27,0,432,426,1,0,0,0,432,
        427,1,0,0,0,432,428,1,0,0,0,432,429,1,0,0,0,432,430,1,0,0,0,433,
        436,1,0,0,0,434,432,1,0,0,0,434,435,1,0,0,0,435,1007,1,0,0,0,436,
        434,1,0,0,0,437,442,3,20,10,0,438,439,5,2,0,0,439,440,3,228,114,
        0,440,441,5,3,0,0,441,443,1,0,0,0,442,438,1,0,0,0,442,443,1,0,0,
        0,443,444,1,0,0,0,444,445,3,50,25,0,445,450,3,52,26,0,446,448,5,
        22,0,0,447,446,1,0,0,0,447,448,1,0,0,0,448,449,1,0,0,0,449,451,3,
        30,15,0,450,447,1,0,0,0,450,451,1,0,0,0,451,1007,1,0,0,0,452,453,
        5,16,0,0,453,454,5,227,0,0,454,456,3,170,85,0,455,457,3,36,18,0,
        456,455,1,0,0,0,456,457,1,0,0,0,457,458,1,0,0,0,458,459,5,49,0,0,
        459,467,5,221,0,0,460,468,3,258,129,0,461,462,5,96,0,0,462,463,5,
        44,0,0,463,468,3,148,74,0,464,465,5,96,0,0,465,466,5,14,0,0,466,
        468,5,44,0,0,467,460,1,0,0,0,467,461,1,0,0,0,467,464,1,0,0,0,467,
        468,1,0,0,0,468,1007,1,0,0,0,469,470,5,15,0,0,470,471,5,227,0,0,
        471,472,3,170,85,0,472,473,5,12,0,0,473,474,7,4,0,0,474,475,3,224,
        112,0,475,1007,1,0,0,0,476,477,5,15,0,0,477,478,5,227,0,0,478,479,
        3,170,85,0,479,480,5,12,0,0,480,481,7,4,0,0,481,482,5,2,0,0,482,
        483,3,224,112,0,483,484,5,3,0,0,484,1007,1,0,0,0,485,486,5,15,0,
        0,486,487,5,227,0,0,487,488,3,170,85,0,488,489,5,190,0,0,489,490,
        5,43,0,0,490,491,3,170,85,0,491,492,5,234,0,0,492,493,3,254,127,
        0,493,1007,1,0,0,0,494,495,5,15,0,0,495,496,5,227,0,0,496,497,3,
        170,85,0,497,498,5,76,0,0,498,499,7,4,0,0,499,500,5,2,0,0,500,501,
        3,168,84,0,501,502,5,3,0,0,502,1007,1,0,0,0,503,504,5,15,0,0,504,
        505,5,227,0,0,505,506,3,170,85,0,506,507,5,76,0,0,507,508,7,4,0,
        0,508,509,3,168,84,0,509,1007,1,0,0,0,510,511,5,15,0,0,511,512,7,
        5,0,0,512,513,3,170,85,0,513,514,5,190,0,0,514,515,5,234,0,0,515,
        516,3,170,85,0,516,1007,1,0,0,0,517,518,5,15,0,0,518,519,7,5,0,0,
        519,520,3,170,85,0,520,521,5,212,0,0,521,522,5,230,0,0,522,523,3,
        54,27,0,523,1007,1,0,0,0,524,525,5,15,0,0,525,526,7,5,0,0,526,527,
        3,170,85,0,527,528,5,251,0,0,528,531,5,230,0,0,529,530,5,110,0,0,
        530,532,5,83,0,0,531,529,1,0,0,0,531,532,1,0,0,0,532,533,1,0,0,0,
        533,534,3,54,27,0,534,1007,1,0,0,0,535,536,5,15,0,0,536,537,5,227,
        0,0,537,538,3,170,85,0,538,540,7,6,0,0,539,541,5,43,0,0,540,539,
        1,0,0,0,540,541,1,0,0,0,541,542,1,0,0,0,542,544,3,170,85,0,543,545,
        3,266,133,0,544,543,1,0,0,0,544,545,1,0,0,0,545,1007,1,0,0,0,546,
        547,5,15,0,0,547,548,5,227,0,0,548,550,3,170,85,0,549,551,3,36,18,
        0,550,549,1,0,0,0,550,551,1,0,0,0,551,552,1,0,0,0,552,554,5,35,0,
        0,553,555,5,43,0,0,554,553,1,0,0,0,554,555,1,0,0,0,555,556,1,0,0,
        0,556,557,3,170,85,0,557,559,3,230,115,0,558,560,3,220,110,0,559,
        558,1,0,0,0,559,560,1,0,0,0,560,1007,1,0,0,0,561,562,5,15,0,0,562,
        563,5,227,0,0,563,565,3,170,85,0,564,566,3,36,18,0,565,564,1,0,0,
        0,565,566,1,0,0,0,566,567,1,0,0,0,567,568,5,192,0,0,568,569,5,44,
        0,0,569,570,5,2,0,0,570,571,3,224,112,0,571,572,5,3,0,0,572,1007,
        1,0,0,0,573,574,5,15,0,0,574,575,5,227,0,0,575,577,3,170,85,0,576,
        578,3,36,18,0,577,576,1,0,0,0,577,578,1,0,0,0,578,579,1,0,0,0,579,
        580,5,212,0,0,580,581,5,209,0,0,581,585,5,283,0,0,582,583,5,262,
        0,0,583,584,5,210,0,0,584,586,3,54,27,0,585,582,1,0,0,0,585,586,
        1,0,0,0,586,1007,1,0,0,0,587,588,5,15,0,0,588,589,5,227,0,0,589,
        591,3,170,85,0,590,592,3,36,18,0,591,590,1,0,0,0,591,592,1,0,0,0,
        592,593,1,0,0,0,593,594,5,212,0,0,594,595,5,210,0,0,595,596,3,54,
        27,0,596,1007,1,0,0,0,597,598,5,15,0,0,598,599,7,5,0,0,599,600,3,
        170,85,0,600,604,5,12,0,0,601,602,5,110,0,0,602,603,5,153,0,0,603,
        605,5,83,0,0,604,601,1,0,0,0,604,605,1,0,0,0,605,607,1,0,0,0,606,
        608,3,34,17,0,607,606,1,0,0,0,608,609,1,0,0,0,609,607,1,0,0,0,609,
        610,1,0,0,0,610,1007,1,0,0,0,611,612,5,15,0,0,612,613,5,227,0,0,
        613,614,3,170,85,0,614,615,3,36,18,0,615,616,5,190,0,0,616,617,5,
        234,0,0,617,618,3,36,18,0,618,1007,1,0,0,0,619,620,5,15,0,0,620,
        621,7,5,0,0,621,622,3,170,85,0,622,625,5,76,0,0,623,624,5,110,0,
        0,624,626,5,83,0,0,625,623,1,0,0,0,625,626,1,0,0,0,626,627,1,0,0,
        0,627,632,3,36,18,0,628,629,5,4,0,0,629,631,3,36,18,0,630,628,1,
        0,0,0,631,634,1,0,0,0,632,630,1,0,0,0,632,633,1,0,0,0,633,636,1,
        0,0,0,634,632,1,0,0,0,635,637,5,181,0,0,636,635,1,0,0,0,636,637,
        1,0,0,0,637,1007,1,0,0,0,638,639,5,15,0,0,639,640,5,227,0,0,640,
        642,3,170,85,0,641,643,3,36,18,0,642,641,1,0,0,0,642,643,1,0,0,0,
        643,644,1,0,0,0,644,645,5,212,0,0,645,646,3,26,13,0,646,1007,1,0,
        0,0,647,648,5,15,0,0,648,649,5,227,0,0,649,650,3,170,85,0,650,651,
        5,186,0,0,651,652,5,172,0,0,652,1007,1,0,0,0,653,654,5,76,0,0,654,
        657,5,227,0,0,655,656,5,110,0,0,656,658,5,83,0,0,657,655,1,0,0,0,
        657,658,1,0,0,0,658,659,1,0,0,0,659,661,3,170,85,0,660,662,5,181,
        0,0,661,660,1,0,0,0,661,662,1,0,0,0,662,1007,1,0,0,0,663,664,5,76,
        0,0,664,667,5,257,0,0,665,666,5,110,0,0,666,668,5,83,0,0,667,665,
        1,0,0,0,667,668,1,0,0,0,668,669,1,0,0,0,669,1007,3,170,85,0,670,
        673,5,53,0,0,671,672,5,161,0,0,672,674,5,192,0,0,673,671,1,0,0,0,
        673,674,1,0,0,0,674,679,1,0,0,0,675,677,5,104,0,0,676,675,1,0,0,
        0,676,677,1,0,0,0,677,678,1,0,0,0,678,680,5,231,0,0,679,676,1,0,
        0,0,679,680,1,0,0,0,680,681,1,0,0,0,681,685,5,257,0,0,682,683,5,
        110,0,0,683,684,5,153,0,0,684,686,5,83,0,0,685,682,1,0,0,0,685,686,
        1,0,0,0,686,687,1,0,0,0,687,689,3,170,85,0,688,690,3,154,77,0,689,
        688,1,0,0,0,689,690,1,0,0,0,690,699,1,0,0,0,691,698,3,28,14,0,692,
        693,5,171,0,0,693,694,5,157,0,0,694,698,3,146,73,0,695,696,5,230,
        0,0,696,698,3,54,27,0,697,691,1,0,0,0,697,692,1,0,0,0,697,695,1,
        0,0,0,698,701,1,0,0,0,699,697,1,0,0,0,699,700,1,0,0,0,700,702,1,
        0,0,0,701,699,1,0,0,0,702,703,5,22,0,0,703,704,3,30,15,0,704,1007,
        1,0,0,0,705,708,5,53,0,0,706,707,5,161,0,0,707,709,5,192,0,0,708,
        706,1,0,0,0,708,709,1,0,0,0,709,711,1,0,0,0,710,712,5,104,0,0,711,
        710,1,0,0,0,711,712,1,0,0,0,712,713,1,0,0,0,713,714,5,231,0,0,714,
        715,5,257,0,0,715,720,3,172,86,0,716,717,5,2,0,0,717,718,3,228,114,
        0,718,719,5,3,0,0,719,721,1,0,0,0,720,716,1,0,0,0,720,721,1,0,0,
        0,721,722,1,0,0,0,722,725,3,50,25,0,723,724,5,160,0,0,724,726,3,
        54,27,0,725,723,1,0,0,0,725,726,1,0,0,0,726,1007,1,0,0,0,727,728,
        5,15,0,0,728,729,5,257,0,0,729,731,3,170,85,0,730,732,5,22,0,0,731,
        730,1,0,0,0,731,732,1,0,0,0,732,733,1,0,0,0,733,734,3,30,15,0,734,
        1007,1,0,0,0,735,738,5,53,0,0,736,737,5,161,0,0,737,739,5,192,0,
        0,738,736,1,0,0,0,738,739,1,0,0,0,739,741,1,0,0,0,740,742,5,231,
        0,0,741,740,1,0,0,0,741,742,1,0,0,0,742,743,1,0,0,0,743,747,5,102,
        0,0,744,745,5,110,0,0,745,746,5,153,0,0,746,748,5,83,0,0,747,744,
        1,0,0,0,747,748,1,0,0,0,748,749,1,0,0,0,749,750,3,170,85,0,750,751,
        5,22,0,0,751,761,5,283,0,0,752,753,5,255,0,0,753,758,3,72,36,0,754,
        755,5,4,0,0,755,757,3,72,36,0,756,754,1,0,0,0,757,760,1,0,0,0,758,
        756,1,0,0,0,758,759,1,0,0,0,759,762,1,0,0,0,760,758,1,0,0,0,761,
        752,1,0,0,0,761,762,1,0,0,0,762,1007,1,0,0,0,763,765,5,76,0,0,764,
        766,5,231,0,0,765,764,1,0,0,0,765,766,1,0,0,0,766,767,1,0,0,0,767,
        770,5,102,0,0,768,769,5,110,0,0,769,771,5,83,0,0,770,768,1,0,0,0,
        770,771,1,0,0,0,771,772,1,0,0,0,772,1007,3,170,85,0,773,775,5,84,
        0,0,774,776,7,7,0,0,775,774,1,0,0,0,775,776,1,0,0,0,776,777,1,0,
        0,0,777,1007,3,14,7,0,778,779,5,215,0,0,779,782,5,228,0,0,780,781,
        7,3,0,0,781,783,3,170,85,0,782,780,1,0,0,0,782,783,1,0,0,0,783,788,
        1,0,0,0,784,786,5,132,0,0,785,784,1,0,0,0,785,786,1,0,0,0,786,787,
        1,0,0,0,787,789,5,283,0,0,788,785,1,0,0,0,788,789,1,0,0,0,789,1007,
        1,0,0,0,790,791,5,215,0,0,791,792,5,227,0,0,792,795,5,86,0,0,793,
        794,7,3,0,0,794,796,3,170,85,0,795,793,1,0,0,0,795,796,1,0,0,0,796,
        797,1,0,0,0,797,798,5,132,0,0,798,800,5,283,0,0,799,801,3,36,18,
        0,800,799,1,0,0,0,800,801,1,0,0,0,801,1007,1,0,0,0,802,803,5,215,
        0,0,803,804,5,230,0,0,804,809,3,170,85,0,805,806,5,2,0,0,806,807,
        3,58,29,0,807,808,5,3,0,0,808,810,1,0,0,0,809,805,1,0,0,0,809,810,
        1,0,0,0,810,1007,1,0,0,0,811,812,5,215,0,0,812,813,5,44,0,0,813,
        814,7,3,0,0,814,817,3,170,85,0,815,816,7,3,0,0,816,818,3,170,85,
        0,817,815,1,0,0,0,817,818,1,0,0,0,818,1007,1,0,0,0,819,820,5,215,
        0,0,820,823,5,258,0,0,821,822,7,3,0,0,822,824,3,170,85,0,823,821,
        1,0,0,0,823,824,1,0,0,0,824,829,1,0,0,0,825,827,5,132,0,0,826,825,
        1,0,0,0,826,827,1,0,0,0,827,828,1,0,0,0,828,830,5,283,0,0,829,826,
        1,0,0,0,829,830,1,0,0,0,830,1007,1,0,0,0,831,832,5,215,0,0,832,833,
        5,172,0,0,833,835,3,170,85,0,834,836,3,36,18,0,835,834,1,0,0,0,835,
        836,1,0,0,0,836,1007,1,0,0,0,837,839,5,215,0,0,838,840,3,258,129,
        0,839,838,1,0,0,0,839,840,1,0,0,0,840,841,1,0,0,0,841,849,5,103,
        0,0,842,844,5,132,0,0,843,842,1,0,0,0,843,844,1,0,0,0,844,847,1,
        0,0,0,845,848,3,170,85,0,846,848,5,283,0,0,847,845,1,0,0,0,847,846,
        1,0,0,0,848,850,1,0,0,0,849,843,1,0,0,0,849,850,1,0,0,0,850,1007,
        1,0,0,0,851,852,5,215,0,0,852,853,5,53,0,0,853,854,5,227,0,0,854,
        857,3,170,85,0,855,856,5,22,0,0,856,858,5,209,0,0,857,855,1,0,0,
        0,857,858,1,0,0,0,858,1007,1,0,0,0,859,860,5,215,0,0,860,861,5,56,
        0,0,861,1007,5,149,0,0,862,863,7,8,0,0,863,865,5,102,0,0,864,866,
        5,86,0,0,865,864,1,0,0,0,865,866,1,0,0,0,866,867,1,0,0,0,867,1007,
        3,42,21,0,868,869,7,8,0,0,869,871,3,40,20,0,870,872,5,86,0,0,871,
        870,1,0,0,0,871,872,1,0,0,0,872,873,1,0,0,0,873,874,3,170,85,0,874,
        1007,1,0,0,0,875,877,7,8,0,0,876,878,5,227,0,0,877,876,1,0,0,0,877,
        878,1,0,0,0,878,880,1,0,0,0,879,881,7,9,0,0,880,879,1,0,0,0,880,
        881,1,0,0,0,881,882,1,0,0,0,882,884,3,170,85,0,883,885,3,36,18,0,
        884,883,1,0,0,0,884,885,1,0,0,0,885,887,1,0,0,0,886,888,3,44,22,
        0,887,886,1,0,0,0,887,888,1,0,0,0,888,1007,1,0,0,0,889,891,7,8,0,
        0,890,892,5,182,0,0,891,890,1,0,0,0,891,892,1,0,0,0,892,893,1,0,
        0,0,893,1007,3,30,15,0,894,895,5,45,0,0,895,896,5,157,0,0,896,897,
        3,40,20,0,897,898,3,170,85,0,898,899,5,123,0,0,899,900,7,10,0,0,
        900,1007,1,0,0,0,901,902,5,45,0,0,902,903,5,157,0,0,903,904,5,227,
        0,0,904,905,3,170,85,0,905,906,5,123,0,0,906,907,7,10,0,0,907,1007,
        1,0,0,0,908,909,5,189,0,0,909,910,5,227,0,0,910,1007,3,170,85,0,
        911,919,5,189,0,0,912,920,5,283,0,0,913,915,9,0,0,0,914,913,1,0,
        0,0,915,918,1,0,0,0,916,917,1,0,0,0,916,914,1,0,0,0,917,920,1,0,
        0,0,918,916,1,0,0,0,919,912,1,0,0,0,919,916,1,0,0,0,920,1007,1,0,
        0,0,921,923,5,31,0,0,922,924,5,129,0,0,923,922,1,0,0,0,923,924,1,
        0,0,0,924,925,1,0,0,0,925,926,5,227,0,0,926,929,3,170,85,0,927,928,
        5,160,0,0,928,930,3,54,27,0,929,927,1,0,0,0,929,930,1,0,0,0,930,
        935,1,0,0,0,931,933,5,22,0,0,932,931,1,0,0,0,932,933,1,0,0,0,933,
        934,1,0,0,0,934,936,3,30,15,0,935,932,1,0,0,0,935,936,1,0,0,0,936,
        1007,1,0,0,0,937,938,5,246,0,0,938,941,5,227,0,0,939,940,5,110,0,
        0,940,942,5,83,0,0,941,939,1,0,0,0,941,942,1,0,0,0,942,943,1,0,0,
        0,943,1007,3,170,85,0,944,945,5,37,0,0,945,1007,5,31,0,0,946,947,
        5,136,0,0,947,949,5,61,0,0,948,950,5,137,0,0,949,948,1,0,0,0,949,
        950,1,0,0,0,950,951,1,0,0,0,951,952,5,117,0,0,952,954,5,283,0,0,
        953,955,5,169,0,0,954,953,1,0,0,0,954,955,1,0,0,0,955,956,1,0,0,
        0,956,957,5,122,0,0,957,958,5,227,0,0,958,960,3,170,85,0,959,961,
        3,36,18,0,960,959,1,0,0,0,960,961,1,0,0,0,961,1007,1,0,0,0,962,963,
        5,242,0,0,963,964,5,227,0,0,964,966,3,170,85,0,965,967,3,36,18,0,
        966,965,1,0,0,0,966,967,1,0,0,0,967,1007,1,0,0,0,968,969,5,148,0,
        0,969,970,5,191,0,0,970,971,5,227,0,0,971,1007,3,170,85,0,972,973,
        7,11,0,0,973,981,3,258,129,0,974,982,5,283,0,0,975,977,9,0,0,0,976,
        975,1,0,0,0,977,980,1,0,0,0,978,979,1,0,0,0,978,976,1,0,0,0,979,
        982,1,0,0,0,980,978,1,0,0,0,981,974,1,0,0,0,981,978,1,0,0,0,982,
        1007,1,0,0,0,983,984,5,212,0,0,984,988,5,198,0,0,985,987,9,0,0,0,
        986,985,1,0,0,0,987,990,1,0,0,0,988,989,1,0,0,0,988,986,1,0,0,0,
        989,1007,1,0,0,0,990,988,1,0,0,0,991,995,5,212,0,0,992,994,9,0,0,
        0,993,992,1,0,0,0,994,997,1,0,0,0,995,996,1,0,0,0,995,993,1,0,0,
        0,996,1007,1,0,0,0,997,995,1,0,0,0,998,1007,5,193,0,0,999,1003,3,
        16,8,0,1000,1002,9,0,0,0,1001,1000,1,0,0,0,1002,1005,1,0,0,0,1003,
        1004,1,0,0,0,1003,1001,1,0,0,0,1004,1007,1,0,0,0,1005,1003,1,0,0,
        0,1006,301,1,0,0,0,1006,303,1,0,0,0,1006,306,1,0,0,0,1006,311,1,
        0,0,0,1006,329,1,0,0,0,1006,336,1,0,0,0,1006,342,1,0,0,0,1006,352,
        1,0,0,0,1006,364,1,0,0,0,1006,379,1,0,0,0,1006,416,1,0,0,0,1006,
        437,1,0,0,0,1006,452,1,0,0,0,1006,469,1,0,0,0,1006,476,1,0,0,0,1006,
        485,1,0,0,0,1006,494,1,0,0,0,1006,503,1,0,0,0,1006,510,1,0,0,0,1006,
        517,1,0,0,0,1006,524,1,0,0,0,1006,535,1,0,0,0,1006,546,1,0,0,0,1006,
        561,1,0,0,0,1006,573,1,0,0,0,1006,587,1,0,0,0,1006,597,1,0,0,0,1006,
        611,1,0,0,0,1006,619,1,0,0,0,1006,638,1,0,0,0,1006,647,1,0,0,0,1006,
        653,1,0,0,0,1006,663,1,0,0,0,1006,670,1,0,0,0,1006,705,1,0,0,0,1006,
        727,1,0,0,0,1006,735,1,0,0,0,1006,763,1,0,0,0,1006,773,1,0,0,0,1006,
        778,1,0,0,0,1006,790,1,0,0,0,1006,802,1,0,0,0,1006,811,1,0,0,0,1006,
        819,1,0,0,0,1006,831,1,0,0,0,1006,837,1,0,0,0,1006,851,1,0,0,0,1006,
        859,1,0,0,0,1006,862,1,0,0,0,1006,868,1,0,0,0,1006,875,1,0,0,0,1006,
        889,1,0,0,0,1006,894,1,0,0,0,1006,901,1,0,0,0,1006,908,1,0,0,0,1006,
        911,1,0,0,0,1006,921,1,0,0,0,1006,937,1,0,0,0,1006,944,1,0,0,0,1006,
        946,1,0,0,0,1006,962,1,0,0,0,1006,968,1,0,0,0,1006,972,1,0,0,0,1006,
        983,1,0,0,0,1006,991,1,0,0,0,1006,998,1,0,0,0,1006,999,1,0,0,0,1007,
        15,1,0,0,0,1008,1009,5,53,0,0,1009,1177,5,198,0,0,1010,1011,5,76,
        0,0,1011,1177,5,198,0,0,1012,1014,5,105,0,0,1013,1015,5,198,0,0,
        1014,1013,1,0,0,0,1014,1015,1,0,0,0,1015,1177,1,0,0,0,1016,1018,
        5,195,0,0,1017,1019,5,198,0,0,1018,1017,1,0,0,0,1018,1019,1,0,0,
        0,1019,1177,1,0,0,0,1020,1021,5,215,0,0,1021,1177,5,105,0,0,1022,
        1023,5,215,0,0,1023,1025,5,198,0,0,1024,1026,5,105,0,0,1025,1024,
        1,0,0,0,1025,1026,1,0,0,0,1026,1177,1,0,0,0,1027,1028,5,215,0,0,
        1028,1177,5,179,0,0,1029,1030,5,215,0,0,1030,1177,5,199,0,0,1031,
        1032,5,215,0,0,1032,1033,5,56,0,0,1033,1177,5,199,0,0,1034,1035,
        5,85,0,0,1035,1177,5,227,0,0,1036,1037,5,112,0,0,1037,1177,5,227,
        0,0,1038,1039,5,215,0,0,1039,1177,5,48,0,0,1040,1041,5,215,0,0,1041,
        1042,5,53,0,0,1042,1177,5,227,0,0,1043,1044,5,215,0,0,1044,1177,
        5,238,0,0,1045,1046,5,215,0,0,1046,1177,5,115,0,0,1047,1048,5,215,
        0,0,1048,1177,5,140,0,0,1049,1050,5,53,0,0,1050,1177,5,114,0,0,1051,
        1052,5,76,0,0,1052,1177,5,114,0,0,1053,1054,5,15,0,0,1054,1177,5,
        114,0,0,1055,1056,5,139,0,0,1056,1177,5,227,0,0,1057,1058,5,139,
        0,0,1058,1177,5,62,0,0,1059,1060,5,250,0,0,1060,1177,5,227,0,0,1061,
        1062,5,250,0,0,1062,1177,5,62,0,0,1063,1064,5,53,0,0,1064,1065,5,
        231,0,0,1065,1177,5,142,0,0,1066,1067,5,76,0,0,1067,1068,5,231,0,
        0,1068,1177,5,142,0,0,1069,1070,5,15,0,0,1070,1071,5,227,0,0,1071,
        1072,3,172,86,0,1072,1073,5,153,0,0,1073,1074,5,39,0,0,1074,1177,
        1,0,0,0,1075,1076,5,15,0,0,1076,1077,5,227,0,0,1077,1078,3,172,86,
        0,1078,1079,5,39,0,0,1079,1080,5,30,0,0,1080,1177,1,0,0,0,1081,1082,
        5,15,0,0,1082,1083,5,227,0,0,1083,1084,3,172,86,0,1084,1085,5,153,
        0,0,1085,1086,5,219,0,0,1086,1177,1,0,0,0,1087,1088,5,15,0,0,1088,
        1089,5,227,0,0,1089,1090,3,172,86,0,1090,1091,5,216,0,0,1091,1092,
        5,30,0,0,1092,1177,1,0,0,0,1093,1094,5,15,0,0,1094,1095,5,227,0,
        0,1095,1096,3,172,86,0,1096,1097,5,153,0,0,1097,1098,5,216,0,0,1098,
        1177,1,0,0,0,1099,1100,5,15,0,0,1100,1101,5,227,0,0,1101,1102,3,
        172,86,0,1102,1103,5,153,0,0,1103,1104,5,222,0,0,1104,1105,5,22,
        0,0,1105,1106,5,72,0,0,1106,1177,1,0,0,0,1107,1108,5,15,0,0,1108,
        1109,5,227,0,0,1109,1110,3,172,86,0,1110,1111,5,212,0,0,1111,1112,
        5,216,0,0,1112,1113,5,138,0,0,1113,1177,1,0,0,0,1114,1115,5,15,0,
        0,1115,1116,5,227,0,0,1116,1117,3,172,86,0,1117,1118,5,82,0,0,1118,
        1119,5,170,0,0,1119,1177,1,0,0,0,1120,1121,5,15,0,0,1121,1122,5,
        227,0,0,1122,1123,3,172,86,0,1123,1124,5,20,0,0,1124,1125,5,170,
        0,0,1125,1177,1,0,0,0,1126,1127,5,15,0,0,1127,1128,5,227,0,0,1128,
        1129,3,172,86,0,1129,1130,5,244,0,0,1130,1131,5,170,0,0,1131,1177,
        1,0,0,0,1132,1133,5,15,0,0,1133,1134,5,227,0,0,1134,1135,3,172,86,
        0,1135,1136,5,235,0,0,1136,1177,1,0,0,0,1137,1138,5,15,0,0,1138,
        1139,5,227,0,0,1139,1141,3,172,86,0,1140,1142,3,36,18,0,1141,1140,
        1,0,0,0,1141,1142,1,0,0,0,1142,1143,1,0,0,0,1143,1144,5,47,0,0,1144,
        1177,1,0,0,0,1145,1146,5,15,0,0,1146,1147,5,227,0,0,1147,1149,3,
        172,86,0,1148,1150,3,36,18,0,1149,1148,1,0,0,0,1149,1150,1,0,0,0,
        1150,1151,1,0,0,0,1151,1152,5,50,0,0,1152,1177,1,0,0,0,1153,1154,
        5,15,0,0,1154,1155,5,227,0,0,1155,1157,3,172,86,0,1156,1158,3,36,
        18,0,1157,1156,1,0,0,0,1157,1158,1,0,0,0,1158,1159,1,0,0,0,1159,
        1160,5,212,0,0,1160,1161,5,93,0,0,1161,1177,1,0,0,0,1162,1163,5,
        15,0,0,1163,1164,5,227,0,0,1164,1166,3,172,86,0,1165,1167,3,36,18,
        0,1166,1165,1,0,0,0,1166,1167,1,0,0,0,1167,1168,1,0,0,0,1168,1169,
        5,192,0,0,1169,1170,5,44,0,0,1170,1177,1,0,0,0,1171,1172,5,220,0,
        0,1172,1177,5,237,0,0,1173,1177,5,46,0,0,1174,1177,5,200,0,0,1175,
        1177,5,71,0,0,1176,1008,1,0,0,0,1176,1010,1,0,0,0,1176,1012,1,0,
        0,0,1176,1016,1,0,0,0,1176,1020,1,0,0,0,1176,1022,1,0,0,0,1176,1027,
        1,0,0,0,1176,1029,1,0,0,0,1176,1031,1,0,0,0,1176,1034,1,0,0,0,1176,
        1036,1,0,0,0,1176,1038,1,0,0,0,1176,1040,1,0,0,0,1176,1043,1,0,0,
        0,1176,1045,1,0,0,0,1176,1047,1,0,0,0,1176,1049,1,0,0,0,1176,1051,
        1,0,0,0,1176,1053,1,0,0,0,1176,1055,1,0,0,0,1176,1057,1,0,0,0,1176,
        1059,1,0,0,0,1176,1061,1,0,0,0,1176,1063,1,0,0,0,1176,1066,1,0,0,
        0,1176,1069,1,0,0,0,1176,1075,1,0,0,0,1176,1081,1,0,0,0,1176,1087,
        1,0,0,0,1176,1093,1,0,0,0,1176,1099,1,0,0,0,1176,1107,1,0,0,0,1176,
        1114,1,0,0,0,1176,1120,1,0,0,0,1176,1126,1,0,0,0,1176,1132,1,0,0,
        0,1176,1137,1,0,0,0,1176,1145,1,0,0,0,1176,1153,1,0,0,0,1176,1162,
        1,0,0,0,1176,1171,1,0,0,0,1176,1173,1,0,0,0,1176,1174,1,0,0,0,1176,
        1175,1,0,0,0,1177,17,1,0,0,0,1178,1180,5,53,0,0,1179,1181,5,231,
        0,0,1180,1179,1,0,0,0,1180,1181,1,0,0,0,1181,1183,1,0,0,0,1182,1184,
        5,87,0,0,1183,1182,1,0,0,0,1183,1184,1,0,0,0,1184,1185,1,0,0,0,1185,
        1189,5,227,0,0,1186,1187,5,110,0,0,1187,1188,5,153,0,0,1188,1190,
        5,83,0,0,1189,1186,1,0,0,0,1189,1190,1,0,0,0,1190,1191,1,0,0,0,1191,
        1192,3,170,85,0,1192,19,1,0,0,0,1193,1194,5,53,0,0,1194,1196,5,161,
        0,0,1195,1193,1,0,0,0,1195,1196,1,0,0,0,1196,1197,1,0,0,0,1197,1198,
        5,192,0,0,1198,1199,5,227,0,0,1199,1200,3,170,85,0,1200,21,1,0,0,
        0,1201,1202,5,39,0,0,1202,1203,5,30,0,0,1203,1207,3,146,73,0,1204,
        1205,5,219,0,0,1205,1206,5,30,0,0,1206,1208,3,150,75,0,1207,1204,
        1,0,0,0,1207,1208,1,0,0,0,1208,1209,1,0,0,0,1209,1210,5,122,0,0,
        1210,1211,5,287,0,0,1211,1212,5,29,0,0,1212,23,1,0,0,0,1213,1214,
        5,216,0,0,1214,1215,5,30,0,0,1215,1216,3,146,73,0,1216,1219,5,157,
        0,0,1217,1220,3,62,31,0,1218,1220,3,64,32,0,1219,1217,1,0,0,0,1219,
        1218,1,0,0,0,1220,1224,1,0,0,0,1221,1222,5,222,0,0,1222,1223,5,22,
        0,0,1223,1225,5,72,0,0,1224,1221,1,0,0,0,1224,1225,1,0,0,0,1225,
        25,1,0,0,0,1226,1227,5,138,0,0,1227,1228,5,283,0,0,1228,27,1,0,0,
        0,1229,1230,5,45,0,0,1230,1231,5,283,0,0,1231,29,1,0,0,0,1232,1234,
        3,46,23,0,1233,1232,1,0,0,0,1233,1234,1,0,0,0,1234,1235,1,0,0,0,
        1235,1236,3,80,40,0,1236,1237,3,76,38,0,1237,31,1,0,0,0,1238,1239,
        5,119,0,0,1239,1241,5,169,0,0,1240,1242,5,227,0,0,1241,1240,1,0,
        0,0,1241,1242,1,0,0,0,1242,1243,1,0,0,0,1243,1250,3,170,85,0,1244,
        1248,3,36,18,0,1245,1246,5,110,0,0,1246,1247,5,153,0,0,1247,1249,
        5,83,0,0,1248,1245,1,0,0,0,1248,1249,1,0,0,0,1249,1251,1,0,0,0,1250,
        1244,1,0,0,0,1250,1251,1,0,0,0,1251,1294,1,0,0,0,1252,1253,5,119,
        0,0,1253,1255,5,122,0,0,1254,1256,5,227,0,0,1255,1254,1,0,0,0,1255,
        1256,1,0,0,0,1256,1257,1,0,0,0,1257,1259,3,170,85,0,1258,1260,3,
        36,18,0,1259,1258,1,0,0,0,1259,1260,1,0,0,0,1260,1264,1,0,0,0,1261,
        1262,5,110,0,0,1262,1263,5,153,0,0,1263,1265,5,83,0,0,1264,1261,
        1,0,0,0,1264,1265,1,0,0,0,1265,1294,1,0,0,0,1266,1267,5,119,0,0,
        1267,1269,5,169,0,0,1268,1270,5,137,0,0,1269,1268,1,0,0,0,1269,1270,
        1,0,0,0,1270,1271,1,0,0,0,1271,1272,5,73,0,0,1272,1274,5,283,0,0,
        1273,1275,3,166,83,0,1274,1273,1,0,0,0,1274,1275,1,0,0,0,1275,1277,
        1,0,0,0,1276,1278,3,66,33,0,1277,1276,1,0,0,0,1277,1278,1,0,0,0,
        1278,1294,1,0,0,0,1279,1280,5,119,0,0,1280,1282,5,169,0,0,1281,1283,
        5,137,0,0,1282,1281,1,0,0,0,1282,1283,1,0,0,0,1283,1284,1,0,0,0,
        1284,1286,5,73,0,0,1285,1287,5,283,0,0,1286,1285,1,0,0,0,1286,1287,
        1,0,0,0,1287,1288,1,0,0,0,1288,1291,3,50,25,0,1289,1290,5,160,0,
        0,1290,1292,3,54,27,0,1291,1289,1,0,0,0,1291,1292,1,0,0,0,1292,1294,
        1,0,0,0,1293,1238,1,0,0,0,1293,1252,1,0,0,0,1293,1266,1,0,0,0,1293,
        1279,1,0,0,0,1294,33,1,0,0,0,1295,1297,3,36,18,0,1296,1298,3,26,
        13,0,1297,1296,1,0,0,0,1297,1298,1,0,0,0,1298,35,1,0,0,0,1299,1300,
        5,170,0,0,1300,1301,5,2,0,0,1301,1306,3,38,19,0,1302,1303,5,4,0,
        0,1303,1305,3,38,19,0,1304,1302,1,0,0,0,1305,1308,1,0,0,0,1306,1304,
        1,0,0,0,1306,1307,1,0,0,0,1307,1309,1,0,0,0,1308,1306,1,0,0,0,1309,
        1310,5,3,0,0,1310,37,1,0,0,0,1311,1314,3,258,129,0,1312,1313,5,264,
        0,0,1313,1315,3,196,98,0,1314,1312,1,0,0,0,1314,1315,1,0,0,0,1315,
        39,1,0,0,0,1316,1317,7,12,0,0,1317,41,1,0,0,0,1318,1324,3,252,126,
        0,1319,1324,5,283,0,0,1320,1324,3,198,99,0,1321,1324,3,200,100,0,
        1322,1324,3,202,101,0,1323,1318,1,0,0,0,1323,1319,1,0,0,0,1323,1320,
        1,0,0,0,1323,1321,1,0,0,0,1323,1322,1,0,0,0,1324,43,1,0,0,0,1325,
        1330,3,258,129,0,1326,1327,5,5,0,0,1327,1329,3,258,129,0,1328,1326,
        1,0,0,0,1329,1332,1,0,0,0,1330,1328,1,0,0,0,1330,1331,1,0,0,0,1331,
        45,1,0,0,0,1332,1330,1,0,0,0,1333,1334,5,262,0,0,1334,1339,3,48,
        24,0,1335,1336,5,4,0,0,1336,1338,3,48,24,0,1337,1335,1,0,0,0,1338,
        1341,1,0,0,0,1339,1337,1,0,0,0,1339,1340,1,0,0,0,1340,47,1,0,0,0,
        1341,1339,1,0,0,0,1342,1344,3,254,127,0,1343,1345,3,146,73,0,1344,
        1343,1,0,0,0,1344,1345,1,0,0,0,1345,1347,1,0,0,0,1346,1348,5,22,
        0,0,1347,1346,1,0,0,0,1347,1348,1,0,0,0,1348,1349,1,0,0,0,1349,1350,
        5,2,0,0,1350,1351,3,30,15,0,1351,1352,5,3,0,0,1352,49,1,0,0,0,1353,
        1354,5,255,0,0,1354,1355,3,170,85,0,1355,51,1,0,0,0,1356,1357,5,
        160,0,0,1357,1367,3,54,27,0,1358,1359,5,171,0,0,1359,1360,5,30,0,
        0,1360,1367,3,180,90,0,1361,1367,3,22,11,0,1362,1367,3,26,13,0,1363,
        1367,3,28,14,0,1364,1365,5,230,0,0,1365,1367,3,54,27,0,1366,1356,
        1,0,0,0,1366,1358,1,0,0,0,1366,1361,1,0,0,0,1366,1362,1,0,0,0,1366,
        1363,1,0,0,0,1366,1364,1,0,0,0,1367,1370,1,0,0,0,1368,1366,1,0,0,
        0,1368,1369,1,0,0,0,1369,53,1,0,0,0,1370,1368,1,0,0,0,1371,1372,
        5,2,0,0,1372,1377,3,56,28,0,1373,1374,5,4,0,0,1374,1376,3,56,28,
        0,1375,1373,1,0,0,0,1376,1379,1,0,0,0,1377,1375,1,0,0,0,1377,1378,
        1,0,0,0,1378,1380,1,0,0,0,1379,1377,1,0,0,0,1380,1381,5,3,0,0,1381,
        55,1,0,0,0,1382,1387,3,58,29,0,1383,1385,5,264,0,0,1384,1383,1,0,
        0,0,1384,1385,1,0,0,0,1385,1386,1,0,0,0,1386,1388,3,60,30,0,1387,
        1384,1,0,0,0,1387,1388,1,0,0,0,1388,57,1,0,0,0,1389,1394,3,258,129,
        0,1390,1391,5,5,0,0,1391,1393,3,258,129,0,1392,1390,1,0,0,0,1393,
        1396,1,0,0,0,1394,1392,1,0,0,0,1394,1395,1,0,0,0,1395,1399,1,0,0,
        0,1396,1394,1,0,0,0,1397,1399,5,283,0,0,1398,1389,1,0,0,0,1398,1397,
        1,0,0,0,1399,59,1,0,0,0,1400,1405,5,287,0,0,1401,1405,5,289,0,0,
        1402,1405,3,204,102,0,1403,1405,5,283,0,0,1404,1400,1,0,0,0,1404,
        1401,1,0,0,0,1404,1402,1,0,0,0,1404,1403,1,0,0,0,1405,61,1,0,0,0,
        1406,1407,5,2,0,0,1407,1412,3,196,98,0,1408,1409,5,4,0,0,1409,1411,
        3,196,98,0,1410,1408,1,0,0,0,1411,1414,1,0,0,0,1412,1410,1,0,0,0,
        1412,1413,1,0,0,0,1413,1415,1,0,0,0,1414,1412,1,0,0,0,1415,1416,
        5,3,0,0,1416,63,1,0,0,0,1417,1418,5,2,0,0,1418,1423,3,62,31,0,1419,
        1420,5,4,0,0,1420,1422,3,62,31,0,1421,1419,1,0,0,0,1422,1425,1,0,
        0,0,1423,1421,1,0,0,0,1423,1424,1,0,0,0,1424,1426,1,0,0,0,1425,1423,
        1,0,0,0,1426,1427,5,3,0,0,1427,65,1,0,0,0,1428,1429,5,222,0,0,1429,
        1430,5,22,0,0,1430,1435,3,68,34,0,1431,1432,5,222,0,0,1432,1433,
        5,30,0,0,1433,1435,3,70,35,0,1434,1428,1,0,0,0,1434,1431,1,0,0,0,
        1435,67,1,0,0,0,1436,1437,5,118,0,0,1437,1438,5,283,0,0,1438,1439,
        5,165,0,0,1439,1442,5,283,0,0,1440,1442,3,258,129,0,1441,1436,1,
        0,0,0,1441,1440,1,0,0,0,1442,69,1,0,0,0,1443,1447,5,283,0,0,1444,
        1445,5,262,0,0,1445,1446,5,210,0,0,1446,1448,3,54,27,0,1447,1444,
        1,0,0,0,1447,1448,1,0,0,0,1448,71,1,0,0,0,1449,1450,3,258,129,0,
        1450,1451,5,283,0,0,1451,73,1,0,0,0,1452,1453,3,32,16,0,1453,1454,
        3,80,40,0,1454,1455,3,76,38,0,1455,1504,1,0,0,0,1456,1458,3,118,
        59,0,1457,1459,3,78,39,0,1458,1457,1,0,0,0,1459,1460,1,0,0,0,1460,
        1458,1,0,0,0,1460,1461,1,0,0,0,1461,1504,1,0,0,0,1462,1463,5,67,
        0,0,1463,1464,5,100,0,0,1464,1465,3,170,85,0,1465,1467,3,164,82,
        0,1466,1468,3,110,55,0,1467,1466,1,0,0,0,1467,1468,1,0,0,0,1468,
        1504,1,0,0,0,1469,1470,5,252,0,0,1470,1471,3,170,85,0,1471,1472,
        3,164,82,0,1472,1474,3,96,48,0,1473,1475,3,110,55,0,1474,1473,1,
        0,0,0,1474,1475,1,0,0,0,1475,1504,1,0,0,0,1476,1477,5,145,0,0,1477,
        1478,5,122,0,0,1478,1479,3,170,85,0,1479,1480,3,164,82,0,1480,1486,
        5,255,0,0,1481,1487,3,170,85,0,1482,1483,5,2,0,0,1483,1484,3,30,
        15,0,1484,1485,5,3,0,0,1485,1487,1,0,0,0,1486,1481,1,0,0,0,1486,
        1482,1,0,0,0,1487,1488,1,0,0,0,1488,1489,3,164,82,0,1489,1490,5,
        157,0,0,1490,1494,3,188,94,0,1491,1493,3,98,49,0,1492,1491,1,0,0,
        0,1493,1496,1,0,0,0,1494,1492,1,0,0,0,1494,1495,1,0,0,0,1495,1500,
        1,0,0,0,1496,1494,1,0,0,0,1497,1499,3,100,50,0,1498,1497,1,0,0,0,
        1499,1502,1,0,0,0,1500,1498,1,0,0,0,1500,1501,1,0,0,0,1501,1504,
        1,0,0,0,1502,1500,1,0,0,0,1503,1452,1,0,0,0,1503,1456,1,0,0,0,1503,
        1462,1,0,0,0,1503,1469,1,0,0,0,1503,1476,1,0,0,0,1504,75,1,0,0,0,
        1505,1506,5,162,0,0,1506,1507,5,30,0,0,1507,1512,3,84,42,0,1508,
        1509,5,4,0,0,1509,1511,3,84,42,0,1510,1508,1,0,0,0,1511,1514,1,0,
        0,0,1512,1510,1,0,0,0,1512,1513,1,0,0,0,1513,1516,1,0,0,0,1514,1512,
        1,0,0,0,1515,1505,1,0,0,0,1515,1516,1,0,0,0,1516,1527,1,0,0,0,1517,
        1518,5,38,0,0,1518,1519,5,30,0,0,1519,1524,3,186,93,0,1520,1521,
        5,4,0,0,1521,1523,3,186,93,0,1522,1520,1,0,0,0,1523,1526,1,0,0,0,
        1524,1522,1,0,0,0,1524,1525,1,0,0,0,1525,1528,1,0,0,0,1526,1524,
        1,0,0,0,1527,1517,1,0,0,0,1527,1528,1,0,0,0,1528,1539,1,0,0,0,1529,
        1530,5,75,0,0,1530,1531,5,30,0,0,1531,1536,3,186,93,0,1532,1533,
        5,4,0,0,1533,1535,3,186,93,0,1534,1532,1,0,0,0,1535,1538,1,0,0,0,
        1536,1534,1,0,0,0,1536,1537,1,0,0,0,1537,1540,1,0,0,0,1538,1536,
        1,0,0,0,1539,1529,1,0,0,0,1539,1540,1,0,0,0,1540,1551,1,0,0,0,1541,
        1542,5,218,0,0,1542,1543,5,30,0,0,1543,1548,3,84,42,0,1544,1545,
        5,4,0,0,1545,1547,3,84,42,0,1546,1544,1,0,0,0,1547,1550,1,0,0,0,
        1548,1546,1,0,0,0,1548,1549,1,0,0,0,1549,1552,1,0,0,0,1550,1548,
        1,0,0,0,1551,1541,1,0,0,0,1551,1552,1,0,0,0,1552,1554,1,0,0,0,1553,
        1555,3,238,119,0,1554,1553,1,0,0,0,1554,1555,1,0,0,0,1555,1561,1,
        0,0,0,1556,1559,5,133,0,0,1557,1560,5,14,0,0,1558,1560,3,186,93,
        0,1559,1557,1,0,0,0,1559,1558,1,0,0,0,1560,1562,1,0,0,0,1561,1556,
        1,0,0,0,1561,1562,1,0,0,0,1562,77,1,0,0,0,1563,1564,3,32,16,0,1564,
        1565,3,88,44,0,1565,79,1,0,0,0,1566,1567,6,40,-1,0,1567,1568,3,82,
        41,0,1568,1592,1,0,0,0,1569,1570,10,3,0,0,1570,1571,4,40,1,0,1571,
        1573,7,13,0,0,1572,1574,3,132,66,0,1573,1572,1,0,0,0,1573,1574,1,
        0,0,0,1574,1575,1,0,0,0,1575,1591,3,80,40,4,1576,1577,10,2,0,0,1577,
        1578,4,40,3,0,1578,1580,5,120,0,0,1579,1581,3,132,66,0,1580,1579,
        1,0,0,0,1580,1581,1,0,0,0,1581,1582,1,0,0,0,1582,1591,3,80,40,3,
        1583,1584,10,1,0,0,1584,1585,4,40,5,0,1585,1587,7,14,0,0,1586,1588,
        3,132,66,0,1587,1586,1,0,0,0,1587,1588,1,0,0,0,1588,1589,1,0,0,0,
        1589,1591,3,80,40,2,1590,1569,1,0,0,0,1590,1576,1,0,0,0,1590,1583,
        1,0,0,0,1591,1594,1,0,0,0,1592,1590,1,0,0,0,1592,1593,1,0,0,0,1593,
        81,1,0,0,0,1594,1592,1,0,0,0,1595,1605,3,90,45,0,1596,1605,3,86,
        43,0,1597,1598,5,227,0,0,1598,1605,3,170,85,0,1599,1605,3,160,80,
        0,1600,1601,5,2,0,0,1601,1602,3,30,15,0,1602,1603,5,3,0,0,1603,1605,
        1,0,0,0,1604,1595,1,0,0,0,1604,1596,1,0,0,0,1604,1597,1,0,0,0,1604,
        1599,1,0,0,0,1604,1600,1,0,0,0,1605,83,1,0,0,0,1606,1608,3,186,93,
        0,1607,1609,7,15,0,0,1608,1607,1,0,0,0,1608,1609,1,0,0,0,1609,1612,
        1,0,0,0,1610,1611,5,155,0,0,1611,1613,7,16,0,0,1612,1610,1,0,0,0,
        1612,1613,1,0,0,0,1613,85,1,0,0,0,1614,1616,3,118,59,0,1615,1617,
        3,88,44,0,1616,1615,1,0,0,0,1617,1618,1,0,0,0,1618,1616,1,0,0,0,
        1618,1619,1,0,0,0,1619,87,1,0,0,0,1620,1622,3,92,46,0,1621,1623,
        3,110,55,0,1622,1621,1,0,0,0,1622,1623,1,0,0,0,1623,1624,1,0,0,0,
        1624,1625,3,76,38,0,1625,1648,1,0,0,0,1626,1630,3,94,47,0,1627,1629,
        3,130,65,0,1628,1627,1,0,0,0,1629,1632,1,0,0,0,1630,1628,1,0,0,0,
        1630,1631,1,0,0,0,1631,1634,1,0,0,0,1632,1630,1,0,0,0,1633,1635,
        3,110,55,0,1634,1633,1,0,0,0,1634,1635,1,0,0,0,1635,1637,1,0,0,0,
        1636,1638,3,120,60,0,1637,1636,1,0,0,0,1637,1638,1,0,0,0,1638,1640,
        1,0,0,0,1639,1641,3,112,56,0,1640,1639,1,0,0,0,1640,1641,1,0,0,0,
        1641,1643,1,0,0,0,1642,1644,3,238,119,0,1643,1642,1,0,0,0,1643,1644,
        1,0,0,0,1644,1645,1,0,0,0,1645,1646,3,76,38,0,1646,1648,1,0,0,0,
        1647,1620,1,0,0,0,1647,1626,1,0,0,0,1648,89,1,0,0,0,1649,1651,3,
        92,46,0,1650,1652,3,118,59,0,1651,1650,1,0,0,0,1651,1652,1,0,0,0,
        1652,1654,1,0,0,0,1653,1655,3,110,55,0,1654,1653,1,0,0,0,1654,1655,
        1,0,0,0,1655,1679,1,0,0,0,1656,1658,3,94,47,0,1657,1659,3,118,59,
        0,1658,1657,1,0,0,0,1658,1659,1,0,0,0,1659,1663,1,0,0,0,1660,1662,
        3,130,65,0,1661,1660,1,0,0,0,1662,1665,1,0,0,0,1663,1661,1,0,0,0,
        1663,1664,1,0,0,0,1664,1667,1,0,0,0,1665,1663,1,0,0,0,1666,1668,
        3,110,55,0,1667,1666,1,0,0,0,1667,1668,1,0,0,0,1668,1670,1,0,0,0,
        1669,1671,3,120,60,0,1670,1669,1,0,0,0,1670,1671,1,0,0,0,1671,1673,
        1,0,0,0,1672,1674,3,112,56,0,1673,1672,1,0,0,0,1673,1674,1,0,0,0,
        1674,1676,1,0,0,0,1675,1677,3,238,119,0,1676,1675,1,0,0,0,1676,1677,
        1,0,0,0,1677,1679,1,0,0,0,1678,1649,1,0,0,0,1678,1656,1,0,0,0,1679,
        91,1,0,0,0,1680,1681,5,206,0,0,1681,1682,5,239,0,0,1682,1683,5,2,
        0,0,1683,1684,3,178,89,0,1684,1685,5,3,0,0,1685,1691,1,0,0,0,1686,
        1687,5,143,0,0,1687,1691,3,178,89,0,1688,1689,5,187,0,0,1689,1691,
        3,178,89,0,1690,1680,1,0,0,0,1690,1686,1,0,0,0,1690,1688,1,0,0,0,
        1691,1693,1,0,0,0,1692,1694,3,166,83,0,1693,1692,1,0,0,0,1693,1694,
        1,0,0,0,1694,1697,1,0,0,0,1695,1696,5,185,0,0,1696,1698,5,283,0,
        0,1697,1695,1,0,0,0,1697,1698,1,0,0,0,1698,1699,1,0,0,0,1699,1700,
        5,255,0,0,1700,1713,5,283,0,0,1701,1711,5,22,0,0,1702,1712,3,148,
        74,0,1703,1712,3,228,114,0,1704,1707,5,2,0,0,1705,1708,3,148,74,
        0,1706,1708,3,228,114,0,1707,1705,1,0,0,0,1707,1706,1,0,0,0,1708,
        1709,1,0,0,0,1709,1710,5,3,0,0,1710,1712,1,0,0,0,1711,1702,1,0,0,
        0,1711,1703,1,0,0,0,1711,1704,1,0,0,0,1712,1714,1,0,0,0,1713,1701,
        1,0,0,0,1713,1714,1,0,0,0,1714,1716,1,0,0,0,1715,1717,3,166,83,0,
        1716,1715,1,0,0,0,1716,1717,1,0,0,0,1717,1720,1,0,0,0,1718,1719,
        5,184,0,0,1719,1721,5,283,0,0,1720,1718,1,0,0,0,1720,1721,1,0,0,
        0,1721,93,1,0,0,0,1722,1726,5,206,0,0,1723,1725,3,114,57,0,1724,
        1723,1,0,0,0,1725,1728,1,0,0,0,1726,1724,1,0,0,0,1726,1727,1,0,0,
        0,1727,1730,1,0,0,0,1728,1726,1,0,0,0,1729,1731,3,132,66,0,1730,
        1729,1,0,0,0,1730,1731,1,0,0,0,1731,1732,1,0,0,0,1732,1733,3,178,
        89,0,1733,95,1,0,0,0,1734,1735,5,212,0,0,1735,1736,3,106,53,0,1736,
        97,1,0,0,0,1737,1738,5,259,0,0,1738,1741,5,144,0,0,1739,1740,5,17,
        0,0,1740,1742,3,188,94,0,1741,1739,1,0,0,0,1741,1742,1,0,0,0,1742,
        1743,1,0,0,0,1743,1744,5,233,0,0,1744,1745,3,102,51,0,1745,99,1,
        0,0,0,1746,1747,5,259,0,0,1747,1748,5,153,0,0,1748,1751,5,144,0,
        0,1749,1750,5,17,0,0,1750,1752,3,188,94,0,1751,1749,1,0,0,0,1751,
        1752,1,0,0,0,1752,1753,1,0,0,0,1753,1754,5,233,0,0,1754,1755,3,104,
        52,0,1755,101,1,0,0,0,1756,1764,5,67,0,0,1757,1758,5,252,0,0,1758,
        1759,5,212,0,0,1759,1764,5,274,0,0,1760,1761,5,252,0,0,1761,1762,
        5,212,0,0,1762,1764,3,106,53,0,1763,1756,1,0,0,0,1763,1757,1,0,0,
        0,1763,1760,1,0,0,0,1764,103,1,0,0,0,1765,1766,5,119,0,0,1766,1784,
        5,274,0,0,1767,1768,5,119,0,0,1768,1769,5,2,0,0,1769,1770,3,168,
        84,0,1770,1771,5,3,0,0,1771,1772,5,256,0,0,1772,1773,5,2,0,0,1773,
        1778,3,186,93,0,1774,1775,5,4,0,0,1775,1777,3,186,93,0,1776,1774,
        1,0,0,0,1777,1780,1,0,0,0,1778,1776,1,0,0,0,1778,1779,1,0,0,0,1779,
        1781,1,0,0,0,1780,1778,1,0,0,0,1781,1782,5,3,0,0,1782,1784,1,0,0,
        0,1783,1765,1,0,0,0,1783,1767,1,0,0,0,1784,105,1,0,0,0,1785,1790,
        3,108,54,0,1786,1787,5,4,0,0,1787,1789,3,108,54,0,1788,1786,1,0,
        0,0,1789,1792,1,0,0,0,1790,1788,1,0,0,0,1790,1791,1,0,0,0,1791,107,
        1,0,0,0,1792,1790,1,0,0,0,1793,1794,3,170,85,0,1794,1795,5,264,0,
        0,1795,1796,3,186,93,0,1796,109,1,0,0,0,1797,1798,5,260,0,0,1798,
        1799,3,188,94,0,1799,111,1,0,0,0,1800,1801,5,108,0,0,1801,1802,3,
        188,94,0,1802,113,1,0,0,0,1803,1804,5,6,0,0,1804,1811,3,116,58,0,
        1805,1807,5,4,0,0,1806,1805,1,0,0,0,1806,1807,1,0,0,0,1807,1808,
        1,0,0,0,1808,1810,3,116,58,0,1809,1806,1,0,0,0,1810,1813,1,0,0,0,
        1811,1809,1,0,0,0,1811,1812,1,0,0,0,1812,1814,1,0,0,0,1813,1811,
        1,0,0,0,1814,1815,5,7,0,0,1815,115,1,0,0,0,1816,1830,3,258,129,0,
        1817,1818,3,258,129,0,1818,1819,5,2,0,0,1819,1824,3,194,97,0,1820,
        1821,5,4,0,0,1821,1823,3,194,97,0,1822,1820,1,0,0,0,1823,1826,1,
        0,0,0,1824,1822,1,0,0,0,1824,1825,1,0,0,0,1825,1827,1,0,0,0,1826,
        1824,1,0,0,0,1827,1828,5,3,0,0,1828,1830,1,0,0,0,1829,1816,1,0,0,
        0,1829,1817,1,0,0,0,1830,117,1,0,0,0,1831,1832,5,100,0,0,1832,1837,
        3,134,67,0,1833,1834,5,4,0,0,1834,1836,3,134,67,0,1835,1833,1,0,
        0,0,1836,1839,1,0,0,0,1837,1835,1,0,0,0,1837,1838,1,0,0,0,1838,1843,
        1,0,0,0,1839,1837,1,0,0,0,1840,1842,3,130,65,0,1841,1840,1,0,0,0,
        1842,1845,1,0,0,0,1843,1841,1,0,0,0,1843,1844,1,0,0,0,1844,1847,
        1,0,0,0,1845,1843,1,0,0,0,1846,1848,3,124,62,0,1847,1846,1,0,0,0,
        1847,1848,1,0,0,0,1848,119,1,0,0,0,1849,1850,5,106,0,0,1850,1851,
        5,30,0,0,1851,1856,3,186,93,0,1852,1853,5,4,0,0,1853,1855,3,186,
        93,0,1854,1852,1,0,0,0,1855,1858,1,0,0,0,1856,1854,1,0,0,0,1856,
        1857,1,0,0,0,1857,1876,1,0,0,0,1858,1856,1,0,0,0,1859,1860,5,262,
        0,0,1860,1877,5,201,0,0,1861,1862,5,262,0,0,1862,1877,5,55,0,0,1863,
        1864,5,107,0,0,1864,1865,5,214,0,0,1865,1866,5,2,0,0,1866,1871,3,
        122,61,0,1867,1868,5,4,0,0,1868,1870,3,122,61,0,1869,1867,1,0,0,
        0,1870,1873,1,0,0,0,1871,1869,1,0,0,0,1871,1872,1,0,0,0,1872,1874,
        1,0,0,0,1873,1871,1,0,0,0,1874,1875,5,3,0,0,1875,1877,1,0,0,0,1876,
        1859,1,0,0,0,1876,1861,1,0,0,0,1876,1863,1,0,0,0,1876,1877,1,0,0,
        0,1877,1894,1,0,0,0,1878,1879,5,106,0,0,1879,1880,5,30,0,0,1880,
        1881,5,107,0,0,1881,1882,5,214,0,0,1882,1883,5,2,0,0,1883,1888,3,
        122,61,0,1884,1885,5,4,0,0,1885,1887,3,122,61,0,1886,1884,1,0,0,
        0,1887,1890,1,0,0,0,1888,1886,1,0,0,0,1888,1889,1,0,0,0,1889,1891,
        1,0,0,0,1890,1888,1,0,0,0,1891,1892,5,3,0,0,1892,1894,1,0,0,0,1893,
        1849,1,0,0,0,1893,1878,1,0,0,0,1894,121,1,0,0,0,1895,1904,5,2,0,
        0,1896,1901,3,186,93,0,1897,1898,5,4,0,0,1898,1900,3,186,93,0,1899,
        1897,1,0,0,0,1900,1903,1,0,0,0,1901,1899,1,0,0,0,1901,1902,1,0,0,
        0,1902,1905,1,0,0,0,1903,1901,1,0,0,0,1904,1896,1,0,0,0,1904,1905,
        1,0,0,0,1905,1906,1,0,0,0,1906,1909,5,3,0,0,1907,1909,3,186,93,0,
        1908,1895,1,0,0,0,1908,1907,1,0,0,0,1909,123,1,0,0,0,1910,1911,5,
        174,0,0,1911,1912,5,2,0,0,1912,1913,3,178,89,0,1913,1914,5,96,0,
        0,1914,1915,3,126,63,0,1915,1916,5,113,0,0,1916,1917,5,2,0,0,1917,
        1922,3,128,64,0,1918,1919,5,4,0,0,1919,1921,3,128,64,0,1920,1918,
        1,0,0,0,1921,1924,1,0,0,0,1922,1920,1,0,0,0,1922,1923,1,0,0,0,1923,
        1925,1,0,0,0,1924,1922,1,0,0,0,1925,1926,5,3,0,0,1926,1927,5,3,0,
        0,1927,125,1,0,0,0,1928,1941,3,258,129,0,1929,1930,5,2,0,0,1930,
        1935,3,258,129,0,1931,1932,5,4,0,0,1932,1934,3,258,129,0,1933,1931,
        1,0,0,0,1934,1937,1,0,0,0,1935,1933,1,0,0,0,1935,1936,1,0,0,0,1936,
        1938,1,0,0,0,1937,1935,1,0,0,0,1938,1939,5,3,0,0,1939,1941,1,0,0,
        0,1940,1928,1,0,0,0,1940,1929,1,0,0,0,1941,127,1,0,0,0,1942,1947,
        3,186,93,0,1943,1945,5,22,0,0,1944,1943,1,0,0,0,1944,1945,1,0,0,
        0,1945,1946,1,0,0,0,1946,1948,3,258,129,0,1947,1944,1,0,0,0,1947,
        1948,1,0,0,0,1948,129,1,0,0,0,1949,1950,5,128,0,0,1950,1952,5,257,
        0,0,1951,1953,5,164,0,0,1952,1951,1,0,0,0,1952,1953,1,0,0,0,1953,
        1954,1,0,0,0,1954,1955,3,252,126,0,1955,1964,5,2,0,0,1956,1961,3,
        186,93,0,1957,1958,5,4,0,0,1958,1960,3,186,93,0,1959,1957,1,0,0,
        0,1960,1963,1,0,0,0,1961,1959,1,0,0,0,1961,1962,1,0,0,0,1962,1965,
        1,0,0,0,1963,1961,1,0,0,0,1964,1956,1,0,0,0,1964,1965,1,0,0,0,1965,
        1966,1,0,0,0,1966,1967,5,3,0,0,1967,1979,3,258,129,0,1968,1970,5,
        22,0,0,1969,1968,1,0,0,0,1969,1970,1,0,0,0,1970,1971,1,0,0,0,1971,
        1976,3,258,129,0,1972,1973,5,4,0,0,1973,1975,3,258,129,0,1974,1972,
        1,0,0,0,1975,1978,1,0,0,0,1976,1974,1,0,0,0,1976,1977,1,0,0,0,1977,
        1980,1,0,0,0,1978,1976,1,0,0,0,1979,1969,1,0,0,0,1979,1980,1,0,0,
        0,1980,131,1,0,0,0,1981,1982,7,17,0,0,1982,133,1,0,0,0,1983,1987,
        3,158,79,0,1984,1986,3,136,68,0,1985,1984,1,0,0,0,1986,1989,1,0,
        0,0,1987,1985,1,0,0,0,1987,1988,1,0,0,0,1988,135,1,0,0,0,1989,1987,
        1,0,0,0,1990,1991,3,138,69,0,1991,1992,5,125,0,0,1992,1994,3,158,
        79,0,1993,1995,3,140,70,0,1994,1993,1,0,0,0,1994,1995,1,0,0,0,1995,
        2002,1,0,0,0,1996,1997,5,151,0,0,1997,1998,3,138,69,0,1998,1999,
        5,125,0,0,1999,2000,3,158,79,0,2000,2002,1,0,0,0,2001,1990,1,0,0,
        0,2001,1996,1,0,0,0,2002,137,1,0,0,0,2003,2005,5,116,0,0,2004,2003,
        1,0,0,0,2004,2005,1,0,0,0,2005,2028,1,0,0,0,2006,2028,5,54,0,0,2007,
        2009,5,131,0,0,2008,2010,5,164,0,0,2009,2008,1,0,0,0,2009,2010,1,
        0,0,0,2010,2028,1,0,0,0,2011,2013,5,131,0,0,2012,2011,1,0,0,0,2012,
        2013,1,0,0,0,2013,2014,1,0,0,0,2014,2028,5,207,0,0,2015,2017,5,196,
        0,0,2016,2018,5,164,0,0,2017,2016,1,0,0,0,2017,2018,1,0,0,0,2018,
        2028,1,0,0,0,2019,2021,5,101,0,0,2020,2022,5,164,0,0,2021,2020,1,
        0,0,0,2021,2022,1,0,0,0,2022,2028,1,0,0,0,2023,2025,5,131,0,0,2024,
        2023,1,0,0,0,2024,2025,1,0,0,0,2025,2026,1,0,0,0,2026,2028,5,18,
        0,0,2027,2004,1,0,0,0,2027,2006,1,0,0,0,2027,2007,1,0,0,0,2027,2012,
        1,0,0,0,2027,2015,1,0,0,0,2027,2019,1,0,0,0,2027,2024,1,0,0,0,2028,
        139,1,0,0,0,2029,2030,5,157,0,0,2030,2034,3,188,94,0,2031,2032,5,
        255,0,0,2032,2034,3,146,73,0,2033,2029,1,0,0,0,2033,2031,1,0,0,0,
        2034,141,1,0,0,0,2035,2036,5,229,0,0,2036,2038,5,2,0,0,2037,2039,
        3,144,72,0,2038,2037,1,0,0,0,2038,2039,1,0,0,0,2039,2040,1,0,0,0,
        2040,2041,5,3,0,0,2041,143,1,0,0,0,2042,2044,5,273,0,0,2043,2042,
        1,0,0,0,2043,2044,1,0,0,0,2044,2045,1,0,0,0,2045,2046,7,18,0,0,2046,
        2067,5,173,0,0,2047,2048,3,186,93,0,2048,2049,5,203,0,0,2049,2067,
        1,0,0,0,2050,2051,5,28,0,0,2051,2052,5,287,0,0,2052,2053,5,163,0,
        0,2053,2054,5,156,0,0,2054,2063,5,287,0,0,2055,2061,5,157,0,0,2056,
        2062,3,258,129,0,2057,2058,3,252,126,0,2058,2059,5,2,0,0,2059,2060,
        5,3,0,0,2060,2062,1,0,0,0,2061,2056,1,0,0,0,2061,2057,1,0,0,0,2062,
        2064,1,0,0,0,2063,2055,1,0,0,0,2063,2064,1,0,0,0,2064,2067,1,0,0,
        0,2065,2067,3,186,93,0,2066,2043,1,0,0,0,2066,2047,1,0,0,0,2066,
        2050,1,0,0,0,2066,2065,1,0,0,0,2067,145,1,0,0,0,2068,2069,5,2,0,
        0,2069,2070,3,148,74,0,2070,2071,5,3,0,0,2071,147,1,0,0,0,2072,2077,
        3,254,127,0,2073,2074,5,4,0,0,2074,2076,3,254,127,0,2075,2073,1,
        0,0,0,2076,2079,1,0,0,0,2077,2075,1,0,0,0,2077,2078,1,0,0,0,2078,
        149,1,0,0,0,2079,2077,1,0,0,0,2080,2081,5,2,0,0,2081,2086,3,152,
        76,0,2082,2083,5,4,0,0,2083,2085,3,152,76,0,2084,2082,1,0,0,0,2085,
        2088,1,0,0,0,2086,2084,1,0,0,0,2086,2087,1,0,0,0,2087,2089,1,0,0,
        0,2088,2086,1,0,0,0,2089,2090,5,3,0,0,2090,151,1,0,0,0,2091,2093,
        3,254,127,0,2092,2094,7,15,0,0,2093,2092,1,0,0,0,2093,2094,1,0,0,
        0,2094,153,1,0,0,0,2095,2096,5,2,0,0,2096,2101,3,156,78,0,2097,2098,
        5,4,0,0,2098,2100,3,156,78,0,2099,2097,1,0,0,0,2100,2103,1,0,0,0,
        2101,2099,1,0,0,0,2101,2102,1,0,0,0,2102,2104,1,0,0,0,2103,2101,
        1,0,0,0,2104,2105,5,3,0,0,2105,155,1,0,0,0,2106,2108,3,258,129,0,
        2107,2109,3,28,14,0,2108,2107,1,0,0,0,2108,2109,1,0,0,0,2109,157,
        1,0,0,0,2110,2112,3,170,85,0,2111,2113,3,142,71,0,2112,2111,1,0,
        0,0,2112,2113,1,0,0,0,2113,2114,1,0,0,0,2114,2115,3,164,82,0,2115,
        2133,1,0,0,0,2116,2117,5,2,0,0,2117,2118,3,30,15,0,2118,2120,5,3,
        0,0,2119,2121,3,142,71,0,2120,2119,1,0,0,0,2120,2121,1,0,0,0,2121,
        2122,1,0,0,0,2122,2123,3,164,82,0,2123,2133,1,0,0,0,2124,2125,5,
        2,0,0,2125,2126,3,134,67,0,2126,2128,5,3,0,0,2127,2129,3,142,71,
        0,2128,2127,1,0,0,0,2128,2129,1,0,0,0,2129,2130,1,0,0,0,2130,2131,
        3,164,82,0,2131,2133,1,0,0,0,2132,2110,1,0,0,0,2132,2116,1,0,0,0,
        2132,2124,1,0,0,0,2133,159,1,0,0,0,2134,2135,5,256,0,0,2135,2140,
        3,186,93,0,2136,2137,5,4,0,0,2137,2139,3,186,93,0,2138,2136,1,0,
        0,0,2139,2142,1,0,0,0,2140,2138,1,0,0,0,2140,2141,1,0,0,0,2141,2143,
        1,0,0,0,2142,2140,1,0,0,0,2143,2144,3,164,82,0,2144,161,1,0,0,0,
        2145,2146,3,254,127,0,2146,2155,5,2,0,0,2147,2152,3,186,93,0,2148,
        2149,5,4,0,0,2149,2151,3,186,93,0,2150,2148,1,0,0,0,2151,2154,1,
        0,0,0,2152,2150,1,0,0,0,2152,2153,1,0,0,0,2153,2156,1,0,0,0,2154,
        2152,1,0,0,0,2155,2147,1,0,0,0,2155,2156,1,0,0,0,2156,2157,1,0,0,
        0,2157,2158,5,3,0,0,2158,2159,3,164,82,0,2159,163,1,0,0,0,2160,2162,
        5,22,0,0,2161,2160,1,0,0,0,2161,2162,1,0,0,0,2162,2163,1,0,0,0,2163,
        2165,3,260,130,0,2164,2166,3,146,73,0,2165,2164,1,0,0,0,2165,2166,
        1,0,0,0,2166,2168,1,0,0,0,2167,2161,1,0,0,0,2167,2168,1,0,0,0,2168,
        165,1,0,0,0,2169,2170,5,202,0,0,2170,2171,5,98,0,0,2171,2172,5,209,
        0,0,2172,2176,5,283,0,0,2173,2174,5,262,0,0,2174,2175,5,210,0,0,
        2175,2177,3,54,27,0,2176,2173,1,0,0,0,2176,2177,1,0,0,0,2177,2219,
        1,0,0,0,2178,2179,5,202,0,0,2179,2180,5,98,0,0,2180,2190,5,68,0,
        0,2181,2182,5,91,0,0,2182,2183,5,232,0,0,2183,2184,5,30,0,0,2184,
        2188,5,283,0,0,2185,2186,5,80,0,0,2186,2187,5,30,0,0,2187,2189,5,
        283,0,0,2188,2185,1,0,0,0,2188,2189,1,0,0,0,2189,2191,1,0,0,0,2190,
        2181,1,0,0,0,2190,2191,1,0,0,0,2191,2197,1,0,0,0,2192,2193,5,42,
        0,0,2193,2194,5,124,0,0,2194,2195,5,232,0,0,2195,2196,5,30,0,0,2196,
        2198,5,283,0,0,2197,2192,1,0,0,0,2197,2198,1,0,0,0,2198,2204,1,0,
        0,0,2199,2200,5,143,0,0,2200,2201,5,126,0,0,2201,2202,5,232,0,0,
        2202,2203,5,30,0,0,2203,2205,5,283,0,0,2204,2199,1,0,0,0,2204,2205,
        1,0,0,0,2205,2210,1,0,0,0,2206,2207,5,134,0,0,2207,2208,5,232,0,
        0,2208,2209,5,30,0,0,2209,2211,5,283,0,0,2210,2206,1,0,0,0,2210,
        2211,1,0,0,0,2211,2216,1,0,0,0,2212,2213,5,154,0,0,2213,2214,5,66,
        0,0,2214,2215,5,22,0,0,2215,2217,5,283,0,0,2216,2212,1,0,0,0,2216,
        2217,1,0,0,0,2217,2219,1,0,0,0,2218,2169,1,0,0,0,2218,2178,1,0,0,
        0,2219,167,1,0,0,0,2220,2225,3,170,85,0,2221,2222,5,4,0,0,2222,2224,
        3,170,85,0,2223,2221,1,0,0,0,2224,2227,1,0,0,0,2225,2223,1,0,0,0,
        2225,2226,1,0,0,0,2226,169,1,0,0,0,2227,2225,1,0,0,0,2228,2233,3,
        254,127,0,2229,2230,5,5,0,0,2230,2232,3,254,127,0,2231,2229,1,0,
        0,0,2232,2235,1,0,0,0,2233,2231,1,0,0,0,2233,2234,1,0,0,0,2234,171,
        1,0,0,0,2235,2233,1,0,0,0,2236,2237,3,254,127,0,2237,2238,5,5,0,
        0,2238,2240,1,0,0,0,2239,2236,1,0,0,0,2239,2240,1,0,0,0,2240,2241,
        1,0,0,0,2241,2242,3,254,127,0,2242,173,1,0,0,0,2243,2244,3,254,127,
        0,2244,2245,5,5,0,0,2245,2247,1,0,0,0,2246,2243,1,0,0,0,2246,2247,
        1,0,0,0,2247,2248,1,0,0,0,2248,2249,3,254,127,0,2249,175,1,0,0,0,
        2250,2258,3,186,93,0,2251,2253,5,22,0,0,2252,2251,1,0,0,0,2252,2253,
        1,0,0,0,2253,2256,1,0,0,0,2254,2257,3,254,127,0,2255,2257,3,146,
        73,0,2256,2254,1,0,0,0,2256,2255,1,0,0,0,2257,2259,1,0,0,0,2258,
        2252,1,0,0,0,2258,2259,1,0,0,0,2259,177,1,0,0,0,2260,2265,3,176,
        88,0,2261,2262,5,4,0,0,2262,2264,3,176,88,0,2263,2261,1,0,0,0,2264,
        2267,1,0,0,0,2265,2263,1,0,0,0,2265,2266,1,0,0,0,2266,179,1,0,0,
        0,2267,2265,1,0,0,0,2268,2269,5,2,0,0,2269,2274,3,182,91,0,2270,
        2271,5,4,0,0,2271,2273,3,182,91,0,2272,2270,1,0,0,0,2273,2276,1,
        0,0,0,2274,2272,1,0,0,0,2274,2275,1,0,0,0,2275,2277,1,0,0,0,2276,
        2274,1,0,0,0,2277,2278,5,3,0,0,2278,181,1,0,0,0,2279,2293,3,252,
        126,0,2280,2281,3,258,129,0,2281,2282,5,2,0,0,2282,2287,3,184,92,
        0,2283,2284,5,4,0,0,2284,2286,3,184,92,0,2285,2283,1,0,0,0,2286,
        2289,1,0,0,0,2287,2285,1,0,0,0,2287,2288,1,0,0,0,2288,2290,1,0,0,
        0,2289,2287,1,0,0,0,2290,2291,5,3,0,0,2291,2293,1,0,0,0,2292,2279,
        1,0,0,0,2292,2280,1,0,0,0,2293,183,1,0,0,0,2294,2297,3,252,126,0,
        2295,2297,3,196,98,0,2296,2294,1,0,0,0,2296,2295,1,0,0,0,2297,185,
        1,0,0,0,2298,2299,3,188,94,0,2299,187,1,0,0,0,2300,2301,6,94,-1,
        0,2301,2302,5,153,0,0,2302,2313,3,188,94,5,2303,2304,5,83,0,0,2304,
        2305,5,2,0,0,2305,2306,3,30,15,0,2306,2307,5,3,0,0,2307,2313,1,0,
        0,0,2308,2310,3,192,96,0,2309,2311,3,190,95,0,2310,2309,1,0,0,0,
        2310,2311,1,0,0,0,2311,2313,1,0,0,0,2312,2300,1,0,0,0,2312,2303,
        1,0,0,0,2312,2308,1,0,0,0,2313,2322,1,0,0,0,2314,2315,10,2,0,0,2315,
        2316,5,17,0,0,2316,2321,3,188,94,3,2317,2318,10,1,0,0,2318,2319,
        5,161,0,0,2319,2321,3,188,94,2,2320,2314,1,0,0,0,2320,2317,1,0,0,
        0,2321,2324,1,0,0,0,2322,2320,1,0,0,0,2322,2323,1,0,0,0,2323,189,
        1,0,0,0,2324,2322,1,0,0,0,2325,2327,5,153,0,0,2326,2325,1,0,0,0,
        2326,2327,1,0,0,0,2327,2328,1,0,0,0,2328,2329,5,26,0,0,2329,2330,
        3,192,96,0,2330,2331,5,17,0,0,2331,2332,3,192,96,0,2332,2408,1,0,
        0,0,2333,2335,5,153,0,0,2334,2333,1,0,0,0,2334,2335,1,0,0,0,2335,
        2336,1,0,0,0,2336,2337,5,113,0,0,2337,2338,5,2,0,0,2338,2343,3,186,
        93,0,2339,2340,5,4,0,0,2340,2342,3,186,93,0,2341,2339,1,0,0,0,2342,
        2345,1,0,0,0,2343,2341,1,0,0,0,2343,2344,1,0,0,0,2344,2346,1,0,0,
        0,2345,2343,1,0,0,0,2346,2347,5,3,0,0,2347,2408,1,0,0,0,2348,2350,
        5,153,0,0,2349,2348,1,0,0,0,2349,2350,1,0,0,0,2350,2351,1,0,0,0,
        2351,2352,5,113,0,0,2352,2353,5,2,0,0,2353,2354,3,30,15,0,2354,2355,
        5,3,0,0,2355,2408,1,0,0,0,2356,2358,5,153,0,0,2357,2356,1,0,0,0,
        2357,2358,1,0,0,0,2358,2359,1,0,0,0,2359,2360,5,197,0,0,2360,2408,
        3,192,96,0,2361,2363,5,153,0,0,2362,2361,1,0,0,0,2362,2363,1,0,0,
        0,2363,2364,1,0,0,0,2364,2365,5,132,0,0,2365,2379,7,19,0,0,2366,
        2367,5,2,0,0,2367,2380,5,3,0,0,2368,2369,5,2,0,0,2369,2374,3,186,
        93,0,2370,2371,5,4,0,0,2371,2373,3,186,93,0,2372,2370,1,0,0,0,2373,
        2376,1,0,0,0,2374,2372,1,0,0,0,2374,2375,1,0,0,0,2375,2377,1,0,0,
        0,2376,2374,1,0,0,0,2377,2378,5,3,0,0,2378,2380,1,0,0,0,2379,2366,
        1,0,0,0,2379,2368,1,0,0,0,2380,2408,1,0,0,0,2381,2383,5,153,0,0,
        2382,2381,1,0,0,0,2382,2383,1,0,0,0,2383,2384,1,0,0,0,2384,2385,
        5,132,0,0,2385,2388,3,192,96,0,2386,2387,5,79,0,0,2387,2389,5,283,
        0,0,2388,2386,1,0,0,0,2388,2389,1,0,0,0,2389,2408,1,0,0,0,2390,2392,
        5,123,0,0,2391,2393,5,153,0,0,2392,2391,1,0,0,0,2392,2393,1,0,0,
        0,2393,2394,1,0,0,0,2394,2408,5,154,0,0,2395,2397,5,123,0,0,2396,
        2398,5,153,0,0,2397,2396,1,0,0,0,2397,2398,1,0,0,0,2398,2399,1,0,
        0,0,2399,2408,7,20,0,0,2400,2402,5,123,0,0,2401,2403,5,153,0,0,2402,
        2401,1,0,0,0,2402,2403,1,0,0,0,2403,2404,1,0,0,0,2404,2405,5,74,
        0,0,2405,2406,5,100,0,0,2406,2408,3,192,96,0,2407,2326,1,0,0,0,2407,
        2334,1,0,0,0,2407,2349,1,0,0,0,2407,2357,1,0,0,0,2407,2362,1,0,0,
        0,2407,2382,1,0,0,0,2407,2390,1,0,0,0,2407,2395,1,0,0,0,2407,2400,
        1,0,0,0,2408,191,1,0,0,0,2409,2410,6,96,-1,0,2410,2414,3,194,97,
        0,2411,2412,7,21,0,0,2412,2414,3,192,96,7,2413,2409,1,0,0,0,2413,
        2411,1,0,0,0,2414,2436,1,0,0,0,2415,2416,10,6,0,0,2416,2417,7,22,
        0,0,2417,2435,3,192,96,7,2418,2419,10,5,0,0,2419,2420,7,23,0,0,2420,
        2435,3,192,96,6,2421,2422,10,4,0,0,2422,2423,5,279,0,0,2423,2435,
        3,192,96,5,2424,2425,10,3,0,0,2425,2426,5,282,0,0,2426,2435,3,192,
        96,4,2427,2428,10,2,0,0,2428,2429,5,280,0,0,2429,2435,3,192,96,3,
        2430,2431,10,1,0,0,2431,2432,3,198,99,0,2432,2433,3,192,96,2,2433,
        2435,1,0,0,0,2434,2415,1,0,0,0,2434,2418,1,0,0,0,2434,2421,1,0,0,
        0,2434,2424,1,0,0,0,2434,2427,1,0,0,0,2434,2430,1,0,0,0,2435,2438,
        1,0,0,0,2436,2434,1,0,0,0,2436,2437,1,0,0,0,2437,193,1,0,0,0,2438,
        2436,1,0,0,0,2439,2440,6,97,-1,0,2440,2624,7,24,0,0,2441,2443,5,
        33,0,0,2442,2444,3,236,118,0,2443,2442,1,0,0,0,2444,2445,1,0,0,0,
        2445,2443,1,0,0,0,2445,2446,1,0,0,0,2446,2449,1,0,0,0,2447,2448,
        5,77,0,0,2448,2450,3,186,93,0,2449,2447,1,0,0,0,2449,2450,1,0,0,
        0,2450,2451,1,0,0,0,2451,2452,5,78,0,0,2452,2624,1,0,0,0,2453,2454,
        5,33,0,0,2454,2456,3,186,93,0,2455,2457,3,236,118,0,2456,2455,1,
        0,0,0,2457,2458,1,0,0,0,2458,2456,1,0,0,0,2458,2459,1,0,0,0,2459,
        2462,1,0,0,0,2460,2461,5,77,0,0,2461,2463,3,186,93,0,2462,2460,1,
        0,0,0,2462,2463,1,0,0,0,2463,2464,1,0,0,0,2464,2465,5,78,0,0,2465,
        2624,1,0,0,0,2466,2467,5,34,0,0,2467,2468,5,2,0,0,2468,2469,3,186,
        93,0,2469,2470,5,22,0,0,2470,2471,3,222,111,0,2471,2472,5,3,0,0,
        2472,2624,1,0,0,0,2473,2474,5,224,0,0,2474,2483,5,2,0,0,2475,2480,
        3,176,88,0,2476,2477,5,4,0,0,2477,2479,3,176,88,0,2478,2476,1,0,
        0,0,2479,2482,1,0,0,0,2480,2478,1,0,0,0,2480,2481,1,0,0,0,2481,2484,
        1,0,0,0,2482,2480,1,0,0,0,2483,2475,1,0,0,0,2483,2484,1,0,0,0,2484,
        2485,1,0,0,0,2485,2624,5,3,0,0,2486,2487,5,94,0,0,2487,2488,5,2,
        0,0,2488,2491,3,186,93,0,2489,2490,5,111,0,0,2490,2492,5,155,0,0,
        2491,2489,1,0,0,0,2491,2492,1,0,0,0,2492,2493,1,0,0,0,2493,2494,
        5,3,0,0,2494,2624,1,0,0,0,2495,2496,5,127,0,0,2496,2497,5,2,0,0,
        2497,2500,3,186,93,0,2498,2499,5,111,0,0,2499,2501,5,155,0,0,2500,
        2498,1,0,0,0,2500,2501,1,0,0,0,2501,2502,1,0,0,0,2502,2503,5,3,0,
        0,2503,2624,1,0,0,0,2504,2505,5,176,0,0,2505,2506,5,2,0,0,2506,2507,
        3,192,96,0,2507,2508,5,113,0,0,2508,2509,3,192,96,0,2509,2510,5,
        3,0,0,2510,2624,1,0,0,0,2511,2624,3,196,98,0,2512,2624,5,274,0,0,
        2513,2514,3,252,126,0,2514,2515,5,5,0,0,2515,2516,5,274,0,0,2516,
        2624,1,0,0,0,2517,2518,5,2,0,0,2518,2521,3,176,88,0,2519,2520,5,
        4,0,0,2520,2522,3,176,88,0,2521,2519,1,0,0,0,2522,2523,1,0,0,0,2523,
        2521,1,0,0,0,2523,2524,1,0,0,0,2524,2525,1,0,0,0,2525,2526,5,3,0,
        0,2526,2624,1,0,0,0,2527,2528,5,2,0,0,2528,2529,3,30,15,0,2529,2530,
        5,3,0,0,2530,2624,1,0,0,0,2531,2532,3,250,125,0,2532,2544,5,2,0,
        0,2533,2535,3,132,66,0,2534,2533,1,0,0,0,2534,2535,1,0,0,0,2535,
        2536,1,0,0,0,2536,2541,3,186,93,0,2537,2538,5,4,0,0,2538,2540,3,
        186,93,0,2539,2537,1,0,0,0,2540,2543,1,0,0,0,2541,2539,1,0,0,0,2541,
        2542,1,0,0,0,2542,2545,1,0,0,0,2543,2541,1,0,0,0,2544,2534,1,0,0,
        0,2544,2545,1,0,0,0,2545,2546,1,0,0,0,2546,2553,5,3,0,0,2547,2548,
        5,92,0,0,2548,2549,5,2,0,0,2549,2550,5,260,0,0,2550,2551,3,188,94,
        0,2551,2552,5,3,0,0,2552,2554,1,0,0,0,2553,2547,1,0,0,0,2553,2554,
        1,0,0,0,2554,2557,1,0,0,0,2555,2556,5,166,0,0,2556,2558,3,242,121,
        0,2557,2555,1,0,0,0,2557,2558,1,0,0,0,2558,2624,1,0,0,0,2559,2560,
        3,258,129,0,2560,2561,5,8,0,0,2561,2562,3,186,93,0,2562,2624,1,0,
        0,0,2563,2564,5,2,0,0,2564,2567,3,258,129,0,2565,2566,5,4,0,0,2566,
        2568,3,258,129,0,2567,2565,1,0,0,0,2568,2569,1,0,0,0,2569,2567,1,
        0,0,0,2569,2570,1,0,0,0,2570,2571,1,0,0,0,2571,2572,5,3,0,0,2572,
        2573,5,8,0,0,2573,2574,3,186,93,0,2574,2624,1,0,0,0,2575,2624,3,
        258,129,0,2576,2577,5,2,0,0,2577,2578,3,186,93,0,2578,2579,5,3,0,
        0,2579,2624,1,0,0,0,2580,2581,5,88,0,0,2581,2582,5,2,0,0,2582,2583,
        3,258,129,0,2583,2584,5,100,0,0,2584,2585,3,192,96,0,2585,2586,5,
        3,0,0,2586,2624,1,0,0,0,2587,2588,7,25,0,0,2588,2589,5,2,0,0,2589,
        2590,3,192,96,0,2590,2591,7,26,0,0,2591,2594,3,192,96,0,2592,2593,
        7,27,0,0,2593,2595,3,192,96,0,2594,2592,1,0,0,0,2594,2595,1,0,0,
        0,2595,2596,1,0,0,0,2596,2597,5,3,0,0,2597,2624,1,0,0,0,2598,2599,
        5,240,0,0,2599,2601,5,2,0,0,2600,2602,7,28,0,0,2601,2600,1,0,0,0,
        2601,2602,1,0,0,0,2602,2604,1,0,0,0,2603,2605,3,192,96,0,2604,2603,
        1,0,0,0,2604,2605,1,0,0,0,2605,2606,1,0,0,0,2606,2607,5,100,0,0,
        2607,2608,3,192,96,0,2608,2609,5,3,0,0,2609,2624,1,0,0,0,2610,2611,
        5,168,0,0,2611,2612,5,2,0,0,2612,2613,3,192,96,0,2613,2614,5,175,
        0,0,2614,2615,3,192,96,0,2615,2616,5,100,0,0,2616,2619,3,192,96,
        0,2617,2618,5,96,0,0,2618,2620,3,192,96,0,2619,2617,1,0,0,0,2619,
        2620,1,0,0,0,2620,2621,1,0,0,0,2621,2622,5,3,0,0,2622,2624,1,0,0,
        0,2623,2439,1,0,0,0,2623,2441,1,0,0,0,2623,2453,1,0,0,0,2623,2466,
        1,0,0,0,2623,2473,1,0,0,0,2623,2486,1,0,0,0,2623,2495,1,0,0,0,2623,
        2504,1,0,0,0,2623,2511,1,0,0,0,2623,2512,1,0,0,0,2623,2513,1,0,0,
        0,2623,2517,1,0,0,0,2623,2527,1,0,0,0,2623,2531,1,0,0,0,2623,2559,
        1,0,0,0,2623,2563,1,0,0,0,2623,2575,1,0,0,0,2623,2576,1,0,0,0,2623,
        2580,1,0,0,0,2623,2587,1,0,0,0,2623,2598,1,0,0,0,2623,2610,1,0,0,
        0,2624,2635,1,0,0,0,2625,2626,10,8,0,0,2626,2627,5,9,0,0,2627,2628,
        3,192,96,0,2628,2629,5,10,0,0,2629,2634,1,0,0,0,2630,2631,10,6,0,
        0,2631,2632,5,5,0,0,2632,2634,3,258,129,0,2633,2625,1,0,0,0,2633,
        2630,1,0,0,0,2634,2637,1,0,0,0,2635,2633,1,0,0,0,2635,2636,1,0,0,
        0,2636,195,1,0,0,0,2637,2635,1,0,0,0,2638,2651,5,154,0,0,2639,2651,
        3,206,103,0,2640,2641,3,258,129,0,2641,2642,5,283,0,0,2642,2651,
        1,0,0,0,2643,2651,3,264,132,0,2644,2651,3,204,102,0,2645,2647,5,
        283,0,0,2646,2645,1,0,0,0,2647,2648,1,0,0,0,2648,2646,1,0,0,0,2648,
        2649,1,0,0,0,2649,2651,1,0,0,0,2650,2638,1,0,0,0,2650,2639,1,0,0,
        0,2650,2640,1,0,0,0,2650,2643,1,0,0,0,2650,2644,1,0,0,0,2650,2646,
        1,0,0,0,2651,197,1,0,0,0,2652,2653,7,29,0,0,2653,199,1,0,0,0,2654,
        2655,7,30,0,0,2655,201,1,0,0,0,2656,2657,7,31,0,0,2657,203,1,0,0,
        0,2658,2659,7,32,0,0,2659,205,1,0,0,0,2660,2663,5,121,0,0,2661,2664,
        3,208,104,0,2662,2664,3,212,106,0,2663,2661,1,0,0,0,2663,2662,1,
        0,0,0,2663,2664,1,0,0,0,2664,207,1,0,0,0,2665,2667,3,210,105,0,2666,
        2668,3,214,107,0,2667,2666,1,0,0,0,2667,2668,1,0,0,0,2668,209,1,
        0,0,0,2669,2670,3,216,108,0,2670,2671,3,218,109,0,2671,2673,1,0,
        0,0,2672,2669,1,0,0,0,2673,2674,1,0,0,0,2674,2672,1,0,0,0,2674,2675,
        1,0,0,0,2675,211,1,0,0,0,2676,2679,3,214,107,0,2677,2680,3,210,105,
        0,2678,2680,3,214,107,0,2679,2677,1,0,0,0,2679,2678,1,0,0,0,2679,
        2680,1,0,0,0,2680,213,1,0,0,0,2681,2682,3,216,108,0,2682,2683,3,
        218,109,0,2683,2684,5,234,0,0,2684,2685,3,218,109,0,2685,215,1,0,
        0,0,2686,2688,7,33,0,0,2687,2686,1,0,0,0,2687,2688,1,0,0,0,2688,
        2689,1,0,0,0,2689,2692,7,18,0,0,2690,2692,5,283,0,0,2691,2687,1,
        0,0,0,2691,2690,1,0,0,0,2692,217,1,0,0,0,2693,2701,5,64,0,0,2694,
        2701,5,109,0,0,2695,2701,5,146,0,0,2696,2701,5,147,0,0,2697,2701,
        5,205,0,0,2698,2701,5,263,0,0,2699,2701,3,258,129,0,2700,2693,1,
        0,0,0,2700,2694,1,0,0,0,2700,2695,1,0,0,0,2700,2696,1,0,0,0,2700,
        2697,1,0,0,0,2700,2698,1,0,0,0,2700,2699,1,0,0,0,2701,219,1,0,0,
        0,2702,2706,5,94,0,0,2703,2704,5,13,0,0,2704,2706,3,254,127,0,2705,
        2702,1,0,0,0,2705,2703,1,0,0,0,2706,221,1,0,0,0,2707,2708,5,21,0,
        0,2708,2709,5,268,0,0,2709,2710,3,222,111,0,2710,2711,5,270,0,0,
        2711,2742,1,0,0,0,2712,2713,5,143,0,0,2713,2714,5,268,0,0,2714,2715,
        3,222,111,0,2715,2716,5,4,0,0,2716,2717,3,222,111,0,2717,2718,5,
        270,0,0,2718,2742,1,0,0,0,2719,2726,5,224,0,0,2720,2722,5,268,0,
        0,2721,2723,3,232,116,0,2722,2721,1,0,0,0,2722,2723,1,0,0,0,2723,
        2724,1,0,0,0,2724,2727,5,270,0,0,2725,2727,5,266,0,0,2726,2720,1,
        0,0,0,2726,2725,1,0,0,0,2727,2742,1,0,0,0,2728,2739,3,258,129,0,
        2729,2730,5,2,0,0,2730,2735,5,287,0,0,2731,2732,5,4,0,0,2732,2734,
        5,287,0,0,2733,2731,1,0,0,0,2734,2737,1,0,0,0,2735,2733,1,0,0,0,
        2735,2736,1,0,0,0,2736,2738,1,0,0,0,2737,2735,1,0,0,0,2738,2740,
        5,3,0,0,2739,2729,1,0,0,0,2739,2740,1,0,0,0,2740,2742,1,0,0,0,2741,
        2707,1,0,0,0,2741,2712,1,0,0,0,2741,2719,1,0,0,0,2741,2728,1,0,0,
        0,2742,223,1,0,0,0,2743,2748,3,226,113,0,2744,2745,5,4,0,0,2745,
        2747,3,226,113,0,2746,2744,1,0,0,0,2747,2750,1,0,0,0,2748,2746,1,
        0,0,0,2748,2749,1,0,0,0,2749,225,1,0,0,0,2750,2748,1,0,0,0,2751,
        2752,3,170,85,0,2752,2755,3,222,111,0,2753,2754,5,153,0,0,2754,2756,
        5,154,0,0,2755,2753,1,0,0,0,2755,2756,1,0,0,0,2756,2758,1,0,0,0,
        2757,2759,3,28,14,0,2758,2757,1,0,0,0,2758,2759,1,0,0,0,2759,2761,
        1,0,0,0,2760,2762,3,220,110,0,2761,2760,1,0,0,0,2761,2762,1,0,0,
        0,2762,227,1,0,0,0,2763,2768,3,230,115,0,2764,2765,5,4,0,0,2765,
        2767,3,230,115,0,2766,2764,1,0,0,0,2767,2770,1,0,0,0,2768,2766,1,
        0,0,0,2768,2769,1,0,0,0,2769,229,1,0,0,0,2770,2768,1,0,0,0,2771,
        2772,3,254,127,0,2772,2775,3,222,111,0,2773,2774,5,153,0,0,2774,
        2776,5,154,0,0,2775,2773,1,0,0,0,2775,2776,1,0,0,0,2776,2778,1,0,
        0,0,2777,2779,3,28,14,0,2778,2777,1,0,0,0,2778,2779,1,0,0,0,2779,
        231,1,0,0,0,2780,2785,3,234,117,0,2781,2782,5,4,0,0,2782,2784,3,
        234,117,0,2783,2781,1,0,0,0,2784,2787,1,0,0,0,2785,2783,1,0,0,0,
        2785,2786,1,0,0,0,2786,233,1,0,0,0,2787,2785,1,0,0,0,2788,2789,3,
        258,129,0,2789,2790,5,11,0,0,2790,2793,3,222,111,0,2791,2792,5,153,
        0,0,2792,2794,5,154,0,0,2793,2791,1,0,0,0,2793,2794,1,0,0,0,2794,
        2796,1,0,0,0,2795,2797,3,28,14,0,2796,2795,1,0,0,0,2796,2797,1,0,
        0,0,2797,235,1,0,0,0,2798,2799,5,259,0,0,2799,2800,3,186,93,0,2800,
        2801,5,233,0,0,2801,2802,3,186,93,0,2802,237,1,0,0,0,2803,2804,5,
        261,0,0,2804,2809,3,240,120,0,2805,2806,5,4,0,0,2806,2808,3,240,
        120,0,2807,2805,1,0,0,0,2808,2811,1,0,0,0,2809,2807,1,0,0,0,2809,
        2810,1,0,0,0,2810,239,1,0,0,0,2811,2809,1,0,0,0,2812,2813,3,254,
        127,0,2813,2814,5,22,0,0,2814,2815,3,242,121,0,2815,241,1,0,0,0,
        2816,2863,3,254,127,0,2817,2818,5,2,0,0,2818,2819,3,254,127,0,2819,
        2820,5,3,0,0,2820,2863,1,0,0,0,2821,2856,5,2,0,0,2822,2823,5,38,
        0,0,2823,2824,5,30,0,0,2824,2829,3,186,93,0,2825,2826,5,4,0,0,2826,
        2828,3,186,93,0,2827,2825,1,0,0,0,2828,2831,1,0,0,0,2829,2827,1,
        0,0,0,2829,2830,1,0,0,0,2830,2857,1,0,0,0,2831,2829,1,0,0,0,2832,
        2833,7,34,0,0,2833,2834,5,30,0,0,2834,2839,3,186,93,0,2835,2836,
        5,4,0,0,2836,2838,3,186,93,0,2837,2835,1,0,0,0,2838,2841,1,0,0,0,
        2839,2837,1,0,0,0,2839,2840,1,0,0,0,2840,2843,1,0,0,0,2841,2839,
        1,0,0,0,2842,2832,1,0,0,0,2842,2843,1,0,0,0,2843,2854,1,0,0,0,2844,
        2845,7,35,0,0,2845,2846,5,30,0,0,2846,2851,3,84,42,0,2847,2848,5,
        4,0,0,2848,2850,3,84,42,0,2849,2847,1,0,0,0,2850,2853,1,0,0,0,2851,
        2849,1,0,0,0,2851,2852,1,0,0,0,2852,2855,1,0,0,0,2853,2851,1,0,0,
        0,2854,2844,1,0,0,0,2854,2855,1,0,0,0,2855,2857,1,0,0,0,2856,2822,
        1,0,0,0,2856,2842,1,0,0,0,2857,2859,1,0,0,0,2858,2860,3,244,122,
        0,2859,2858,1,0,0,0,2859,2860,1,0,0,0,2860,2861,1,0,0,0,2861,2863,
        5,3,0,0,2862,2816,1,0,0,0,2862,2817,1,0,0,0,2862,2821,1,0,0,0,2863,
        243,1,0,0,0,2864,2865,5,183,0,0,2865,2881,3,246,123,0,2866,2867,
        5,203,0,0,2867,2881,3,246,123,0,2868,2869,5,183,0,0,2869,2870,5,
        26,0,0,2870,2871,3,246,123,0,2871,2872,5,17,0,0,2872,2873,3,246,
        123,0,2873,2881,1,0,0,0,2874,2875,5,203,0,0,2875,2876,5,26,0,0,2876,
        2877,3,246,123,0,2877,2878,5,17,0,0,2878,2879,3,246,123,0,2879,2881,
        1,0,0,0,2880,2864,1,0,0,0,2880,2866,1,0,0,0,2880,2868,1,0,0,0,2880,
        2874,1,0,0,0,2881,245,1,0,0,0,2882,2883,5,245,0,0,2883,2890,7,36,
        0,0,2884,2885,5,56,0,0,2885,2890,5,202,0,0,2886,2887,3,186,93,0,
        2887,2888,7,36,0,0,2888,2890,1,0,0,0,2889,2882,1,0,0,0,2889,2884,
        1,0,0,0,2889,2886,1,0,0,0,2890,247,1,0,0,0,2891,2896,3,252,126,0,
        2892,2893,5,4,0,0,2893,2895,3,252,126,0,2894,2892,1,0,0,0,2895,2898,
        1,0,0,0,2896,2894,1,0,0,0,2896,2897,1,0,0,0,2897,249,1,0,0,0,2898,
        2896,1,0,0,0,2899,2904,3,252,126,0,2900,2904,5,92,0,0,2901,2904,
        5,131,0,0,2902,2904,5,196,0,0,2903,2899,1,0,0,0,2903,2900,1,0,0,
        0,2903,2901,1,0,0,0,2903,2902,1,0,0,0,2904,251,1,0,0,0,2905,2910,
        3,258,129,0,2906,2907,5,5,0,0,2907,2909,3,258,129,0,2908,2906,1,
        0,0,0,2909,2912,1,0,0,0,2910,2908,1,0,0,0,2910,2911,1,0,0,0,2911,
        253,1,0,0,0,2912,2910,1,0,0,0,2913,2914,3,258,129,0,2914,2915,3,
        256,128,0,2915,255,1,0,0,0,2916,2917,5,273,0,0,2917,2919,3,258,129,
        0,2918,2916,1,0,0,0,2919,2920,1,0,0,0,2920,2918,1,0,0,0,2920,2921,
        1,0,0,0,2921,2924,1,0,0,0,2922,2924,1,0,0,0,2923,2918,1,0,0,0,2923,
        2922,1,0,0,0,2924,257,1,0,0,0,2925,2929,3,260,130,0,2926,2927,4,
        129,16,0,2927,2929,3,270,135,0,2928,2925,1,0,0,0,2928,2926,1,0,0,
        0,2929,259,1,0,0,0,2930,2937,5,292,0,0,2931,2937,3,262,131,0,2932,
        2933,4,130,17,0,2933,2937,3,268,134,0,2934,2935,4,130,18,0,2935,
        2937,3,272,136,0,2936,2930,1,0,0,0,2936,2931,1,0,0,0,2936,2932,1,
        0,0,0,2936,2934,1,0,0,0,2937,261,1,0,0,0,2938,2939,5,293,0,0,2939,
        263,1,0,0,0,2940,2942,4,132,19,0,2941,2943,5,273,0,0,2942,2941,1,
        0,0,0,2942,2943,1,0,0,0,2943,2944,1,0,0,0,2944,2980,5,288,0,0,2945,
        2947,4,132,20,0,2946,2948,5,273,0,0,2947,2946,1,0,0,0,2947,2948,
        1,0,0,0,2948,2949,1,0,0,0,2949,2980,5,289,0,0,2950,2952,4,132,21,
        0,2951,2953,5,273,0,0,2952,2951,1,0,0,0,2952,2953,1,0,0,0,2953,2954,
        1,0,0,0,2954,2980,7,37,0,0,2955,2957,5,273,0,0,2956,2955,1,0,0,0,
        2956,2957,1,0,0,0,2957,2958,1,0,0,0,2958,2980,5,287,0,0,2959,2961,
        5,273,0,0,2960,2959,1,0,0,0,2960,2961,1,0,0,0,2961,2962,1,0,0,0,
        2962,2980,5,284,0,0,2963,2965,5,273,0,0,2964,2963,1,0,0,0,2964,2965,
        1,0,0,0,2965,2966,1,0,0,0,2966,2980,5,285,0,0,2967,2969,5,273,0,
        0,2968,2967,1,0,0,0,2968,2969,1,0,0,0,2969,2970,1,0,0,0,2970,2980,
        5,286,0,0,2971,2973,5,273,0,0,2972,2971,1,0,0,0,2972,2973,1,0,0,
        0,2973,2974,1,0,0,0,2974,2980,5,290,0,0,2975,2977,5,273,0,0,2976,
        2975,1,0,0,0,2976,2977,1,0,0,0,2977,2978,1,0,0,0,2978,2980,5,291,
        0,0,2979,2940,1,0,0,0,2979,2945,1,0,0,0,2979,2950,1,0,0,0,2979,2956,
        1,0,0,0,2979,2960,1,0,0,0,2979,2964,1,0,0,0,2979,2968,1,0,0,0,2979,
        2972,1,0,0,0,2979,2976,1,0,0,0,2980,265,1,0,0,0,2981,2982,5,243,
        0,0,2982,2989,3,222,111,0,2983,2989,3,28,14,0,2984,2989,3,220,110,
        0,2985,2986,7,38,0,0,2986,2987,5,153,0,0,2987,2989,5,154,0,0,2988,
        2981,1,0,0,0,2988,2983,1,0,0,0,2988,2984,1,0,0,0,2988,2985,1,0,0,
        0,2989,267,1,0,0,0,2990,2991,7,39,0,0,2991,269,1,0,0,0,2992,2993,
        7,40,0,0,2993,271,1,0,0,0,2994,2995,7,41,0,0,2995,273,1,0,0,0,390,
        278,303,308,316,324,326,346,350,356,359,362,369,374,377,384,396,
        405,407,411,414,421,432,434,442,447,450,456,467,531,540,544,550,
        554,559,565,577,585,591,604,609,625,632,636,642,657,661,667,673,
        676,679,685,689,697,699,708,711,720,725,731,738,741,747,758,761,
        765,770,775,782,785,788,795,800,809,817,823,826,829,835,839,843,
        847,849,857,865,871,877,880,884,887,891,916,919,923,929,932,935,
        941,949,954,960,966,978,981,988,995,1003,1006,1014,1018,1025,1141,
        1149,1157,1166,1176,1180,1183,1189,1195,1207,1219,1224,1233,1241,
        1248,1250,1255,1259,1264,1269,1274,1277,1282,1286,1291,1293,1297,
        1306,1314,1323,1330,1339,1344,1347,1366,1368,1377,1384,1387,1394,
        1398,1404,1412,1423,1434,1441,1447,1460,1467,1474,1486,1494,1500,
        1503,1512,1515,1524,1527,1536,1539,1548,1551,1554,1559,1561,1573,
        1580,1587,1590,1592,1604,1608,1612,1618,1622,1630,1634,1637,1640,
        1643,1647,1651,1654,1658,1663,1667,1670,1673,1676,1678,1690,1693,
        1697,1707,1711,1713,1716,1720,1726,1730,1741,1751,1763,1778,1783,
        1790,1806,1811,1824,1829,1837,1843,1847,1856,1871,1876,1888,1893,
        1901,1904,1908,1922,1935,1940,1944,1947,1952,1961,1964,1969,1976,
        1979,1987,1994,2001,2004,2009,2012,2017,2021,2024,2027,2033,2038,
        2043,2061,2063,2066,2077,2086,2093,2101,2108,2112,2120,2128,2132,
        2140,2152,2155,2161,2165,2167,2176,2188,2190,2197,2204,2210,2216,
        2218,2225,2233,2239,2246,2252,2256,2258,2265,2274,2287,2292,2296,
        2310,2312,2320,2322,2326,2334,2343,2349,2357,2362,2374,2379,2382,
        2388,2392,2397,2402,2407,2413,2434,2436,2445,2449,2458,2462,2480,
        2483,2491,2500,2523,2534,2541,2544,2553,2557,2569,2594,2601,2604,
        2619,2623,2633,2635,2648,2650,2663,2667,2674,2679,2687,2691,2700,
        2705,2722,2726,2735,2739,2741,2748,2755,2758,2761,2768,2775,2778,
        2785,2793,2796,2809,2829,2839,2842,2851,2854,2856,2859,2862,2880,
        2889,2896,2903,2910,2920,2923,2928,2936,2942,2947,2952,2956,2960,
        2964,2968,2972,2976,2979,2988
    ]

class sqlParser ( Parser ):

    grammarFileName = "sql.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "';'", "'('", "')'", "','", "'.'", "'/*+'", 
                     "'*/'", "'->'", "'['", "']'", "':'", "'ADD'", "'AFTER'", 
                     "'ALL'", "'ALTER'", "'ANALYZE'", "'AND'", "'ANTI'", 
                     "'ANY'", "'ARCHIVE'", "'ARRAY'", "'AS'", "'ASC'", "'AT'", 
                     "'AUTHORIZATION'", "'BETWEEN'", "'BOTH'", "'BUCKET'", 
                     "'BUCKETS'", "'BY'", "'CACHE'", "'CASCADE'", "'CASE'", 
                     "'CAST'", "'CHANGE'", "'CHECK'", "'CLEAR'", "'CLUSTER'", 
                     "'CLUSTERED'", "'CODEGEN'", "'COLLATE'", "'COLLECTION'", 
                     "'COLUMN'", "'COLUMNS'", "'COMMENT'", "'COMMIT'", "'COMPACT'", 
                     "'COMPACTIONS'", "'COMPUTE'", "'CONCATENATE'", "'CONSTRAINT'", 
                     "'COST'", "'CREATE'", "'CROSS'", "'CUBE'", "'CURRENT'", 
                     "'CURRENT_DATE'", "'CURRENT_TIME'", "'CURRENT_TIMESTAMP'", 
                     "'CURRENT_USER'", "'DATA'", "'DATABASE'", "<INVALID>", 
                     "'DAY'", "'DBPROPERTIES'", "'DEFINED'", "'DELETE'", 
                     "'DELIMITED'", "'DESC'", "'DESCRIBE'", "'DFS'", "'DIRECTORIES'", 
                     "'DIRECTORY'", "'DISTINCT'", "'DISTRIBUTE'", "'DROP'", 
                     "'ELSE'", "'END'", "'ESCAPE'", "'ESCAPED'", "'EXCEPT'", 
                     "'EXCHANGE'", "'EXISTS'", "'EXPLAIN'", "'EXPORT'", 
                     "'EXTENDED'", "'EXTERNAL'", "'EXTRACT'", "'FALSE'", 
                     "'FETCH'", "'FIELDS'", "'FILTER'", "'FILEFORMAT'", 
                     "'FIRST'", "'FOLLOWING'", "'FOR'", "'FOREIGN'", "'FORMAT'", 
                     "'FORMATTED'", "'FROM'", "'FULL'", "'FUNCTION'", "'FUNCTIONS'", 
                     "'GLOBAL'", "'GRANT'", "'GROUP'", "'GROUPING'", "'HAVING'", 
                     "'HOUR'", "'IF'", "'IGNORE'", "'IMPORT'", "'IN'", "'INDEX'", 
                     "'INDEXES'", "'INNER'", "'INPATH'", "'INPUTFORMAT'", 
                     "'INSERT'", "'INTERSECT'", "'INTERVAL'", "'INTO'", 
                     "'IS'", "'ITEMS'", "'JOIN'", "'KEYS'", "'LAST'", "'LATERAL'", 
                     "'LAZY'", "'LEADING'", "'LEFT'", "'LIKE'", "'LIMIT'", 
                     "'LINES'", "'LIST'", "'LOAD'", "'LOCAL'", "'LOCATION'", 
                     "'LOCK'", "'LOCKS'", "'LOGICAL'", "'MACRO'", "'MAP'", 
                     "'MATCHED'", "'MERGE'", "'MINUTE'", "'MONTH'", "'MSCK'", 
                     "'NAMESPACE'", "'NAMESPACES'", "'NATURAL'", "'NO'", 
                     "<INVALID>", "'NULL'", "'NULLS'", "'OF'", "'ON'", "'ONLY'", 
                     "'OPTION'", "'OPTIONS'", "'OR'", "'ORDER'", "'OUT'", 
                     "'OUTER'", "'OUTPUTFORMAT'", "'OVER'", "'OVERLAPS'", 
                     "'OVERLAY'", "'OVERWRITE'", "'PARTITION'", "'PARTITIONED'", 
                     "'PARTITIONS'", "'PERCENT'", "'PIVOT'", "'PLACING'", 
                     "'POSITION'", "'PRECEDING'", "'PRIMARY'", "'PRINCIPALS'", 
                     "'PROPERTIES'", "'PURGE'", "'QUERY'", "'RANGE'", "'RECORDREADER'", 
                     "'RECORDWRITER'", "'RECOVER'", "'REDUCE'", "'REFERENCES'", 
                     "'REFRESH'", "'RENAME'", "'REPAIR'", "'REPLACE'", "'RESET'", 
                     "'RESTRICT'", "'REVOKE'", "'RIGHT'", "<INVALID>", "'ROLE'", 
                     "'ROLES'", "'ROLLBACK'", "'ROLLUP'", "'ROW'", "'ROWS'", 
                     "'SCHEMA'", "'SECOND'", "'SELECT'", "'SEMI'", "'SEPARATED'", 
                     "'SERDE'", "'SERDEPROPERTIES'", "'SESSION_USER'", "'SET'", 
                     "'MINUS'", "'SETS'", "'SHOW'", "'SKEWED'", "'SOME'", 
                     "'SORT'", "'SORTED'", "'START'", "'STATISTICS'", "'STORED'", 
                     "'STRATIFY'", "'STRUCT'", "'SUBSTR'", "'SUBSTRING'", 
                     "'TABLE'", "'TABLES'", "'TABLESAMPLE'", "'TBLPROPERTIES'", 
                     "<INVALID>", "'TERMINATED'", "'THEN'", "'TO'", "'TOUCH'", 
                     "'TRAILING'", "'TRANSACTION'", "'TRANSACTIONS'", "'TRANSFORM'", 
                     "'TRIM'", "'TRUE'", "'TRUNCATE'", "'TYPE'", "'UNARCHIVE'", 
                     "'UNBOUNDED'", "'UNCACHE'", "'UNION'", "'UNIQUE'", 
                     "'UNKNOWN'", "'UNLOCK'", "'UNSET'", "'UPDATE'", "'USE'", 
                     "'USER'", "'USING'", "'VALUES'", "'VIEW'", "'VIEWS'", 
                     "'WHEN'", "'WHERE'", "'WINDOW'", "'WITH'", "'YEAR'", 
                     "<INVALID>", "'<=>'", "'<>'", "'!='", "'<'", "<INVALID>", 
                     "'>'", "<INVALID>", "'+'", "'-'", "'*'", "'/'", "'%'", 
                     "'DIV'", "'~'", "'&'", "'|'", "'||'", "'^'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "ADD", "AFTER", "ALL", "ALTER", "ANALYZE", "AND", 
                      "ANTI", "ANY", "ARCHIVE", "ARRAY", "AS", "ASC", "AT", 
                      "AUTHORIZATION", "BETWEEN", "BOTH", "BUCKET", "BUCKETS", 
                      "BY", "CACHE", "CASCADE", "CASE", "CAST", "CHANGE", 
                      "CHECK", "CLEAR", "CLUSTER", "CLUSTERED", "CODEGEN", 
                      "COLLATE", "COLLECTION", "COLUMN", "COLUMNS", "COMMENT", 
                      "COMMIT", "COMPACT", "COMPACTIONS", "COMPUTE", "CONCATENATE", 
                      "CONSTRAINT", "COST", "CREATE", "CROSS", "CUBE", "CURRENT", 
                      "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", 
                      "CURRENT_USER", "DATA", "DATABASE", "DATABASES", "DAY", 
                      "DBPROPERTIES", "DEFINED", "DELETE", "DELIMITED", 
                      "DESC", "DESCRIBE", "DFS", "DIRECTORIES", "DIRECTORY", 
                      "DISTINCT", "DISTRIBUTE", "DROP", "ELSE", "END", "ESCAPE", 
                      "ESCAPED", "EXCEPT", "EXCHANGE", "EXISTS", "EXPLAIN", 
                      "EXPORT", "EXTENDED", "EXTERNAL", "EXTRACT", "FALSE", 
                      "FETCH", "FIELDS", "FILTER", "FILEFORMAT", "FIRST", 
                      "FOLLOWING", "FOR", "FOREIGN", "FORMAT", "FORMATTED", 
                      "FROM", "FULL", "FUNCTION", "FUNCTIONS", "GLOBAL", 
                      "GRANT", "GROUP", "GROUPING", "HAVING", "HOUR", "IF", 
                      "IGNORE", "IMPORT", "IN", "INDEX", "INDEXES", "INNER", 
                      "INPATH", "INPUTFORMAT", "INSERT", "INTERSECT", "INTERVAL", 
                      "INTO", "IS", "ITEMS", "JOIN", "KEYS", "LAST", "LATERAL", 
                      "LAZY", "LEADING", "LEFT", "LIKE", "LIMIT", "LINES", 
                      "LIST", "LOAD", "LOCAL", "LOCATION", "LOCK", "LOCKS", 
                      "LOGICAL", "MACRO", "MAP", "MATCHED", "MERGE", "MINUTE", 
                      "MONTH", "MSCK", "NAMESPACE", "NAMESPACES", "NATURAL", 
                      "NO", "NOT", "NULL", "NULLS", "OF", "ON", "ONLY", 
                      "OPTION", "OPTIONS", "OR", "ORDER", "OUT", "OUTER", 
                      "OUTPUTFORMAT", "OVER", "OVERLAPS", "OVERLAY", "OVERWRITE", 
                      "PARTITION", "PARTITIONED", "PARTITIONS", "PERCENTLIT", 
                      "PIVOT", "PLACING", "POSITION", "PRECEDING", "PRIMARY", 
                      "PRINCIPALS", "PROPERTIES", "PURGE", "QUERY", "RANGE", 
                      "RECORDREADER", "RECORDWRITER", "RECOVER", "REDUCE", 
                      "REFERENCES", "REFRESH", "RENAME", "REPAIR", "REPLACE", 
                      "RESET", "RESTRICT", "REVOKE", "RIGHT", "RLIKE", "ROLE", 
                      "ROLES", "ROLLBACK", "ROLLUP", "ROW", "ROWS", "SCHEMA", 
                      "SECOND", "SELECT", "SEMI", "SEPARATED", "SERDE", 
                      "SERDEPROPERTIES", "SESSION_USER", "SET", "SETMINUS", 
                      "SETS", "SHOW", "SKEWED", "SOME", "SORT", "SORTED", 
                      "START", "STATISTICS", "STORED", "STRATIFY", "STRUCT", 
                      "SUBSTR", "SUBSTRING", "TABLE", "TABLES", "TABLESAMPLE", 
                      "TBLPROPERTIES", "TEMPORARY", "TERMINATED", "THEN", 
                      "TO", "TOUCH", "TRAILING", "TRANSACTION", "TRANSACTIONS", 
                      "TRANSFORM", "TRIM", "TRUE", "TRUNCATE", "TYPE", "UNARCHIVE", 
                      "UNBOUNDED", "UNCACHE", "UNION", "UNIQUE", "UNKNOWN", 
                      "UNLOCK", "UNSET", "UPDATE", "USE", "USER", "USING", 
                      "VALUES", "VIEW", "VIEWS", "WHEN", "WHERE", "WINDOW", 
                      "WITH", "YEAR", "EQ", "NSEQ", "NEQ", "NEQJ", "LT", 
                      "LTE", "GT", "GTE", "PLUS", "MINUS", "ASTERISK", "SLASH", 
                      "PERCENT", "DIV", "TILDE", "AMPERSAND", "PIPE", "CONCAT_PIPE", 
                      "HAT", "STRING", "BIGINT_LITERAL", "SMALLINT_LITERAL", 
                      "TINYINT_LITERAL", "INTEGER_VALUE", "EXPONENT_VALUE", 
                      "DECIMAL_VALUE", "DOUBLE_LITERAL", "BIGDECIMAL_LITERAL", 
                      "IDENTIFIER", "BACKQUOTED_IDENTIFIER", "SIMPLE_COMMENT", 
                      "BRACKETED_COMMENT", "WS", "UNRECOGNIZED" ]

    RULE_singleStatement = 0
    RULE_singleExpression = 1
    RULE_singleTableIdentifier = 2
    RULE_singleMultipartIdentifier = 3
    RULE_singleFunctionIdentifier = 4
    RULE_singleDataType = 5
    RULE_singleTableSchema = 6
    RULE_statement = 7
    RULE_unsupportedHiveNativeCommands = 8
    RULE_createTableHeader = 9
    RULE_replaceTableHeader = 10
    RULE_bucketSpec = 11
    RULE_skewSpec = 12
    RULE_locationSpec = 13
    RULE_commentSpec = 14
    RULE_query = 15
    RULE_insertInto = 16
    RULE_partitionSpecLocation = 17
    RULE_partitionSpec = 18
    RULE_partitionVal = 19
    RULE_namespace = 20
    RULE_describeFuncName = 21
    RULE_describeColName = 22
    RULE_ctes = 23
    RULE_namedQuery = 24
    RULE_tableProvider = 25
    RULE_createTableClauses = 26
    RULE_tablePropertyList = 27
    RULE_tableProperty = 28
    RULE_tablePropertyKey = 29
    RULE_tablePropertyValue = 30
    RULE_constantList = 31
    RULE_nestedConstantList = 32
    RULE_createFileFormat = 33
    RULE_fileFormat = 34
    RULE_storageHandler = 35
    RULE_resource = 36
    RULE_dmlStatementNoWith = 37
    RULE_queryOrganization = 38
    RULE_multiInsertQueryBody = 39
    RULE_queryTerm = 40
    RULE_queryPrimary = 41
    RULE_sortItem = 42
    RULE_fromStatement = 43
    RULE_fromStatementBody = 44
    RULE_querySpecification = 45
    RULE_transformClause = 46
    RULE_selectClause = 47
    RULE_setClause = 48
    RULE_matchedClause = 49
    RULE_notMatchedClause = 50
    RULE_matchedAction = 51
    RULE_notMatchedAction = 52
    RULE_assignmentList = 53
    RULE_assignment = 54
    RULE_whereClause = 55
    RULE_havingClause = 56
    RULE_hint = 57
    RULE_hintStatement = 58
    RULE_fromClause = 59
    RULE_aggregationClause = 60
    RULE_groupingSet = 61
    RULE_pivotClause = 62
    RULE_pivotColumn = 63
    RULE_pivotValue = 64
    RULE_lateralView = 65
    RULE_setQuantifier = 66
    RULE_relation = 67
    RULE_joinRelation = 68
    RULE_joinType = 69
    RULE_joinCriteria = 70
    RULE_sample = 71
    RULE_sampleMethod = 72
    RULE_identifierList = 73
    RULE_identifierSeq = 74
    RULE_orderedIdentifierList = 75
    RULE_orderedIdentifier = 76
    RULE_identifierCommentList = 77
    RULE_identifierComment = 78
    RULE_relationPrimary = 79
    RULE_inlineTable = 80
    RULE_functionTable = 81
    RULE_tableAlias = 82
    RULE_rowFormat = 83
    RULE_multipartIdentifierList = 84
    RULE_multipartIdentifier = 85
    RULE_tableIdentifier = 86
    RULE_functionIdentifier = 87
    RULE_namedExpression = 88
    RULE_namedExpressionSeq = 89
    RULE_transformList = 90
    RULE_transform = 91
    RULE_transformArgument = 92
    RULE_expression = 93
    RULE_booleanExpression = 94
    RULE_predicate = 95
    RULE_valueExpression = 96
    RULE_primaryExpression = 97
    RULE_constant = 98
    RULE_comparisonOperator = 99
    RULE_arithmeticOperator = 100
    RULE_predicateOperator = 101
    RULE_booleanValue = 102
    RULE_interval = 103
    RULE_errorCapturingMultiUnitsInterval = 104
    RULE_multiUnitsInterval = 105
    RULE_errorCapturingUnitToUnitInterval = 106
    RULE_unitToUnitInterval = 107
    RULE_intervalValue = 108
    RULE_intervalUnit = 109
    RULE_colPosition = 110
    RULE_dataType = 111
    RULE_qualifiedColTypeWithPositionList = 112
    RULE_qualifiedColTypeWithPosition = 113
    RULE_colTypeList = 114
    RULE_colType = 115
    RULE_complexColTypeList = 116
    RULE_complexColType = 117
    RULE_whenClause = 118
    RULE_windowClause = 119
    RULE_namedWindow = 120
    RULE_windowSpec = 121
    RULE_windowFrame = 122
    RULE_frameBound = 123
    RULE_qualifiedNameList = 124
    RULE_functionName = 125
    RULE_qualifiedName = 126
    RULE_errorCapturingIdentifier = 127
    RULE_errorCapturingIdentifierExtra = 128
    RULE_identifier = 129
    RULE_strictIdentifier = 130
    RULE_quotedIdentifier = 131
    RULE_number = 132
    RULE_alterColumnAction = 133
    RULE_ansiNonReserved = 134
    RULE_strictNonReserved = 135
    RULE_nonReserved = 136

    ruleNames =  [ "singleStatement", "singleExpression", "singleTableIdentifier", 
                   "singleMultipartIdentifier", "singleFunctionIdentifier", 
                   "singleDataType", "singleTableSchema", "statement", "unsupportedHiveNativeCommands", 
                   "createTableHeader", "replaceTableHeader", "bucketSpec", 
                   "skewSpec", "locationSpec", "commentSpec", "query", "insertInto", 
                   "partitionSpecLocation", "partitionSpec", "partitionVal", 
                   "namespace", "describeFuncName", "describeColName", "ctes", 
                   "namedQuery", "tableProvider", "createTableClauses", 
                   "tablePropertyList", "tableProperty", "tablePropertyKey", 
                   "tablePropertyValue", "constantList", "nestedConstantList", 
                   "createFileFormat", "fileFormat", "storageHandler", "resource", 
                   "dmlStatementNoWith", "queryOrganization", "multiInsertQueryBody", 
                   "queryTerm", "queryPrimary", "sortItem", "fromStatement", 
                   "fromStatementBody", "querySpecification", "transformClause", 
                   "selectClause", "setClause", "matchedClause", "notMatchedClause", 
                   "matchedAction", "notMatchedAction", "assignmentList", 
                   "assignment", "whereClause", "havingClause", "hint", 
                   "hintStatement", "fromClause", "aggregationClause", "groupingSet", 
                   "pivotClause", "pivotColumn", "pivotValue", "lateralView", 
                   "setQuantifier", "relation", "joinRelation", "joinType", 
                   "joinCriteria", "sample", "sampleMethod", "identifierList", 
                   "identifierSeq", "orderedIdentifierList", "orderedIdentifier", 
                   "identifierCommentList", "identifierComment", "relationPrimary", 
                   "inlineTable", "functionTable", "tableAlias", "rowFormat", 
                   "multipartIdentifierList", "multipartIdentifier", "tableIdentifier", 
                   "functionIdentifier", "namedExpression", "namedExpressionSeq", 
                   "transformList", "transform", "transformArgument", "expression", 
                   "booleanExpression", "predicate", "valueExpression", 
                   "primaryExpression", "constant", "comparisonOperator", 
                   "arithmeticOperator", "predicateOperator", "booleanValue", 
                   "interval", "errorCapturingMultiUnitsInterval", "multiUnitsInterval", 
                   "errorCapturingUnitToUnitInterval", "unitToUnitInterval", 
                   "intervalValue", "intervalUnit", "colPosition", "dataType", 
                   "qualifiedColTypeWithPositionList", "qualifiedColTypeWithPosition", 
                   "colTypeList", "colType", "complexColTypeList", "complexColType", 
                   "whenClause", "windowClause", "namedWindow", "windowSpec", 
                   "windowFrame", "frameBound", "qualifiedNameList", "functionName", 
                   "qualifiedName", "errorCapturingIdentifier", "errorCapturingIdentifierExtra", 
                   "identifier", "strictIdentifier", "quotedIdentifier", 
                   "number", "alterColumnAction", "ansiNonReserved", "strictNonReserved", 
                   "nonReserved" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    ADD=12
    AFTER=13
    ALL=14
    ALTER=15
    ANALYZE=16
    AND=17
    ANTI=18
    ANY=19
    ARCHIVE=20
    ARRAY=21
    AS=22
    ASC=23
    AT=24
    AUTHORIZATION=25
    BETWEEN=26
    BOTH=27
    BUCKET=28
    BUCKETS=29
    BY=30
    CACHE=31
    CASCADE=32
    CASE=33
    CAST=34
    CHANGE=35
    CHECK=36
    CLEAR=37
    CLUSTER=38
    CLUSTERED=39
    CODEGEN=40
    COLLATE=41
    COLLECTION=42
    COLUMN=43
    COLUMNS=44
    COMMENT=45
    COMMIT=46
    COMPACT=47
    COMPACTIONS=48
    COMPUTE=49
    CONCATENATE=50
    CONSTRAINT=51
    COST=52
    CREATE=53
    CROSS=54
    CUBE=55
    CURRENT=56
    CURRENT_DATE=57
    CURRENT_TIME=58
    CURRENT_TIMESTAMP=59
    CURRENT_USER=60
    DATA=61
    DATABASE=62
    DATABASES=63
    DAY=64
    DBPROPERTIES=65
    DEFINED=66
    DELETE=67
    DELIMITED=68
    DESC=69
    DESCRIBE=70
    DFS=71
    DIRECTORIES=72
    DIRECTORY=73
    DISTINCT=74
    DISTRIBUTE=75
    DROP=76
    ELSE=77
    END=78
    ESCAPE=79
    ESCAPED=80
    EXCEPT=81
    EXCHANGE=82
    EXISTS=83
    EXPLAIN=84
    EXPORT=85
    EXTENDED=86
    EXTERNAL=87
    EXTRACT=88
    FALSE=89
    FETCH=90
    FIELDS=91
    FILTER=92
    FILEFORMAT=93
    FIRST=94
    FOLLOWING=95
    FOR=96
    FOREIGN=97
    FORMAT=98
    FORMATTED=99
    FROM=100
    FULL=101
    FUNCTION=102
    FUNCTIONS=103
    GLOBAL=104
    GRANT=105
    GROUP=106
    GROUPING=107
    HAVING=108
    HOUR=109
    IF=110
    IGNORE=111
    IMPORT=112
    IN=113
    INDEX=114
    INDEXES=115
    INNER=116
    INPATH=117
    INPUTFORMAT=118
    INSERT=119
    INTERSECT=120
    INTERVAL=121
    INTO=122
    IS=123
    ITEMS=124
    JOIN=125
    KEYS=126
    LAST=127
    LATERAL=128
    LAZY=129
    LEADING=130
    LEFT=131
    LIKE=132
    LIMIT=133
    LINES=134
    LIST=135
    LOAD=136
    LOCAL=137
    LOCATION=138
    LOCK=139
    LOCKS=140
    LOGICAL=141
    MACRO=142
    MAP=143
    MATCHED=144
    MERGE=145
    MINUTE=146
    MONTH=147
    MSCK=148
    NAMESPACE=149
    NAMESPACES=150
    NATURAL=151
    NO=152
    NOT=153
    NULL=154
    NULLS=155
    OF=156
    ON=157
    ONLY=158
    OPTION=159
    OPTIONS=160
    OR=161
    ORDER=162
    OUT=163
    OUTER=164
    OUTPUTFORMAT=165
    OVER=166
    OVERLAPS=167
    OVERLAY=168
    OVERWRITE=169
    PARTITION=170
    PARTITIONED=171
    PARTITIONS=172
    PERCENTLIT=173
    PIVOT=174
    PLACING=175
    POSITION=176
    PRECEDING=177
    PRIMARY=178
    PRINCIPALS=179
    PROPERTIES=180
    PURGE=181
    QUERY=182
    RANGE=183
    RECORDREADER=184
    RECORDWRITER=185
    RECOVER=186
    REDUCE=187
    REFERENCES=188
    REFRESH=189
    RENAME=190
    REPAIR=191
    REPLACE=192
    RESET=193
    RESTRICT=194
    REVOKE=195
    RIGHT=196
    RLIKE=197
    ROLE=198
    ROLES=199
    ROLLBACK=200
    ROLLUP=201
    ROW=202
    ROWS=203
    SCHEMA=204
    SECOND=205
    SELECT=206
    SEMI=207
    SEPARATED=208
    SERDE=209
    SERDEPROPERTIES=210
    SESSION_USER=211
    SET=212
    SETMINUS=213
    SETS=214
    SHOW=215
    SKEWED=216
    SOME=217
    SORT=218
    SORTED=219
    START=220
    STATISTICS=221
    STORED=222
    STRATIFY=223
    STRUCT=224
    SUBSTR=225
    SUBSTRING=226
    TABLE=227
    TABLES=228
    TABLESAMPLE=229
    TBLPROPERTIES=230
    TEMPORARY=231
    TERMINATED=232
    THEN=233
    TO=234
    TOUCH=235
    TRAILING=236
    TRANSACTION=237
    TRANSACTIONS=238
    TRANSFORM=239
    TRIM=240
    TRUE=241
    TRUNCATE=242
    TYPE=243
    UNARCHIVE=244
    UNBOUNDED=245
    UNCACHE=246
    UNION=247
    UNIQUE=248
    UNKNOWN=249
    UNLOCK=250
    UNSET=251
    UPDATE=252
    USE=253
    USER=254
    USING=255
    VALUES=256
    VIEW=257
    VIEWS=258
    WHEN=259
    WHERE=260
    WINDOW=261
    WITH=262
    YEAR=263
    EQ=264
    NSEQ=265
    NEQ=266
    NEQJ=267
    LT=268
    LTE=269
    GT=270
    GTE=271
    PLUS=272
    MINUS=273
    ASTERISK=274
    SLASH=275
    PERCENT=276
    DIV=277
    TILDE=278
    AMPERSAND=279
    PIPE=280
    CONCAT_PIPE=281
    HAT=282
    STRING=283
    BIGINT_LITERAL=284
    SMALLINT_LITERAL=285
    TINYINT_LITERAL=286
    INTEGER_VALUE=287
    EXPONENT_VALUE=288
    DECIMAL_VALUE=289
    DOUBLE_LITERAL=290
    BIGDECIMAL_LITERAL=291
    IDENTIFIER=292
    BACKQUOTED_IDENTIFIER=293
    SIMPLE_COMMENT=294
    BRACKETED_COMMENT=295
    WS=296
    UNRECOGNIZED=297

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.10.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    # When false, INTERSECT is given the greater precedence over the other set
    # operations (UNION, EXCEPT and MINUS) as per the SQL standard.
    @property
    def legacy_setops_precedence_enbled(self):
        return False

    # When false, a literal with an exponent would be converted into
    # double type rather than decimal type.
    @property
    def legacy_exponent_literal_as_decimal_enabled(self):
        return False

    # Verify whether current token is a valid decimal token (which contains dot).
    # Returns true if the character that follows the token is not a digit or letter or underscore.

    #  For example:
    # For char stream "2.3", "2." is not a valid decimal token, because it is followed by digit '3'.
    # For char stream "2.3_", "2.3" is not a valid decimal token, because it is followed by '_'.
    # For char stream "2.3W", "2.3" is not a valid decimal token, because it is followed by 'W'.
    # For char stream "12.0D 34.E2+0.12 "  12.0D is a valid decimal token because it is followed
    # by a space. 34.E2 is a valid decimal token because it is followed by symbol '+'
    # which is not a digit or letter or underscore.
    @property
    def isValidDecimal(self):
        return True  # TODO: remove this
        nextChar = self._input.LA(1);
        if (nextChar >= 'A' and nextChar <= 'Z') or (nextChar >= '0' and nextChar <= '9') or nextChar == '_':
            return False
        else:
            return True

    # When true, the behavior of keywords follows ANSI SQL standard.
    @property
    def SQL_standard_keyword_behavior(self):
        if "_ansi_sql" in self.__dict__:
            return self._ansi_sql
        return False

    # This method will be called when we see '/ *' and try to match it as a bracketed comment.
    # If the next character is '+', it should be parsed as hint later, and we cannot match
    # it as a bracketed comment.

    # Returns true if the next character is '+'.
    def isHint(self):
        return False  # TODO: remove this
        nextChar = self._input.LA(1);
        if nextChar == '+':
            return True
        else:
            return False


    @property
    def allUpperCase(self):
        if "_all_upper_case" in self.__dict__:
            return self._all_upper_case
        return False





    class SingleStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement(self):
            return self.getTypedRuleContext(sqlParser.StatementContext,0)


        def EOF(self):
            return self.getToken(sqlParser.EOF, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_singleStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSingleStatement" ):
                return visitor.visitSingleStatement(self)
            else:
                return visitor.visitChildren(self)




    def singleStatement(self):

        localctx = sqlParser.SingleStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_singleStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 274
            self.statement()
            self.state = 278
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==sqlParser.T__0:
                self.state = 275
                self.match(sqlParser.T__0)
                self.state = 280
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 281
            self.match(sqlParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SingleExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def namedExpression(self):
            return self.getTypedRuleContext(sqlParser.NamedExpressionContext,0)


        def EOF(self):
            return self.getToken(sqlParser.EOF, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_singleExpression

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSingleExpression" ):
                return visitor.visitSingleExpression(self)
            else:
                return visitor.visitChildren(self)




    def singleExpression(self):

        localctx = sqlParser.SingleExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_singleExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 283
            self.namedExpression()
            self.state = 284
            self.match(sqlParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SingleTableIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tableIdentifier(self):
            return self.getTypedRuleContext(sqlParser.TableIdentifierContext,0)


        def EOF(self):
            return self.getToken(sqlParser.EOF, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_singleTableIdentifier

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSingleTableIdentifier" ):
                return visitor.visitSingleTableIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def singleTableIdentifier(self):

        localctx = sqlParser.SingleTableIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_singleTableIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 286
            self.tableIdentifier()
            self.state = 287
            self.match(sqlParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SingleMultipartIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)


        def EOF(self):
            return self.getToken(sqlParser.EOF, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_singleMultipartIdentifier

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSingleMultipartIdentifier" ):
                return visitor.visitSingleMultipartIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def singleMultipartIdentifier(self):

        localctx = sqlParser.SingleMultipartIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_singleMultipartIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 289
            self.multipartIdentifier()
            self.state = 290
            self.match(sqlParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SingleFunctionIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def functionIdentifier(self):
            return self.getTypedRuleContext(sqlParser.FunctionIdentifierContext,0)


        def EOF(self):
            return self.getToken(sqlParser.EOF, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_singleFunctionIdentifier

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSingleFunctionIdentifier" ):
                return visitor.visitSingleFunctionIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def singleFunctionIdentifier(self):

        localctx = sqlParser.SingleFunctionIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_singleFunctionIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 292
            self.functionIdentifier()
            self.state = 293
            self.match(sqlParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SingleDataTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def dataType(self):
            return self.getTypedRuleContext(sqlParser.DataTypeContext,0)


        def EOF(self):
            return self.getToken(sqlParser.EOF, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_singleDataType

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSingleDataType" ):
                return visitor.visitSingleDataType(self)
            else:
                return visitor.visitChildren(self)




    def singleDataType(self):

        localctx = sqlParser.SingleDataTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_singleDataType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 295
            self.dataType()
            self.state = 296
            self.match(sqlParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SingleTableSchemaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def colTypeList(self):
            return self.getTypedRuleContext(sqlParser.ColTypeListContext,0)


        def EOF(self):
            return self.getToken(sqlParser.EOF, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_singleTableSchema

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSingleTableSchema" ):
                return visitor.visitSingleTableSchema(self)
            else:
                return visitor.visitChildren(self)




    def singleTableSchema(self):

        localctx = sqlParser.SingleTableSchemaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_singleTableSchema)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 298
            self.colTypeList()
            self.state = 299
            self.match(sqlParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return sqlParser.RULE_statement

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class ExplainContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def EXPLAIN(self):
            return self.getToken(sqlParser.EXPLAIN, 0)
        def statement(self):
            return self.getTypedRuleContext(sqlParser.StatementContext,0)

        def LOGICAL(self):
            return self.getToken(sqlParser.LOGICAL, 0)
        def FORMATTED(self):
            return self.getToken(sqlParser.FORMATTED, 0)
        def EXTENDED(self):
            return self.getToken(sqlParser.EXTENDED, 0)
        def CODEGEN(self):
            return self.getToken(sqlParser.CODEGEN, 0)
        def COST(self):
            return self.getToken(sqlParser.COST, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExplain" ):
                return visitor.visitExplain(self)
            else:
                return visitor.visitChildren(self)


    class ResetConfigurationContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def RESET(self):
            return self.getToken(sqlParser.RESET, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitResetConfiguration" ):
                return visitor.visitResetConfiguration(self)
            else:
                return visitor.visitChildren(self)


    class AlterViewQueryContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ALTER(self):
            return self.getToken(sqlParser.ALTER, 0)
        def VIEW(self):
            return self.getToken(sqlParser.VIEW, 0)
        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def query(self):
            return self.getTypedRuleContext(sqlParser.QueryContext,0)

        def AS(self):
            return self.getToken(sqlParser.AS, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlterViewQuery" ):
                return visitor.visitAlterViewQuery(self)
            else:
                return visitor.visitChildren(self)


    class UseContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def USE(self):
            return self.getToken(sqlParser.USE, 0)
        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def NAMESPACE(self):
            return self.getToken(sqlParser.NAMESPACE, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUse" ):
                return visitor.visitUse(self)
            else:
                return visitor.visitChildren(self)


    class DropNamespaceContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DROP(self):
            return self.getToken(sqlParser.DROP, 0)
        def namespace(self):
            return self.getTypedRuleContext(sqlParser.NamespaceContext,0)

        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def IF(self):
            return self.getToken(sqlParser.IF, 0)
        def EXISTS(self):
            return self.getToken(sqlParser.EXISTS, 0)
        def RESTRICT(self):
            return self.getToken(sqlParser.RESTRICT, 0)
        def CASCADE(self):
            return self.getToken(sqlParser.CASCADE, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDropNamespace" ):
                return visitor.visitDropNamespace(self)
            else:
                return visitor.visitChildren(self)


    class CreateTempViewUsingContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def CREATE(self):
            return self.getToken(sqlParser.CREATE, 0)
        def TEMPORARY(self):
            return self.getToken(sqlParser.TEMPORARY, 0)
        def VIEW(self):
            return self.getToken(sqlParser.VIEW, 0)
        def tableIdentifier(self):
            return self.getTypedRuleContext(sqlParser.TableIdentifierContext,0)

        def tableProvider(self):
            return self.getTypedRuleContext(sqlParser.TableProviderContext,0)

        def OR(self):
            return self.getToken(sqlParser.OR, 0)
        def REPLACE(self):
            return self.getToken(sqlParser.REPLACE, 0)
        def GLOBAL(self):
            return self.getToken(sqlParser.GLOBAL, 0)
        def colTypeList(self):
            return self.getTypedRuleContext(sqlParser.ColTypeListContext,0)

        def OPTIONS(self):
            return self.getToken(sqlParser.OPTIONS, 0)
        def tablePropertyList(self):
            return self.getTypedRuleContext(sqlParser.TablePropertyListContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateTempViewUsing" ):
                return visitor.visitCreateTempViewUsing(self)
            else:
                return visitor.visitChildren(self)


    class RenameTableContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.qpdfrom = None # MultipartIdentifierContext
            self.to = None # MultipartIdentifierContext
            self.copyFrom(ctx)

        def ALTER(self):
            return self.getToken(sqlParser.ALTER, 0)
        def RENAME(self):
            return self.getToken(sqlParser.RENAME, 0)
        def TO(self):
            return self.getToken(sqlParser.TO, 0)
        def TABLE(self):
            return self.getToken(sqlParser.TABLE, 0)
        def VIEW(self):
            return self.getToken(sqlParser.VIEW, 0)
        def multipartIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.MultipartIdentifierContext)
            else:
                return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRenameTable" ):
                return visitor.visitRenameTable(self)
            else:
                return visitor.visitChildren(self)


    class FailNativeCommandContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SET(self):
            return self.getToken(sqlParser.SET, 0)
        def ROLE(self):
            return self.getToken(sqlParser.ROLE, 0)
        def unsupportedHiveNativeCommands(self):
            return self.getTypedRuleContext(sqlParser.UnsupportedHiveNativeCommandsContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFailNativeCommand" ):
                return visitor.visitFailNativeCommand(self)
            else:
                return visitor.visitChildren(self)


    class ClearCacheContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def CLEAR(self):
            return self.getToken(sqlParser.CLEAR, 0)
        def CACHE(self):
            return self.getToken(sqlParser.CACHE, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitClearCache" ):
                return visitor.visitClearCache(self)
            else:
                return visitor.visitChildren(self)


    class DropViewContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DROP(self):
            return self.getToken(sqlParser.DROP, 0)
        def VIEW(self):
            return self.getToken(sqlParser.VIEW, 0)
        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def IF(self):
            return self.getToken(sqlParser.IF, 0)
        def EXISTS(self):
            return self.getToken(sqlParser.EXISTS, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDropView" ):
                return visitor.visitDropView(self)
            else:
                return visitor.visitChildren(self)


    class ShowTablesContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.pattern = None # Token
            self.copyFrom(ctx)

        def SHOW(self):
            return self.getToken(sqlParser.SHOW, 0)
        def TABLES(self):
            return self.getToken(sqlParser.TABLES, 0)
        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def FROM(self):
            return self.getToken(sqlParser.FROM, 0)
        def IN(self):
            return self.getToken(sqlParser.IN, 0)
        def STRING(self):
            return self.getToken(sqlParser.STRING, 0)
        def LIKE(self):
            return self.getToken(sqlParser.LIKE, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowTables" ):
                return visitor.visitShowTables(self)
            else:
                return visitor.visitChildren(self)


    class RecoverPartitionsContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ALTER(self):
            return self.getToken(sqlParser.ALTER, 0)
        def TABLE(self):
            return self.getToken(sqlParser.TABLE, 0)
        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def RECOVER(self):
            return self.getToken(sqlParser.RECOVER, 0)
        def PARTITIONS(self):
            return self.getToken(sqlParser.PARTITIONS, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRecoverPartitions" ):
                return visitor.visitRecoverPartitions(self)
            else:
                return visitor.visitChildren(self)


    class ShowCurrentNamespaceContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SHOW(self):
            return self.getToken(sqlParser.SHOW, 0)
        def CURRENT(self):
            return self.getToken(sqlParser.CURRENT, 0)
        def NAMESPACE(self):
            return self.getToken(sqlParser.NAMESPACE, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowCurrentNamespace" ):
                return visitor.visitShowCurrentNamespace(self)
            else:
                return visitor.visitChildren(self)


    class RenameTablePartitionContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.qpdfrom = None # PartitionSpecContext
            self.to = None # PartitionSpecContext
            self.copyFrom(ctx)

        def ALTER(self):
            return self.getToken(sqlParser.ALTER, 0)
        def TABLE(self):
            return self.getToken(sqlParser.TABLE, 0)
        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def RENAME(self):
            return self.getToken(sqlParser.RENAME, 0)
        def TO(self):
            return self.getToken(sqlParser.TO, 0)
        def partitionSpec(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.PartitionSpecContext)
            else:
                return self.getTypedRuleContext(sqlParser.PartitionSpecContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRenameTablePartition" ):
                return visitor.visitRenameTablePartition(self)
            else:
                return visitor.visitChildren(self)


    class RepairTableContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def MSCK(self):
            return self.getToken(sqlParser.MSCK, 0)
        def REPAIR(self):
            return self.getToken(sqlParser.REPAIR, 0)
        def TABLE(self):
            return self.getToken(sqlParser.TABLE, 0)
        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRepairTable" ):
                return visitor.visitRepairTable(self)
            else:
                return visitor.visitChildren(self)


    class RefreshResourceContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def REFRESH(self):
            return self.getToken(sqlParser.REFRESH, 0)
        def STRING(self):
            return self.getToken(sqlParser.STRING, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRefreshResource" ):
                return visitor.visitRefreshResource(self)
            else:
                return visitor.visitChildren(self)


    class ShowCreateTableContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SHOW(self):
            return self.getToken(sqlParser.SHOW, 0)
        def CREATE(self):
            return self.getToken(sqlParser.CREATE, 0)
        def TABLE(self):
            return self.getToken(sqlParser.TABLE, 0)
        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def AS(self):
            return self.getToken(sqlParser.AS, 0)
        def SERDE(self):
            return self.getToken(sqlParser.SERDE, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowCreateTable" ):
                return visitor.visitShowCreateTable(self)
            else:
                return visitor.visitChildren(self)


    class ShowNamespacesContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.pattern = None # Token
            self.copyFrom(ctx)

        def SHOW(self):
            return self.getToken(sqlParser.SHOW, 0)
        def DATABASES(self):
            return self.getToken(sqlParser.DATABASES, 0)
        def NAMESPACES(self):
            return self.getToken(sqlParser.NAMESPACES, 0)
        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def FROM(self):
            return self.getToken(sqlParser.FROM, 0)
        def IN(self):
            return self.getToken(sqlParser.IN, 0)
        def STRING(self):
            return self.getToken(sqlParser.STRING, 0)
        def LIKE(self):
            return self.getToken(sqlParser.LIKE, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowNamespaces" ):
                return visitor.visitShowNamespaces(self)
            else:
                return visitor.visitChildren(self)


    class ShowColumnsContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.table = None # MultipartIdentifierContext
            self.ns = None # MultipartIdentifierContext
            self.copyFrom(ctx)

        def SHOW(self):
            return self.getToken(sqlParser.SHOW, 0)
        def COLUMNS(self):
            return self.getToken(sqlParser.COLUMNS, 0)
        def FROM(self, i:int=None):
            if i is None:
                return self.getTokens(sqlParser.FROM)
            else:
                return self.getToken(sqlParser.FROM, i)
        def IN(self, i:int=None):
            if i is None:
                return self.getTokens(sqlParser.IN)
            else:
                return self.getToken(sqlParser.IN, i)
        def multipartIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.MultipartIdentifierContext)
            else:
                return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowColumns" ):
                return visitor.visitShowColumns(self)
            else:
                return visitor.visitChildren(self)


    class ReplaceTableContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def replaceTableHeader(self):
            return self.getTypedRuleContext(sqlParser.ReplaceTableHeaderContext,0)

        def tableProvider(self):
            return self.getTypedRuleContext(sqlParser.TableProviderContext,0)

        def createTableClauses(self):
            return self.getTypedRuleContext(sqlParser.CreateTableClausesContext,0)

        def colTypeList(self):
            return self.getTypedRuleContext(sqlParser.ColTypeListContext,0)

        def query(self):
            return self.getTypedRuleContext(sqlParser.QueryContext,0)

        def AS(self):
            return self.getToken(sqlParser.AS, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReplaceTable" ):
                return visitor.visitReplaceTable(self)
            else:
                return visitor.visitChildren(self)


    class AddTablePartitionContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ALTER(self):
            return self.getToken(sqlParser.ALTER, 0)
        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def ADD(self):
            return self.getToken(sqlParser.ADD, 0)
        def TABLE(self):
            return self.getToken(sqlParser.TABLE, 0)
        def VIEW(self):
            return self.getToken(sqlParser.VIEW, 0)
        def IF(self):
            return self.getToken(sqlParser.IF, 0)
        def NOT(self):
            return self.getToken(sqlParser.NOT, 0)
        def EXISTS(self):
            return self.getToken(sqlParser.EXISTS, 0)
        def partitionSpecLocation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.PartitionSpecLocationContext)
            else:
                return self.getTypedRuleContext(sqlParser.PartitionSpecLocationContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAddTablePartition" ):
                return visitor.visitAddTablePartition(self)
            else:
                return visitor.visitChildren(self)


    class SetNamespaceLocationContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ALTER(self):
            return self.getToken(sqlParser.ALTER, 0)
        def namespace(self):
            return self.getTypedRuleContext(sqlParser.NamespaceContext,0)

        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def SET(self):
            return self.getToken(sqlParser.SET, 0)
        def locationSpec(self):
            return self.getTypedRuleContext(sqlParser.LocationSpecContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSetNamespaceLocation" ):
                return visitor.visitSetNamespaceLocation(self)
            else:
                return visitor.visitChildren(self)


    class RefreshTableContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def REFRESH(self):
            return self.getToken(sqlParser.REFRESH, 0)
        def TABLE(self):
            return self.getToken(sqlParser.TABLE, 0)
        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRefreshTable" ):
                return visitor.visitRefreshTable(self)
            else:
                return visitor.visitChildren(self)


    class SetNamespacePropertiesContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ALTER(self):
            return self.getToken(sqlParser.ALTER, 0)
        def namespace(self):
            return self.getTypedRuleContext(sqlParser.NamespaceContext,0)

        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def SET(self):
            return self.getToken(sqlParser.SET, 0)
        def tablePropertyList(self):
            return self.getTypedRuleContext(sqlParser.TablePropertyListContext,0)

        def DBPROPERTIES(self):
            return self.getToken(sqlParser.DBPROPERTIES, 0)
        def PROPERTIES(self):
            return self.getToken(sqlParser.PROPERTIES, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSetNamespaceProperties" ):
                return visitor.visitSetNamespaceProperties(self)
            else:
                return visitor.visitChildren(self)


    class ManageResourceContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(sqlParser.IdentifierContext,0)

        def ADD(self):
            return self.getToken(sqlParser.ADD, 0)
        def LIST(self):
            return self.getToken(sqlParser.LIST, 0)
        def STRING(self):
            return self.getToken(sqlParser.STRING, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitManageResource" ):
                return visitor.visitManageResource(self)
            else:
                return visitor.visitChildren(self)


    class AnalyzeContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ANALYZE(self):
            return self.getToken(sqlParser.ANALYZE, 0)
        def TABLE(self):
            return self.getToken(sqlParser.TABLE, 0)
        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def COMPUTE(self):
            return self.getToken(sqlParser.COMPUTE, 0)
        def STATISTICS(self):
            return self.getToken(sqlParser.STATISTICS, 0)
        def partitionSpec(self):
            return self.getTypedRuleContext(sqlParser.PartitionSpecContext,0)

        def identifier(self):
            return self.getTypedRuleContext(sqlParser.IdentifierContext,0)

        def FOR(self):
            return self.getToken(sqlParser.FOR, 0)
        def COLUMNS(self):
            return self.getToken(sqlParser.COLUMNS, 0)
        def identifierSeq(self):
            return self.getTypedRuleContext(sqlParser.IdentifierSeqContext,0)

        def ALL(self):
            return self.getToken(sqlParser.ALL, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAnalyze" ):
                return visitor.visitAnalyze(self)
            else:
                return visitor.visitChildren(self)


    class CreateHiveTableContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.columns = None # ColTypeListContext
            self.partitionColumns = None # ColTypeListContext
            self.partitionColumnNames = None # IdentifierListContext
            self.tableProps = None # TablePropertyListContext
            self.copyFrom(ctx)

        def createTableHeader(self):
            return self.getTypedRuleContext(sqlParser.CreateTableHeaderContext,0)

        def commentSpec(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.CommentSpecContext)
            else:
                return self.getTypedRuleContext(sqlParser.CommentSpecContext,i)

        def bucketSpec(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.BucketSpecContext)
            else:
                return self.getTypedRuleContext(sqlParser.BucketSpecContext,i)

        def skewSpec(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.SkewSpecContext)
            else:
                return self.getTypedRuleContext(sqlParser.SkewSpecContext,i)

        def rowFormat(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.RowFormatContext)
            else:
                return self.getTypedRuleContext(sqlParser.RowFormatContext,i)

        def createFileFormat(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.CreateFileFormatContext)
            else:
                return self.getTypedRuleContext(sqlParser.CreateFileFormatContext,i)

        def locationSpec(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.LocationSpecContext)
            else:
                return self.getTypedRuleContext(sqlParser.LocationSpecContext,i)

        def query(self):
            return self.getTypedRuleContext(sqlParser.QueryContext,0)

        def colTypeList(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.ColTypeListContext)
            else:
                return self.getTypedRuleContext(sqlParser.ColTypeListContext,i)

        def PARTITIONED(self, i:int=None):
            if i is None:
                return self.getTokens(sqlParser.PARTITIONED)
            else:
                return self.getToken(sqlParser.PARTITIONED, i)
        def BY(self, i:int=None):
            if i is None:
                return self.getTokens(sqlParser.BY)
            else:
                return self.getToken(sqlParser.BY, i)
        def TBLPROPERTIES(self, i:int=None):
            if i is None:
                return self.getTokens(sqlParser.TBLPROPERTIES)
            else:
                return self.getToken(sqlParser.TBLPROPERTIES, i)
        def identifierList(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.IdentifierListContext)
            else:
                return self.getTypedRuleContext(sqlParser.IdentifierListContext,i)

        def tablePropertyList(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.TablePropertyListContext)
            else:
                return self.getTypedRuleContext(sqlParser.TablePropertyListContext,i)

        def AS(self):
            return self.getToken(sqlParser.AS, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateHiveTable" ):
                return visitor.visitCreateHiveTable(self)
            else:
                return visitor.visitChildren(self)


    class CreateFunctionContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.className = None # Token
            self.copyFrom(ctx)

        def CREATE(self):
            return self.getToken(sqlParser.CREATE, 0)
        def FUNCTION(self):
            return self.getToken(sqlParser.FUNCTION, 0)
        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def AS(self):
            return self.getToken(sqlParser.AS, 0)
        def STRING(self):
            return self.getToken(sqlParser.STRING, 0)
        def OR(self):
            return self.getToken(sqlParser.OR, 0)
        def REPLACE(self):
            return self.getToken(sqlParser.REPLACE, 0)
        def TEMPORARY(self):
            return self.getToken(sqlParser.TEMPORARY, 0)
        def IF(self):
            return self.getToken(sqlParser.IF, 0)
        def NOT(self):
            return self.getToken(sqlParser.NOT, 0)
        def EXISTS(self):
            return self.getToken(sqlParser.EXISTS, 0)
        def USING(self):
            return self.getToken(sqlParser.USING, 0)
        def resource(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.ResourceContext)
            else:
                return self.getTypedRuleContext(sqlParser.ResourceContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateFunction" ):
                return visitor.visitCreateFunction(self)
            else:
                return visitor.visitChildren(self)


    class ShowTableContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.ns = None # MultipartIdentifierContext
            self.pattern = None # Token
            self.copyFrom(ctx)

        def SHOW(self):
            return self.getToken(sqlParser.SHOW, 0)
        def TABLE(self):
            return self.getToken(sqlParser.TABLE, 0)
        def EXTENDED(self):
            return self.getToken(sqlParser.EXTENDED, 0)
        def LIKE(self):
            return self.getToken(sqlParser.LIKE, 0)
        def STRING(self):
            return self.getToken(sqlParser.STRING, 0)
        def partitionSpec(self):
            return self.getTypedRuleContext(sqlParser.PartitionSpecContext,0)

        def FROM(self):
            return self.getToken(sqlParser.FROM, 0)
        def IN(self):
            return self.getToken(sqlParser.IN, 0)
        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowTable" ):
                return visitor.visitShowTable(self)
            else:
                return visitor.visitChildren(self)


    class HiveReplaceColumnsContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.table = None # MultipartIdentifierContext
            self.columns = None # QualifiedColTypeWithPositionListContext
            self.copyFrom(ctx)

        def ALTER(self):
            return self.getToken(sqlParser.ALTER, 0)
        def TABLE(self):
            return self.getToken(sqlParser.TABLE, 0)
        def REPLACE(self):
            return self.getToken(sqlParser.REPLACE, 0)
        def COLUMNS(self):
            return self.getToken(sqlParser.COLUMNS, 0)
        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def qualifiedColTypeWithPositionList(self):
            return self.getTypedRuleContext(sqlParser.QualifiedColTypeWithPositionListContext,0)

        def partitionSpec(self):
            return self.getTypedRuleContext(sqlParser.PartitionSpecContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHiveReplaceColumns" ):
                return visitor.visitHiveReplaceColumns(self)
            else:
                return visitor.visitChildren(self)


    class CommentNamespaceContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.comment = None # Token
            self.copyFrom(ctx)

        def COMMENT(self):
            return self.getToken(sqlParser.COMMENT, 0)
        def ON(self):
            return self.getToken(sqlParser.ON, 0)
        def namespace(self):
            return self.getTypedRuleContext(sqlParser.NamespaceContext,0)

        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def IS(self):
            return self.getToken(sqlParser.IS, 0)
        def STRING(self):
            return self.getToken(sqlParser.STRING, 0)
        def NULL(self):
            return self.getToken(sqlParser.NULL, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCommentNamespace" ):
                return visitor.visitCommentNamespace(self)
            else:
                return visitor.visitChildren(self)


    class CreateTableContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def createTableHeader(self):
            return self.getTypedRuleContext(sqlParser.CreateTableHeaderContext,0)

        def tableProvider(self):
            return self.getTypedRuleContext(sqlParser.TableProviderContext,0)

        def createTableClauses(self):
            return self.getTypedRuleContext(sqlParser.CreateTableClausesContext,0)

        def colTypeList(self):
            return self.getTypedRuleContext(sqlParser.ColTypeListContext,0)

        def query(self):
            return self.getTypedRuleContext(sqlParser.QueryContext,0)

        def AS(self):
            return self.getToken(sqlParser.AS, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateTable" ):
                return visitor.visitCreateTable(self)
            else:
                return visitor.visitChildren(self)


    class DmlStatementContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def dmlStatementNoWith(self):
            return self.getTypedRuleContext(sqlParser.DmlStatementNoWithContext,0)

        def ctes(self):
            return self.getTypedRuleContext(sqlParser.CtesContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDmlStatement" ):
                return visitor.visitDmlStatement(self)
            else:
                return visitor.visitChildren(self)


    class CreateTableLikeContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.target = None # TableIdentifierContext
            self.source = None # TableIdentifierContext
            self.tableProps = None # TablePropertyListContext
            self.copyFrom(ctx)

        def CREATE(self):
            return self.getToken(sqlParser.CREATE, 0)
        def TABLE(self):
            return self.getToken(sqlParser.TABLE, 0)
        def LIKE(self):
            return self.getToken(sqlParser.LIKE, 0)
        def tableIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.TableIdentifierContext)
            else:
                return self.getTypedRuleContext(sqlParser.TableIdentifierContext,i)

        def IF(self):
            return self.getToken(sqlParser.IF, 0)
        def NOT(self):
            return self.getToken(sqlParser.NOT, 0)
        def EXISTS(self):
            return self.getToken(sqlParser.EXISTS, 0)
        def tableProvider(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.TableProviderContext)
            else:
                return self.getTypedRuleContext(sqlParser.TableProviderContext,i)

        def rowFormat(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.RowFormatContext)
            else:
                return self.getTypedRuleContext(sqlParser.RowFormatContext,i)

        def createFileFormat(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.CreateFileFormatContext)
            else:
                return self.getTypedRuleContext(sqlParser.CreateFileFormatContext,i)

        def locationSpec(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.LocationSpecContext)
            else:
                return self.getTypedRuleContext(sqlParser.LocationSpecContext,i)

        def TBLPROPERTIES(self, i:int=None):
            if i is None:
                return self.getTokens(sqlParser.TBLPROPERTIES)
            else:
                return self.getToken(sqlParser.TBLPROPERTIES, i)
        def tablePropertyList(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.TablePropertyListContext)
            else:
                return self.getTypedRuleContext(sqlParser.TablePropertyListContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateTableLike" ):
                return visitor.visitCreateTableLike(self)
            else:
                return visitor.visitChildren(self)


    class UncacheTableContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def UNCACHE(self):
            return self.getToken(sqlParser.UNCACHE, 0)
        def TABLE(self):
            return self.getToken(sqlParser.TABLE, 0)
        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def IF(self):
            return self.getToken(sqlParser.IF, 0)
        def EXISTS(self):
            return self.getToken(sqlParser.EXISTS, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUncacheTable" ):
                return visitor.visitUncacheTable(self)
            else:
                return visitor.visitChildren(self)


    class DropFunctionContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DROP(self):
            return self.getToken(sqlParser.DROP, 0)
        def FUNCTION(self):
            return self.getToken(sqlParser.FUNCTION, 0)
        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def TEMPORARY(self):
            return self.getToken(sqlParser.TEMPORARY, 0)
        def IF(self):
            return self.getToken(sqlParser.IF, 0)
        def EXISTS(self):
            return self.getToken(sqlParser.EXISTS, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDropFunction" ):
                return visitor.visitDropFunction(self)
            else:
                return visitor.visitChildren(self)


    class DescribeRelationContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.option = None # Token
            self.copyFrom(ctx)

        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def DESC(self):
            return self.getToken(sqlParser.DESC, 0)
        def DESCRIBE(self):
            return self.getToken(sqlParser.DESCRIBE, 0)
        def TABLE(self):
            return self.getToken(sqlParser.TABLE, 0)
        def partitionSpec(self):
            return self.getTypedRuleContext(sqlParser.PartitionSpecContext,0)

        def describeColName(self):
            return self.getTypedRuleContext(sqlParser.DescribeColNameContext,0)

        def EXTENDED(self):
            return self.getToken(sqlParser.EXTENDED, 0)
        def FORMATTED(self):
            return self.getToken(sqlParser.FORMATTED, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDescribeRelation" ):
                return visitor.visitDescribeRelation(self)
            else:
                return visitor.visitChildren(self)


    class LoadDataContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.path = None # Token
            self.copyFrom(ctx)

        def LOAD(self):
            return self.getToken(sqlParser.LOAD, 0)
        def DATA(self):
            return self.getToken(sqlParser.DATA, 0)
        def INPATH(self):
            return self.getToken(sqlParser.INPATH, 0)
        def INTO(self):
            return self.getToken(sqlParser.INTO, 0)
        def TABLE(self):
            return self.getToken(sqlParser.TABLE, 0)
        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def STRING(self):
            return self.getToken(sqlParser.STRING, 0)
        def LOCAL(self):
            return self.getToken(sqlParser.LOCAL, 0)
        def OVERWRITE(self):
            return self.getToken(sqlParser.OVERWRITE, 0)
        def partitionSpec(self):
            return self.getTypedRuleContext(sqlParser.PartitionSpecContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoadData" ):
                return visitor.visitLoadData(self)
            else:
                return visitor.visitChildren(self)


    class ShowPartitionsContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SHOW(self):
            return self.getToken(sqlParser.SHOW, 0)
        def PARTITIONS(self):
            return self.getToken(sqlParser.PARTITIONS, 0)
        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def partitionSpec(self):
            return self.getTypedRuleContext(sqlParser.PartitionSpecContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowPartitions" ):
                return visitor.visitShowPartitions(self)
            else:
                return visitor.visitChildren(self)


    class DescribeFunctionContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def FUNCTION(self):
            return self.getToken(sqlParser.FUNCTION, 0)
        def describeFuncName(self):
            return self.getTypedRuleContext(sqlParser.DescribeFuncNameContext,0)

        def DESC(self):
            return self.getToken(sqlParser.DESC, 0)
        def DESCRIBE(self):
            return self.getToken(sqlParser.DESCRIBE, 0)
        def EXTENDED(self):
            return self.getToken(sqlParser.EXTENDED, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDescribeFunction" ):
                return visitor.visitDescribeFunction(self)
            else:
                return visitor.visitChildren(self)


    class RenameTableColumnContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.table = None # MultipartIdentifierContext
            self.qpdfrom = None # MultipartIdentifierContext
            self.to = None # ErrorCapturingIdentifierContext
            self.copyFrom(ctx)

        def ALTER(self):
            return self.getToken(sqlParser.ALTER, 0)
        def TABLE(self):
            return self.getToken(sqlParser.TABLE, 0)
        def RENAME(self):
            return self.getToken(sqlParser.RENAME, 0)
        def COLUMN(self):
            return self.getToken(sqlParser.COLUMN, 0)
        def TO(self):
            return self.getToken(sqlParser.TO, 0)
        def multipartIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.MultipartIdentifierContext)
            else:
                return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,i)

        def errorCapturingIdentifier(self):
            return self.getTypedRuleContext(sqlParser.ErrorCapturingIdentifierContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRenameTableColumn" ):
                return visitor.visitRenameTableColumn(self)
            else:
                return visitor.visitChildren(self)


    class StatementDefaultContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def query(self):
            return self.getTypedRuleContext(sqlParser.QueryContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatementDefault" ):
                return visitor.visitStatementDefault(self)
            else:
                return visitor.visitChildren(self)


    class HiveChangeColumnContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.table = None # MultipartIdentifierContext
            self.colName = None # MultipartIdentifierContext
            self.copyFrom(ctx)

        def ALTER(self):
            return self.getToken(sqlParser.ALTER, 0)
        def TABLE(self):
            return self.getToken(sqlParser.TABLE, 0)
        def CHANGE(self):
            return self.getToken(sqlParser.CHANGE, 0)
        def colType(self):
            return self.getTypedRuleContext(sqlParser.ColTypeContext,0)

        def multipartIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.MultipartIdentifierContext)
            else:
                return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,i)

        def partitionSpec(self):
            return self.getTypedRuleContext(sqlParser.PartitionSpecContext,0)

        def COLUMN(self):
            return self.getToken(sqlParser.COLUMN, 0)
        def colPosition(self):
            return self.getTypedRuleContext(sqlParser.ColPositionContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHiveChangeColumn" ):
                return visitor.visitHiveChangeColumn(self)
            else:
                return visitor.visitChildren(self)


    class DescribeQueryContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def query(self):
            return self.getTypedRuleContext(sqlParser.QueryContext,0)

        def DESC(self):
            return self.getToken(sqlParser.DESC, 0)
        def DESCRIBE(self):
            return self.getToken(sqlParser.DESCRIBE, 0)
        def QUERY(self):
            return self.getToken(sqlParser.QUERY, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDescribeQuery" ):
                return visitor.visitDescribeQuery(self)
            else:
                return visitor.visitChildren(self)


    class TruncateTableContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def TRUNCATE(self):
            return self.getToken(sqlParser.TRUNCATE, 0)
        def TABLE(self):
            return self.getToken(sqlParser.TABLE, 0)
        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def partitionSpec(self):
            return self.getTypedRuleContext(sqlParser.PartitionSpecContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTruncateTable" ):
                return visitor.visitTruncateTable(self)
            else:
                return visitor.visitChildren(self)


    class SetTableSerDeContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ALTER(self):
            return self.getToken(sqlParser.ALTER, 0)
        def TABLE(self):
            return self.getToken(sqlParser.TABLE, 0)
        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def SET(self):
            return self.getToken(sqlParser.SET, 0)
        def SERDE(self):
            return self.getToken(sqlParser.SERDE, 0)
        def STRING(self):
            return self.getToken(sqlParser.STRING, 0)
        def partitionSpec(self):
            return self.getTypedRuleContext(sqlParser.PartitionSpecContext,0)

        def WITH(self):
            return self.getToken(sqlParser.WITH, 0)
        def SERDEPROPERTIES(self):
            return self.getToken(sqlParser.SERDEPROPERTIES, 0)
        def tablePropertyList(self):
            return self.getTypedRuleContext(sqlParser.TablePropertyListContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSetTableSerDe" ):
                return visitor.visitSetTableSerDe(self)
            else:
                return visitor.visitChildren(self)


    class CreateViewContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def CREATE(self):
            return self.getToken(sqlParser.CREATE, 0)
        def VIEW(self):
            return self.getToken(sqlParser.VIEW, 0)
        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def AS(self):
            return self.getToken(sqlParser.AS, 0)
        def query(self):
            return self.getTypedRuleContext(sqlParser.QueryContext,0)

        def OR(self):
            return self.getToken(sqlParser.OR, 0)
        def REPLACE(self):
            return self.getToken(sqlParser.REPLACE, 0)
        def TEMPORARY(self):
            return self.getToken(sqlParser.TEMPORARY, 0)
        def IF(self):
            return self.getToken(sqlParser.IF, 0)
        def NOT(self):
            return self.getToken(sqlParser.NOT, 0)
        def EXISTS(self):
            return self.getToken(sqlParser.EXISTS, 0)
        def identifierCommentList(self):
            return self.getTypedRuleContext(sqlParser.IdentifierCommentListContext,0)

        def commentSpec(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.CommentSpecContext)
            else:
                return self.getTypedRuleContext(sqlParser.CommentSpecContext,i)

        def PARTITIONED(self, i:int=None):
            if i is None:
                return self.getTokens(sqlParser.PARTITIONED)
            else:
                return self.getToken(sqlParser.PARTITIONED, i)
        def ON(self, i:int=None):
            if i is None:
                return self.getTokens(sqlParser.ON)
            else:
                return self.getToken(sqlParser.ON, i)
        def identifierList(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.IdentifierListContext)
            else:
                return self.getTypedRuleContext(sqlParser.IdentifierListContext,i)

        def TBLPROPERTIES(self, i:int=None):
            if i is None:
                return self.getTokens(sqlParser.TBLPROPERTIES)
            else:
                return self.getToken(sqlParser.TBLPROPERTIES, i)
        def tablePropertyList(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.TablePropertyListContext)
            else:
                return self.getTypedRuleContext(sqlParser.TablePropertyListContext,i)

        def GLOBAL(self):
            return self.getToken(sqlParser.GLOBAL, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateView" ):
                return visitor.visitCreateView(self)
            else:
                return visitor.visitChildren(self)


    class DropTablePartitionsContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ALTER(self):
            return self.getToken(sqlParser.ALTER, 0)
        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def DROP(self):
            return self.getToken(sqlParser.DROP, 0)
        def partitionSpec(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.PartitionSpecContext)
            else:
                return self.getTypedRuleContext(sqlParser.PartitionSpecContext,i)

        def TABLE(self):
            return self.getToken(sqlParser.TABLE, 0)
        def VIEW(self):
            return self.getToken(sqlParser.VIEW, 0)
        def IF(self):
            return self.getToken(sqlParser.IF, 0)
        def EXISTS(self):
            return self.getToken(sqlParser.EXISTS, 0)
        def PURGE(self):
            return self.getToken(sqlParser.PURGE, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDropTablePartitions" ):
                return visitor.visitDropTablePartitions(self)
            else:
                return visitor.visitChildren(self)


    class SetConfigurationContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SET(self):
            return self.getToken(sqlParser.SET, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSetConfiguration" ):
                return visitor.visitSetConfiguration(self)
            else:
                return visitor.visitChildren(self)


    class DropTableContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DROP(self):
            return self.getToken(sqlParser.DROP, 0)
        def TABLE(self):
            return self.getToken(sqlParser.TABLE, 0)
        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def IF(self):
            return self.getToken(sqlParser.IF, 0)
        def EXISTS(self):
            return self.getToken(sqlParser.EXISTS, 0)
        def PURGE(self):
            return self.getToken(sqlParser.PURGE, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDropTable" ):
                return visitor.visitDropTable(self)
            else:
                return visitor.visitChildren(self)


    class DescribeNamespaceContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def namespace(self):
            return self.getTypedRuleContext(sqlParser.NamespaceContext,0)

        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def DESC(self):
            return self.getToken(sqlParser.DESC, 0)
        def DESCRIBE(self):
            return self.getToken(sqlParser.DESCRIBE, 0)
        def EXTENDED(self):
            return self.getToken(sqlParser.EXTENDED, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDescribeNamespace" ):
                return visitor.visitDescribeNamespace(self)
            else:
                return visitor.visitChildren(self)


    class AlterTableAlterColumnContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.table = None # MultipartIdentifierContext
            self.column = None # MultipartIdentifierContext
            self.copyFrom(ctx)

        def ALTER(self, i:int=None):
            if i is None:
                return self.getTokens(sqlParser.ALTER)
            else:
                return self.getToken(sqlParser.ALTER, i)
        def TABLE(self):
            return self.getToken(sqlParser.TABLE, 0)
        def multipartIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.MultipartIdentifierContext)
            else:
                return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,i)

        def CHANGE(self):
            return self.getToken(sqlParser.CHANGE, 0)
        def COLUMN(self):
            return self.getToken(sqlParser.COLUMN, 0)
        def alterColumnAction(self):
            return self.getTypedRuleContext(sqlParser.AlterColumnActionContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlterTableAlterColumn" ):
                return visitor.visitAlterTableAlterColumn(self)
            else:
                return visitor.visitChildren(self)


    class CommentTableContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.comment = None # Token
            self.copyFrom(ctx)

        def COMMENT(self):
            return self.getToken(sqlParser.COMMENT, 0)
        def ON(self):
            return self.getToken(sqlParser.ON, 0)
        def TABLE(self):
            return self.getToken(sqlParser.TABLE, 0)
        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def IS(self):
            return self.getToken(sqlParser.IS, 0)
        def STRING(self):
            return self.getToken(sqlParser.STRING, 0)
        def NULL(self):
            return self.getToken(sqlParser.NULL, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCommentTable" ):
                return visitor.visitCommentTable(self)
            else:
                return visitor.visitChildren(self)


    class CreateNamespaceContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def CREATE(self):
            return self.getToken(sqlParser.CREATE, 0)
        def namespace(self):
            return self.getTypedRuleContext(sqlParser.NamespaceContext,0)

        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def IF(self):
            return self.getToken(sqlParser.IF, 0)
        def NOT(self):
            return self.getToken(sqlParser.NOT, 0)
        def EXISTS(self):
            return self.getToken(sqlParser.EXISTS, 0)
        def commentSpec(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.CommentSpecContext)
            else:
                return self.getTypedRuleContext(sqlParser.CommentSpecContext,i)

        def locationSpec(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.LocationSpecContext)
            else:
                return self.getTypedRuleContext(sqlParser.LocationSpecContext,i)

        def WITH(self, i:int=None):
            if i is None:
                return self.getTokens(sqlParser.WITH)
            else:
                return self.getToken(sqlParser.WITH, i)
        def tablePropertyList(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.TablePropertyListContext)
            else:
                return self.getTypedRuleContext(sqlParser.TablePropertyListContext,i)

        def DBPROPERTIES(self, i:int=None):
            if i is None:
                return self.getTokens(sqlParser.DBPROPERTIES)
            else:
                return self.getToken(sqlParser.DBPROPERTIES, i)
        def PROPERTIES(self, i:int=None):
            if i is None:
                return self.getTokens(sqlParser.PROPERTIES)
            else:
                return self.getToken(sqlParser.PROPERTIES, i)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateNamespace" ):
                return visitor.visitCreateNamespace(self)
            else:
                return visitor.visitChildren(self)


    class ShowTblPropertiesContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.table = None # MultipartIdentifierContext
            self.key = None # TablePropertyKeyContext
            self.copyFrom(ctx)

        def SHOW(self):
            return self.getToken(sqlParser.SHOW, 0)
        def TBLPROPERTIES(self):
            return self.getToken(sqlParser.TBLPROPERTIES, 0)
        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def tablePropertyKey(self):
            return self.getTypedRuleContext(sqlParser.TablePropertyKeyContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowTblProperties" ):
                return visitor.visitShowTblProperties(self)
            else:
                return visitor.visitChildren(self)


    class UnsetTablePropertiesContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ALTER(self):
            return self.getToken(sqlParser.ALTER, 0)
        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def UNSET(self):
            return self.getToken(sqlParser.UNSET, 0)
        def TBLPROPERTIES(self):
            return self.getToken(sqlParser.TBLPROPERTIES, 0)
        def tablePropertyList(self):
            return self.getTypedRuleContext(sqlParser.TablePropertyListContext,0)

        def TABLE(self):
            return self.getToken(sqlParser.TABLE, 0)
        def VIEW(self):
            return self.getToken(sqlParser.VIEW, 0)
        def IF(self):
            return self.getToken(sqlParser.IF, 0)
        def EXISTS(self):
            return self.getToken(sqlParser.EXISTS, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnsetTableProperties" ):
                return visitor.visitUnsetTableProperties(self)
            else:
                return visitor.visitChildren(self)


    class SetTableLocationContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ALTER(self):
            return self.getToken(sqlParser.ALTER, 0)
        def TABLE(self):
            return self.getToken(sqlParser.TABLE, 0)
        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def SET(self):
            return self.getToken(sqlParser.SET, 0)
        def locationSpec(self):
            return self.getTypedRuleContext(sqlParser.LocationSpecContext,0)

        def partitionSpec(self):
            return self.getTypedRuleContext(sqlParser.PartitionSpecContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSetTableLocation" ):
                return visitor.visitSetTableLocation(self)
            else:
                return visitor.visitChildren(self)


    class DropTableColumnsContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.columns = None # MultipartIdentifierListContext
            self.copyFrom(ctx)

        def ALTER(self):
            return self.getToken(sqlParser.ALTER, 0)
        def TABLE(self):
            return self.getToken(sqlParser.TABLE, 0)
        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def DROP(self):
            return self.getToken(sqlParser.DROP, 0)
        def COLUMN(self):
            return self.getToken(sqlParser.COLUMN, 0)
        def COLUMNS(self):
            return self.getToken(sqlParser.COLUMNS, 0)
        def multipartIdentifierList(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierListContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDropTableColumns" ):
                return visitor.visitDropTableColumns(self)
            else:
                return visitor.visitChildren(self)


    class ShowViewsContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.pattern = None # Token
            self.copyFrom(ctx)

        def SHOW(self):
            return self.getToken(sqlParser.SHOW, 0)
        def VIEWS(self):
            return self.getToken(sqlParser.VIEWS, 0)
        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def FROM(self):
            return self.getToken(sqlParser.FROM, 0)
        def IN(self):
            return self.getToken(sqlParser.IN, 0)
        def STRING(self):
            return self.getToken(sqlParser.STRING, 0)
        def LIKE(self):
            return self.getToken(sqlParser.LIKE, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowViews" ):
                return visitor.visitShowViews(self)
            else:
                return visitor.visitChildren(self)


    class ShowFunctionsContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.pattern = None # Token
            self.copyFrom(ctx)

        def SHOW(self):
            return self.getToken(sqlParser.SHOW, 0)
        def FUNCTIONS(self):
            return self.getToken(sqlParser.FUNCTIONS, 0)
        def identifier(self):
            return self.getTypedRuleContext(sqlParser.IdentifierContext,0)

        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def LIKE(self):
            return self.getToken(sqlParser.LIKE, 0)
        def STRING(self):
            return self.getToken(sqlParser.STRING, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShowFunctions" ):
                return visitor.visitShowFunctions(self)
            else:
                return visitor.visitChildren(self)


    class CacheTableContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.options = None # TablePropertyListContext
            self.copyFrom(ctx)

        def CACHE(self):
            return self.getToken(sqlParser.CACHE, 0)
        def TABLE(self):
            return self.getToken(sqlParser.TABLE, 0)
        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def LAZY(self):
            return self.getToken(sqlParser.LAZY, 0)
        def OPTIONS(self):
            return self.getToken(sqlParser.OPTIONS, 0)
        def query(self):
            return self.getTypedRuleContext(sqlParser.QueryContext,0)

        def tablePropertyList(self):
            return self.getTypedRuleContext(sqlParser.TablePropertyListContext,0)

        def AS(self):
            return self.getToken(sqlParser.AS, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCacheTable" ):
                return visitor.visitCacheTable(self)
            else:
                return visitor.visitChildren(self)


    class AddTableColumnsContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.columns = None # QualifiedColTypeWithPositionListContext
            self.copyFrom(ctx)

        def ALTER(self):
            return self.getToken(sqlParser.ALTER, 0)
        def TABLE(self):
            return self.getToken(sqlParser.TABLE, 0)
        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def ADD(self):
            return self.getToken(sqlParser.ADD, 0)
        def COLUMN(self):
            return self.getToken(sqlParser.COLUMN, 0)
        def COLUMNS(self):
            return self.getToken(sqlParser.COLUMNS, 0)
        def qualifiedColTypeWithPositionList(self):
            return self.getTypedRuleContext(sqlParser.QualifiedColTypeWithPositionListContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAddTableColumns" ):
                return visitor.visitAddTableColumns(self)
            else:
                return visitor.visitChildren(self)


    class SetTablePropertiesContext(StatementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StatementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ALTER(self):
            return self.getToken(sqlParser.ALTER, 0)
        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def SET(self):
            return self.getToken(sqlParser.SET, 0)
        def TBLPROPERTIES(self):
            return self.getToken(sqlParser.TBLPROPERTIES, 0)
        def tablePropertyList(self):
            return self.getTypedRuleContext(sqlParser.TablePropertyListContext,0)

        def TABLE(self):
            return self.getToken(sqlParser.TABLE, 0)
        def VIEW(self):
            return self.getToken(sqlParser.VIEW, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSetTableProperties" ):
                return visitor.visitSetTableProperties(self)
            else:
                return visitor.visitChildren(self)



    def statement(self):

        localctx = sqlParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_statement)
        self._la = 0 # Token type
        try:
            self.state = 1006
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,106,self._ctx)
            if la_ == 1:
                localctx = sqlParser.StatementDefaultContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 301
                self.query()
                pass

            elif la_ == 2:
                localctx = sqlParser.DmlStatementContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 303
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.WITH:
                    self.state = 302
                    self.ctes()


                self.state = 305
                self.dmlStatementNoWith()
                pass

            elif la_ == 3:
                localctx = sqlParser.UseContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 306
                self.match(sqlParser.USE)
                self.state = 308
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
                if la_ == 1:
                    self.state = 307
                    self.match(sqlParser.NAMESPACE)


                self.state = 310
                self.multipartIdentifier()
                pass

            elif la_ == 4:
                localctx = sqlParser.CreateNamespaceContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 311
                self.match(sqlParser.CREATE)
                self.state = 312
                self.namespace()
                self.state = 316
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
                if la_ == 1:
                    self.state = 313
                    self.match(sqlParser.IF)
                    self.state = 314
                    self.match(sqlParser.NOT)
                    self.state = 315
                    self.match(sqlParser.EXISTS)


                self.state = 318
                self.multipartIdentifier()
                self.state = 326
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==sqlParser.COMMENT or _la==sqlParser.LOCATION or _la==sqlParser.WITH:
                    self.state = 324
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [sqlParser.COMMENT]:
                        self.state = 319
                        self.commentSpec()
                        pass
                    elif token in [sqlParser.LOCATION]:
                        self.state = 320
                        self.locationSpec()
                        pass
                    elif token in [sqlParser.WITH]:
                        self.state = 321
                        self.match(sqlParser.WITH)
                        self.state = 322
                        _la = self._input.LA(1)
                        if not(_la==sqlParser.DBPROPERTIES or _la==sqlParser.PROPERTIES):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 323
                        self.tablePropertyList()
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 328
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass

            elif la_ == 5:
                localctx = sqlParser.SetNamespacePropertiesContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 329
                self.match(sqlParser.ALTER)
                self.state = 330
                self.namespace()
                self.state = 331
                self.multipartIdentifier()
                self.state = 332
                self.match(sqlParser.SET)
                self.state = 333
                _la = self._input.LA(1)
                if not(_la==sqlParser.DBPROPERTIES or _la==sqlParser.PROPERTIES):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 334
                self.tablePropertyList()
                pass

            elif la_ == 6:
                localctx = sqlParser.SetNamespaceLocationContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 336
                self.match(sqlParser.ALTER)
                self.state = 337
                self.namespace()
                self.state = 338
                self.multipartIdentifier()
                self.state = 339
                self.match(sqlParser.SET)
                self.state = 340
                self.locationSpec()
                pass

            elif la_ == 7:
                localctx = sqlParser.DropNamespaceContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 342
                self.match(sqlParser.DROP)
                self.state = 343
                self.namespace()
                self.state = 346
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
                if la_ == 1:
                    self.state = 344
                    self.match(sqlParser.IF)
                    self.state = 345
                    self.match(sqlParser.EXISTS)


                self.state = 348
                self.multipartIdentifier()
                self.state = 350
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.CASCADE or _la==sqlParser.RESTRICT:
                    self.state = 349
                    _la = self._input.LA(1)
                    if not(_la==sqlParser.CASCADE or _la==sqlParser.RESTRICT):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                pass

            elif la_ == 8:
                localctx = sqlParser.ShowNamespacesContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 352
                self.match(sqlParser.SHOW)
                self.state = 353
                _la = self._input.LA(1)
                if not(_la==sqlParser.DATABASES or _la==sqlParser.NAMESPACES):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 356
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.FROM or _la==sqlParser.IN:
                    self.state = 354
                    _la = self._input.LA(1)
                    if not(_la==sqlParser.FROM or _la==sqlParser.IN):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 355
                    self.multipartIdentifier()


                self.state = 362
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.LIKE or _la==sqlParser.STRING:
                    self.state = 359
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==sqlParser.LIKE:
                        self.state = 358
                        self.match(sqlParser.LIKE)


                    self.state = 361
                    localctx.pattern = self.match(sqlParser.STRING)


                pass

            elif la_ == 9:
                localctx = sqlParser.CreateTableContext(self, localctx)
                self.enterOuterAlt(localctx, 9)
                self.state = 364
                self.createTableHeader()
                self.state = 369
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.T__1:
                    self.state = 365
                    self.match(sqlParser.T__1)
                    self.state = 366
                    self.colTypeList()
                    self.state = 367
                    self.match(sqlParser.T__2)


                self.state = 371
                self.tableProvider()
                self.state = 372
                self.createTableClauses()
                self.state = 377
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.T__1 or _la==sqlParser.AS or _la==sqlParser.FROM or _la==sqlParser.MAP or ((((_la - 187)) & ~0x3f) == 0 and ((1 << (_la - 187)) & ((1 << (sqlParser.REDUCE - 187)) | (1 << (sqlParser.SELECT - 187)) | (1 << (sqlParser.TABLE - 187)))) != 0) or _la==sqlParser.VALUES or _la==sqlParser.WITH:
                    self.state = 374
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==sqlParser.AS:
                        self.state = 373
                        self.match(sqlParser.AS)


                    self.state = 376
                    self.query()


                pass

            elif la_ == 10:
                localctx = sqlParser.CreateHiveTableContext(self, localctx)
                self.enterOuterAlt(localctx, 10)
                self.state = 379
                self.createTableHeader()
                self.state = 384
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
                if la_ == 1:
                    self.state = 380
                    self.match(sqlParser.T__1)
                    self.state = 381
                    localctx.columns = self.colTypeList()
                    self.state = 382
                    self.match(sqlParser.T__2)


                self.state = 407
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==sqlParser.CLUSTERED or _la==sqlParser.COMMENT or _la==sqlParser.LOCATION or _la==sqlParser.PARTITIONED or ((((_la - 202)) & ~0x3f) == 0 and ((1 << (_la - 202)) & ((1 << (sqlParser.ROW - 202)) | (1 << (sqlParser.SKEWED - 202)) | (1 << (sqlParser.STORED - 202)) | (1 << (sqlParser.TBLPROPERTIES - 202)))) != 0):
                    self.state = 405
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [sqlParser.COMMENT]:
                        self.state = 386
                        self.commentSpec()
                        pass
                    elif token in [sqlParser.PARTITIONED]:
                        self.state = 396
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
                        if la_ == 1:
                            self.state = 387
                            self.match(sqlParser.PARTITIONED)
                            self.state = 388
                            self.match(sqlParser.BY)
                            self.state = 389
                            self.match(sqlParser.T__1)
                            self.state = 390
                            localctx.partitionColumns = self.colTypeList()
                            self.state = 391
                            self.match(sqlParser.T__2)
                            pass

                        elif la_ == 2:
                            self.state = 393
                            self.match(sqlParser.PARTITIONED)
                            self.state = 394
                            self.match(sqlParser.BY)
                            self.state = 395
                            localctx.partitionColumnNames = self.identifierList()
                            pass


                        pass
                    elif token in [sqlParser.CLUSTERED]:
                        self.state = 398
                        self.bucketSpec()
                        pass
                    elif token in [sqlParser.SKEWED]:
                        self.state = 399
                        self.skewSpec()
                        pass
                    elif token in [sqlParser.ROW]:
                        self.state = 400
                        self.rowFormat()
                        pass
                    elif token in [sqlParser.STORED]:
                        self.state = 401
                        self.createFileFormat()
                        pass
                    elif token in [sqlParser.LOCATION]:
                        self.state = 402
                        self.locationSpec()
                        pass
                    elif token in [sqlParser.TBLPROPERTIES]:
                        self.state = 403
                        self.match(sqlParser.TBLPROPERTIES)
                        self.state = 404
                        localctx.tableProps = self.tablePropertyList()
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 409
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 414
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.T__1 or _la==sqlParser.AS or _la==sqlParser.FROM or _la==sqlParser.MAP or ((((_la - 187)) & ~0x3f) == 0 and ((1 << (_la - 187)) & ((1 << (sqlParser.REDUCE - 187)) | (1 << (sqlParser.SELECT - 187)) | (1 << (sqlParser.TABLE - 187)))) != 0) or _la==sqlParser.VALUES or _la==sqlParser.WITH:
                    self.state = 411
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==sqlParser.AS:
                        self.state = 410
                        self.match(sqlParser.AS)


                    self.state = 413
                    self.query()


                pass

            elif la_ == 11:
                localctx = sqlParser.CreateTableLikeContext(self, localctx)
                self.enterOuterAlt(localctx, 11)
                self.state = 416
                self.match(sqlParser.CREATE)
                self.state = 417
                self.match(sqlParser.TABLE)
                self.state = 421
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,20,self._ctx)
                if la_ == 1:
                    self.state = 418
                    self.match(sqlParser.IF)
                    self.state = 419
                    self.match(sqlParser.NOT)
                    self.state = 420
                    self.match(sqlParser.EXISTS)


                self.state = 423
                localctx.target = self.tableIdentifier()
                self.state = 424
                self.match(sqlParser.LIKE)
                self.state = 425
                localctx.source = self.tableIdentifier()
                self.state = 434
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==sqlParser.LOCATION or ((((_la - 202)) & ~0x3f) == 0 and ((1 << (_la - 202)) & ((1 << (sqlParser.ROW - 202)) | (1 << (sqlParser.STORED - 202)) | (1 << (sqlParser.TBLPROPERTIES - 202)) | (1 << (sqlParser.USING - 202)))) != 0):
                    self.state = 432
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [sqlParser.USING]:
                        self.state = 426
                        self.tableProvider()
                        pass
                    elif token in [sqlParser.ROW]:
                        self.state = 427
                        self.rowFormat()
                        pass
                    elif token in [sqlParser.STORED]:
                        self.state = 428
                        self.createFileFormat()
                        pass
                    elif token in [sqlParser.LOCATION]:
                        self.state = 429
                        self.locationSpec()
                        pass
                    elif token in [sqlParser.TBLPROPERTIES]:
                        self.state = 430
                        self.match(sqlParser.TBLPROPERTIES)
                        self.state = 431
                        localctx.tableProps = self.tablePropertyList()
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 436
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass

            elif la_ == 12:
                localctx = sqlParser.ReplaceTableContext(self, localctx)
                self.enterOuterAlt(localctx, 12)
                self.state = 437
                self.replaceTableHeader()
                self.state = 442
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.T__1:
                    self.state = 438
                    self.match(sqlParser.T__1)
                    self.state = 439
                    self.colTypeList()
                    self.state = 440
                    self.match(sqlParser.T__2)


                self.state = 444
                self.tableProvider()
                self.state = 445
                self.createTableClauses()
                self.state = 450
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.T__1 or _la==sqlParser.AS or _la==sqlParser.FROM or _la==sqlParser.MAP or ((((_la - 187)) & ~0x3f) == 0 and ((1 << (_la - 187)) & ((1 << (sqlParser.REDUCE - 187)) | (1 << (sqlParser.SELECT - 187)) | (1 << (sqlParser.TABLE - 187)))) != 0) or _la==sqlParser.VALUES or _la==sqlParser.WITH:
                    self.state = 447
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==sqlParser.AS:
                        self.state = 446
                        self.match(sqlParser.AS)


                    self.state = 449
                    self.query()


                pass

            elif la_ == 13:
                localctx = sqlParser.AnalyzeContext(self, localctx)
                self.enterOuterAlt(localctx, 13)
                self.state = 452
                self.match(sqlParser.ANALYZE)
                self.state = 453
                self.match(sqlParser.TABLE)
                self.state = 454
                self.multipartIdentifier()
                self.state = 456
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.PARTITION:
                    self.state = 455
                    self.partitionSpec()


                self.state = 458
                self.match(sqlParser.COMPUTE)
                self.state = 459
                self.match(sqlParser.STATISTICS)
                self.state = 467
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,27,self._ctx)
                if la_ == 1:
                    self.state = 460
                    self.identifier()

                elif la_ == 2:
                    self.state = 461
                    self.match(sqlParser.FOR)
                    self.state = 462
                    self.match(sqlParser.COLUMNS)
                    self.state = 463
                    self.identifierSeq()

                elif la_ == 3:
                    self.state = 464
                    self.match(sqlParser.FOR)
                    self.state = 465
                    self.match(sqlParser.ALL)
                    self.state = 466
                    self.match(sqlParser.COLUMNS)


                pass

            elif la_ == 14:
                localctx = sqlParser.AddTableColumnsContext(self, localctx)
                self.enterOuterAlt(localctx, 14)
                self.state = 469
                self.match(sqlParser.ALTER)
                self.state = 470
                self.match(sqlParser.TABLE)
                self.state = 471
                self.multipartIdentifier()
                self.state = 472
                self.match(sqlParser.ADD)
                self.state = 473
                _la = self._input.LA(1)
                if not(_la==sqlParser.COLUMN or _la==sqlParser.COLUMNS):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 474
                localctx.columns = self.qualifiedColTypeWithPositionList()
                pass

            elif la_ == 15:
                localctx = sqlParser.AddTableColumnsContext(self, localctx)
                self.enterOuterAlt(localctx, 15)
                self.state = 476
                self.match(sqlParser.ALTER)
                self.state = 477
                self.match(sqlParser.TABLE)
                self.state = 478
                self.multipartIdentifier()
                self.state = 479
                self.match(sqlParser.ADD)
                self.state = 480
                _la = self._input.LA(1)
                if not(_la==sqlParser.COLUMN or _la==sqlParser.COLUMNS):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 481
                self.match(sqlParser.T__1)
                self.state = 482
                localctx.columns = self.qualifiedColTypeWithPositionList()
                self.state = 483
                self.match(sqlParser.T__2)
                pass

            elif la_ == 16:
                localctx = sqlParser.RenameTableColumnContext(self, localctx)
                self.enterOuterAlt(localctx, 16)
                self.state = 485
                self.match(sqlParser.ALTER)
                self.state = 486
                self.match(sqlParser.TABLE)
                self.state = 487
                localctx.table = self.multipartIdentifier()
                self.state = 488
                self.match(sqlParser.RENAME)
                self.state = 489
                self.match(sqlParser.COLUMN)
                self.state = 490
                localctx.qpdfrom = self.multipartIdentifier()
                self.state = 491
                self.match(sqlParser.TO)
                self.state = 492
                localctx.to = self.errorCapturingIdentifier()
                pass

            elif la_ == 17:
                localctx = sqlParser.DropTableColumnsContext(self, localctx)
                self.enterOuterAlt(localctx, 17)
                self.state = 494
                self.match(sqlParser.ALTER)
                self.state = 495
                self.match(sqlParser.TABLE)
                self.state = 496
                self.multipartIdentifier()
                self.state = 497
                self.match(sqlParser.DROP)
                self.state = 498
                _la = self._input.LA(1)
                if not(_la==sqlParser.COLUMN or _la==sqlParser.COLUMNS):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 499
                self.match(sqlParser.T__1)
                self.state = 500
                localctx.columns = self.multipartIdentifierList()
                self.state = 501
                self.match(sqlParser.T__2)
                pass

            elif la_ == 18:
                localctx = sqlParser.DropTableColumnsContext(self, localctx)
                self.enterOuterAlt(localctx, 18)
                self.state = 503
                self.match(sqlParser.ALTER)
                self.state = 504
                self.match(sqlParser.TABLE)
                self.state = 505
                self.multipartIdentifier()
                self.state = 506
                self.match(sqlParser.DROP)
                self.state = 507
                _la = self._input.LA(1)
                if not(_la==sqlParser.COLUMN or _la==sqlParser.COLUMNS):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 508
                localctx.columns = self.multipartIdentifierList()
                pass

            elif la_ == 19:
                localctx = sqlParser.RenameTableContext(self, localctx)
                self.enterOuterAlt(localctx, 19)
                self.state = 510
                self.match(sqlParser.ALTER)
                self.state = 511
                _la = self._input.LA(1)
                if not(_la==sqlParser.TABLE or _la==sqlParser.VIEW):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 512
                localctx.qpdfrom = self.multipartIdentifier()
                self.state = 513
                self.match(sqlParser.RENAME)
                self.state = 514
                self.match(sqlParser.TO)
                self.state = 515
                localctx.to = self.multipartIdentifier()
                pass

            elif la_ == 20:
                localctx = sqlParser.SetTablePropertiesContext(self, localctx)
                self.enterOuterAlt(localctx, 20)
                self.state = 517
                self.match(sqlParser.ALTER)
                self.state = 518
                _la = self._input.LA(1)
                if not(_la==sqlParser.TABLE or _la==sqlParser.VIEW):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 519
                self.multipartIdentifier()
                self.state = 520
                self.match(sqlParser.SET)
                self.state = 521
                self.match(sqlParser.TBLPROPERTIES)
                self.state = 522
                self.tablePropertyList()
                pass

            elif la_ == 21:
                localctx = sqlParser.UnsetTablePropertiesContext(self, localctx)
                self.enterOuterAlt(localctx, 21)
                self.state = 524
                self.match(sqlParser.ALTER)
                self.state = 525
                _la = self._input.LA(1)
                if not(_la==sqlParser.TABLE or _la==sqlParser.VIEW):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 526
                self.multipartIdentifier()
                self.state = 527
                self.match(sqlParser.UNSET)
                self.state = 528
                self.match(sqlParser.TBLPROPERTIES)
                self.state = 531
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.IF:
                    self.state = 529
                    self.match(sqlParser.IF)
                    self.state = 530
                    self.match(sqlParser.EXISTS)


                self.state = 533
                self.tablePropertyList()
                pass

            elif la_ == 22:
                localctx = sqlParser.AlterTableAlterColumnContext(self, localctx)
                self.enterOuterAlt(localctx, 22)
                self.state = 535
                self.match(sqlParser.ALTER)
                self.state = 536
                self.match(sqlParser.TABLE)
                self.state = 537
                localctx.table = self.multipartIdentifier()
                self.state = 538
                _la = self._input.LA(1)
                if not(_la==sqlParser.ALTER or _la==sqlParser.CHANGE):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 540
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,29,self._ctx)
                if la_ == 1:
                    self.state = 539
                    self.match(sqlParser.COLUMN)


                self.state = 542
                localctx.column = self.multipartIdentifier()
                self.state = 544
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.AFTER or _la==sqlParser.COMMENT or _la==sqlParser.DROP or _la==sqlParser.FIRST or _la==sqlParser.SET or _la==sqlParser.TYPE:
                    self.state = 543
                    self.alterColumnAction()


                pass

            elif la_ == 23:
                localctx = sqlParser.HiveChangeColumnContext(self, localctx)
                self.enterOuterAlt(localctx, 23)
                self.state = 546
                self.match(sqlParser.ALTER)
                self.state = 547
                self.match(sqlParser.TABLE)
                self.state = 548
                localctx.table = self.multipartIdentifier()
                self.state = 550
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.PARTITION:
                    self.state = 549
                    self.partitionSpec()


                self.state = 552
                self.match(sqlParser.CHANGE)
                self.state = 554
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,32,self._ctx)
                if la_ == 1:
                    self.state = 553
                    self.match(sqlParser.COLUMN)


                self.state = 556
                localctx.colName = self.multipartIdentifier()
                self.state = 557
                self.colType()
                self.state = 559
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.AFTER or _la==sqlParser.FIRST:
                    self.state = 558
                    self.colPosition()


                pass

            elif la_ == 24:
                localctx = sqlParser.HiveReplaceColumnsContext(self, localctx)
                self.enterOuterAlt(localctx, 24)
                self.state = 561
                self.match(sqlParser.ALTER)
                self.state = 562
                self.match(sqlParser.TABLE)
                self.state = 563
                localctx.table = self.multipartIdentifier()
                self.state = 565
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.PARTITION:
                    self.state = 564
                    self.partitionSpec()


                self.state = 567
                self.match(sqlParser.REPLACE)
                self.state = 568
                self.match(sqlParser.COLUMNS)
                self.state = 569
                self.match(sqlParser.T__1)
                self.state = 570
                localctx.columns = self.qualifiedColTypeWithPositionList()
                self.state = 571
                self.match(sqlParser.T__2)
                pass

            elif la_ == 25:
                localctx = sqlParser.SetTableSerDeContext(self, localctx)
                self.enterOuterAlt(localctx, 25)
                self.state = 573
                self.match(sqlParser.ALTER)
                self.state = 574
                self.match(sqlParser.TABLE)
                self.state = 575
                self.multipartIdentifier()
                self.state = 577
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.PARTITION:
                    self.state = 576
                    self.partitionSpec()


                self.state = 579
                self.match(sqlParser.SET)
                self.state = 580
                self.match(sqlParser.SERDE)
                self.state = 581
                self.match(sqlParser.STRING)
                self.state = 585
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.WITH:
                    self.state = 582
                    self.match(sqlParser.WITH)
                    self.state = 583
                    self.match(sqlParser.SERDEPROPERTIES)
                    self.state = 584
                    self.tablePropertyList()


                pass

            elif la_ == 26:
                localctx = sqlParser.SetTableSerDeContext(self, localctx)
                self.enterOuterAlt(localctx, 26)
                self.state = 587
                self.match(sqlParser.ALTER)
                self.state = 588
                self.match(sqlParser.TABLE)
                self.state = 589
                self.multipartIdentifier()
                self.state = 591
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.PARTITION:
                    self.state = 590
                    self.partitionSpec()


                self.state = 593
                self.match(sqlParser.SET)
                self.state = 594
                self.match(sqlParser.SERDEPROPERTIES)
                self.state = 595
                self.tablePropertyList()
                pass

            elif la_ == 27:
                localctx = sqlParser.AddTablePartitionContext(self, localctx)
                self.enterOuterAlt(localctx, 27)
                self.state = 597
                self.match(sqlParser.ALTER)
                self.state = 598
                _la = self._input.LA(1)
                if not(_la==sqlParser.TABLE or _la==sqlParser.VIEW):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 599
                self.multipartIdentifier()
                self.state = 600
                self.match(sqlParser.ADD)
                self.state = 604
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.IF:
                    self.state = 601
                    self.match(sqlParser.IF)
                    self.state = 602
                    self.match(sqlParser.NOT)
                    self.state = 603
                    self.match(sqlParser.EXISTS)


                self.state = 607 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 606
                    self.partitionSpecLocation()
                    self.state = 609 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==sqlParser.PARTITION):
                        break

                pass

            elif la_ == 28:
                localctx = sqlParser.RenameTablePartitionContext(self, localctx)
                self.enterOuterAlt(localctx, 28)
                self.state = 611
                self.match(sqlParser.ALTER)
                self.state = 612
                self.match(sqlParser.TABLE)
                self.state = 613
                self.multipartIdentifier()
                self.state = 614
                localctx.qpdfrom = self.partitionSpec()
                self.state = 615
                self.match(sqlParser.RENAME)
                self.state = 616
                self.match(sqlParser.TO)
                self.state = 617
                localctx.to = self.partitionSpec()
                pass

            elif la_ == 29:
                localctx = sqlParser.DropTablePartitionsContext(self, localctx)
                self.enterOuterAlt(localctx, 29)
                self.state = 619
                self.match(sqlParser.ALTER)
                self.state = 620
                _la = self._input.LA(1)
                if not(_la==sqlParser.TABLE or _la==sqlParser.VIEW):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 621
                self.multipartIdentifier()
                self.state = 622
                self.match(sqlParser.DROP)
                self.state = 625
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.IF:
                    self.state = 623
                    self.match(sqlParser.IF)
                    self.state = 624
                    self.match(sqlParser.EXISTS)


                self.state = 627
                self.partitionSpec()
                self.state = 632
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==sqlParser.T__3:
                    self.state = 628
                    self.match(sqlParser.T__3)
                    self.state = 629
                    self.partitionSpec()
                    self.state = 634
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 636
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.PURGE:
                    self.state = 635
                    self.match(sqlParser.PURGE)


                pass

            elif la_ == 30:
                localctx = sqlParser.SetTableLocationContext(self, localctx)
                self.enterOuterAlt(localctx, 30)
                self.state = 638
                self.match(sqlParser.ALTER)
                self.state = 639
                self.match(sqlParser.TABLE)
                self.state = 640
                self.multipartIdentifier()
                self.state = 642
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.PARTITION:
                    self.state = 641
                    self.partitionSpec()


                self.state = 644
                self.match(sqlParser.SET)
                self.state = 645
                self.locationSpec()
                pass

            elif la_ == 31:
                localctx = sqlParser.RecoverPartitionsContext(self, localctx)
                self.enterOuterAlt(localctx, 31)
                self.state = 647
                self.match(sqlParser.ALTER)
                self.state = 648
                self.match(sqlParser.TABLE)
                self.state = 649
                self.multipartIdentifier()
                self.state = 650
                self.match(sqlParser.RECOVER)
                self.state = 651
                self.match(sqlParser.PARTITIONS)
                pass

            elif la_ == 32:
                localctx = sqlParser.DropTableContext(self, localctx)
                self.enterOuterAlt(localctx, 32)
                self.state = 653
                self.match(sqlParser.DROP)
                self.state = 654
                self.match(sqlParser.TABLE)
                self.state = 657
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,44,self._ctx)
                if la_ == 1:
                    self.state = 655
                    self.match(sqlParser.IF)
                    self.state = 656
                    self.match(sqlParser.EXISTS)


                self.state = 659
                self.multipartIdentifier()
                self.state = 661
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.PURGE:
                    self.state = 660
                    self.match(sqlParser.PURGE)


                pass

            elif la_ == 33:
                localctx = sqlParser.DropViewContext(self, localctx)
                self.enterOuterAlt(localctx, 33)
                self.state = 663
                self.match(sqlParser.DROP)
                self.state = 664
                self.match(sqlParser.VIEW)
                self.state = 667
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,46,self._ctx)
                if la_ == 1:
                    self.state = 665
                    self.match(sqlParser.IF)
                    self.state = 666
                    self.match(sqlParser.EXISTS)


                self.state = 669
                self.multipartIdentifier()
                pass

            elif la_ == 34:
                localctx = sqlParser.CreateViewContext(self, localctx)
                self.enterOuterAlt(localctx, 34)
                self.state = 670
                self.match(sqlParser.CREATE)
                self.state = 673
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.OR:
                    self.state = 671
                    self.match(sqlParser.OR)
                    self.state = 672
                    self.match(sqlParser.REPLACE)


                self.state = 679
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.GLOBAL or _la==sqlParser.TEMPORARY:
                    self.state = 676
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==sqlParser.GLOBAL:
                        self.state = 675
                        self.match(sqlParser.GLOBAL)


                    self.state = 678
                    self.match(sqlParser.TEMPORARY)


                self.state = 681
                self.match(sqlParser.VIEW)
                self.state = 685
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,50,self._ctx)
                if la_ == 1:
                    self.state = 682
                    self.match(sqlParser.IF)
                    self.state = 683
                    self.match(sqlParser.NOT)
                    self.state = 684
                    self.match(sqlParser.EXISTS)


                self.state = 687
                self.multipartIdentifier()
                self.state = 689
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.T__1:
                    self.state = 688
                    self.identifierCommentList()


                self.state = 699
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==sqlParser.COMMENT or _la==sqlParser.PARTITIONED or _la==sqlParser.TBLPROPERTIES:
                    self.state = 697
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [sqlParser.COMMENT]:
                        self.state = 691
                        self.commentSpec()
                        pass
                    elif token in [sqlParser.PARTITIONED]:
                        self.state = 692
                        self.match(sqlParser.PARTITIONED)
                        self.state = 693
                        self.match(sqlParser.ON)
                        self.state = 694
                        self.identifierList()
                        pass
                    elif token in [sqlParser.TBLPROPERTIES]:
                        self.state = 695
                        self.match(sqlParser.TBLPROPERTIES)
                        self.state = 696
                        self.tablePropertyList()
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 701
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 702
                self.match(sqlParser.AS)
                self.state = 703
                self.query()
                pass

            elif la_ == 35:
                localctx = sqlParser.CreateTempViewUsingContext(self, localctx)
                self.enterOuterAlt(localctx, 35)
                self.state = 705
                self.match(sqlParser.CREATE)
                self.state = 708
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.OR:
                    self.state = 706
                    self.match(sqlParser.OR)
                    self.state = 707
                    self.match(sqlParser.REPLACE)


                self.state = 711
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.GLOBAL:
                    self.state = 710
                    self.match(sqlParser.GLOBAL)


                self.state = 713
                self.match(sqlParser.TEMPORARY)
                self.state = 714
                self.match(sqlParser.VIEW)
                self.state = 715
                self.tableIdentifier()
                self.state = 720
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.T__1:
                    self.state = 716
                    self.match(sqlParser.T__1)
                    self.state = 717
                    self.colTypeList()
                    self.state = 718
                    self.match(sqlParser.T__2)


                self.state = 722
                self.tableProvider()
                self.state = 725
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.OPTIONS:
                    self.state = 723
                    self.match(sqlParser.OPTIONS)
                    self.state = 724
                    self.tablePropertyList()


                pass

            elif la_ == 36:
                localctx = sqlParser.AlterViewQueryContext(self, localctx)
                self.enterOuterAlt(localctx, 36)
                self.state = 727
                self.match(sqlParser.ALTER)
                self.state = 728
                self.match(sqlParser.VIEW)
                self.state = 729
                self.multipartIdentifier()
                self.state = 731
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.AS:
                    self.state = 730
                    self.match(sqlParser.AS)


                self.state = 733
                self.query()
                pass

            elif la_ == 37:
                localctx = sqlParser.CreateFunctionContext(self, localctx)
                self.enterOuterAlt(localctx, 37)
                self.state = 735
                self.match(sqlParser.CREATE)
                self.state = 738
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.OR:
                    self.state = 736
                    self.match(sqlParser.OR)
                    self.state = 737
                    self.match(sqlParser.REPLACE)


                self.state = 741
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.TEMPORARY:
                    self.state = 740
                    self.match(sqlParser.TEMPORARY)


                self.state = 743
                self.match(sqlParser.FUNCTION)
                self.state = 747
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,61,self._ctx)
                if la_ == 1:
                    self.state = 744
                    self.match(sqlParser.IF)
                    self.state = 745
                    self.match(sqlParser.NOT)
                    self.state = 746
                    self.match(sqlParser.EXISTS)


                self.state = 749
                self.multipartIdentifier()
                self.state = 750
                self.match(sqlParser.AS)
                self.state = 751
                localctx.className = self.match(sqlParser.STRING)
                self.state = 761
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.USING:
                    self.state = 752
                    self.match(sqlParser.USING)
                    self.state = 753
                    self.resource()
                    self.state = 758
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==sqlParser.T__3:
                        self.state = 754
                        self.match(sqlParser.T__3)
                        self.state = 755
                        self.resource()
                        self.state = 760
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)



                pass

            elif la_ == 38:
                localctx = sqlParser.DropFunctionContext(self, localctx)
                self.enterOuterAlt(localctx, 38)
                self.state = 763
                self.match(sqlParser.DROP)
                self.state = 765
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.TEMPORARY:
                    self.state = 764
                    self.match(sqlParser.TEMPORARY)


                self.state = 767
                self.match(sqlParser.FUNCTION)
                self.state = 770
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,65,self._ctx)
                if la_ == 1:
                    self.state = 768
                    self.match(sqlParser.IF)
                    self.state = 769
                    self.match(sqlParser.EXISTS)


                self.state = 772
                self.multipartIdentifier()
                pass

            elif la_ == 39:
                localctx = sqlParser.ExplainContext(self, localctx)
                self.enterOuterAlt(localctx, 39)
                self.state = 773
                self.match(sqlParser.EXPLAIN)
                self.state = 775
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.CODEGEN or _la==sqlParser.COST or ((((_la - 86)) & ~0x3f) == 0 and ((1 << (_la - 86)) & ((1 << (sqlParser.EXTENDED - 86)) | (1 << (sqlParser.FORMATTED - 86)) | (1 << (sqlParser.LOGICAL - 86)))) != 0):
                    self.state = 774
                    _la = self._input.LA(1)
                    if not(_la==sqlParser.CODEGEN or _la==sqlParser.COST or ((((_la - 86)) & ~0x3f) == 0 and ((1 << (_la - 86)) & ((1 << (sqlParser.EXTENDED - 86)) | (1 << (sqlParser.FORMATTED - 86)) | (1 << (sqlParser.LOGICAL - 86)))) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 777
                self.statement()
                pass

            elif la_ == 40:
                localctx = sqlParser.ShowTablesContext(self, localctx)
                self.enterOuterAlt(localctx, 40)
                self.state = 778
                self.match(sqlParser.SHOW)
                self.state = 779
                self.match(sqlParser.TABLES)
                self.state = 782
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.FROM or _la==sqlParser.IN:
                    self.state = 780
                    _la = self._input.LA(1)
                    if not(_la==sqlParser.FROM or _la==sqlParser.IN):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 781
                    self.multipartIdentifier()


                self.state = 788
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.LIKE or _la==sqlParser.STRING:
                    self.state = 785
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==sqlParser.LIKE:
                        self.state = 784
                        self.match(sqlParser.LIKE)


                    self.state = 787
                    localctx.pattern = self.match(sqlParser.STRING)


                pass

            elif la_ == 41:
                localctx = sqlParser.ShowTableContext(self, localctx)
                self.enterOuterAlt(localctx, 41)
                self.state = 790
                self.match(sqlParser.SHOW)
                self.state = 791
                self.match(sqlParser.TABLE)
                self.state = 792
                self.match(sqlParser.EXTENDED)
                self.state = 795
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.FROM or _la==sqlParser.IN:
                    self.state = 793
                    _la = self._input.LA(1)
                    if not(_la==sqlParser.FROM or _la==sqlParser.IN):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 794
                    localctx.ns = self.multipartIdentifier()


                self.state = 797
                self.match(sqlParser.LIKE)
                self.state = 798
                localctx.pattern = self.match(sqlParser.STRING)
                self.state = 800
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.PARTITION:
                    self.state = 799
                    self.partitionSpec()


                pass

            elif la_ == 42:
                localctx = sqlParser.ShowTblPropertiesContext(self, localctx)
                self.enterOuterAlt(localctx, 42)
                self.state = 802
                self.match(sqlParser.SHOW)
                self.state = 803
                self.match(sqlParser.TBLPROPERTIES)
                self.state = 804
                localctx.table = self.multipartIdentifier()
                self.state = 809
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.T__1:
                    self.state = 805
                    self.match(sqlParser.T__1)
                    self.state = 806
                    localctx.key = self.tablePropertyKey()
                    self.state = 807
                    self.match(sqlParser.T__2)


                pass

            elif la_ == 43:
                localctx = sqlParser.ShowColumnsContext(self, localctx)
                self.enterOuterAlt(localctx, 43)
                self.state = 811
                self.match(sqlParser.SHOW)
                self.state = 812
                self.match(sqlParser.COLUMNS)
                self.state = 813
                _la = self._input.LA(1)
                if not(_la==sqlParser.FROM or _la==sqlParser.IN):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 814
                localctx.table = self.multipartIdentifier()
                self.state = 817
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.FROM or _la==sqlParser.IN:
                    self.state = 815
                    _la = self._input.LA(1)
                    if not(_la==sqlParser.FROM or _la==sqlParser.IN):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 816
                    localctx.ns = self.multipartIdentifier()


                pass

            elif la_ == 44:
                localctx = sqlParser.ShowViewsContext(self, localctx)
                self.enterOuterAlt(localctx, 44)
                self.state = 819
                self.match(sqlParser.SHOW)
                self.state = 820
                self.match(sqlParser.VIEWS)
                self.state = 823
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.FROM or _la==sqlParser.IN:
                    self.state = 821
                    _la = self._input.LA(1)
                    if not(_la==sqlParser.FROM or _la==sqlParser.IN):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 822
                    self.multipartIdentifier()


                self.state = 829
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.LIKE or _la==sqlParser.STRING:
                    self.state = 826
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==sqlParser.LIKE:
                        self.state = 825
                        self.match(sqlParser.LIKE)


                    self.state = 828
                    localctx.pattern = self.match(sqlParser.STRING)


                pass

            elif la_ == 45:
                localctx = sqlParser.ShowPartitionsContext(self, localctx)
                self.enterOuterAlt(localctx, 45)
                self.state = 831
                self.match(sqlParser.SHOW)
                self.state = 832
                self.match(sqlParser.PARTITIONS)
                self.state = 833
                self.multipartIdentifier()
                self.state = 835
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.PARTITION:
                    self.state = 834
                    self.partitionSpec()


                pass

            elif la_ == 46:
                localctx = sqlParser.ShowFunctionsContext(self, localctx)
                self.enterOuterAlt(localctx, 46)
                self.state = 837
                self.match(sqlParser.SHOW)
                self.state = 839
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,78,self._ctx)
                if la_ == 1:
                    self.state = 838
                    self.identifier()


                self.state = 841
                self.match(sqlParser.FUNCTIONS)
                self.state = 849
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,81,self._ctx)
                if la_ == 1:
                    self.state = 843
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,79,self._ctx)
                    if la_ == 1:
                        self.state = 842
                        self.match(sqlParser.LIKE)


                    self.state = 847
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,80,self._ctx)
                    if la_ == 1:
                        self.state = 845
                        self.multipartIdentifier()
                        pass

                    elif la_ == 2:
                        self.state = 846
                        localctx.pattern = self.match(sqlParser.STRING)
                        pass




                pass

            elif la_ == 47:
                localctx = sqlParser.ShowCreateTableContext(self, localctx)
                self.enterOuterAlt(localctx, 47)
                self.state = 851
                self.match(sqlParser.SHOW)
                self.state = 852
                self.match(sqlParser.CREATE)
                self.state = 853
                self.match(sqlParser.TABLE)
                self.state = 854
                self.multipartIdentifier()
                self.state = 857
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.AS:
                    self.state = 855
                    self.match(sqlParser.AS)
                    self.state = 856
                    self.match(sqlParser.SERDE)


                pass

            elif la_ == 48:
                localctx = sqlParser.ShowCurrentNamespaceContext(self, localctx)
                self.enterOuterAlt(localctx, 48)
                self.state = 859
                self.match(sqlParser.SHOW)
                self.state = 860
                self.match(sqlParser.CURRENT)
                self.state = 861
                self.match(sqlParser.NAMESPACE)
                pass

            elif la_ == 49:
                localctx = sqlParser.DescribeFunctionContext(self, localctx)
                self.enterOuterAlt(localctx, 49)
                self.state = 862
                _la = self._input.LA(1)
                if not(_la==sqlParser.DESC or _la==sqlParser.DESCRIBE):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 863
                self.match(sqlParser.FUNCTION)
                self.state = 865
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,83,self._ctx)
                if la_ == 1:
                    self.state = 864
                    self.match(sqlParser.EXTENDED)


                self.state = 867
                self.describeFuncName()
                pass

            elif la_ == 50:
                localctx = sqlParser.DescribeNamespaceContext(self, localctx)
                self.enterOuterAlt(localctx, 50)
                self.state = 868
                _la = self._input.LA(1)
                if not(_la==sqlParser.DESC or _la==sqlParser.DESCRIBE):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 869
                self.namespace()
                self.state = 871
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,84,self._ctx)
                if la_ == 1:
                    self.state = 870
                    self.match(sqlParser.EXTENDED)


                self.state = 873
                self.multipartIdentifier()
                pass

            elif la_ == 51:
                localctx = sqlParser.DescribeRelationContext(self, localctx)
                self.enterOuterAlt(localctx, 51)
                self.state = 875
                _la = self._input.LA(1)
                if not(_la==sqlParser.DESC or _la==sqlParser.DESCRIBE):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 877
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,85,self._ctx)
                if la_ == 1:
                    self.state = 876
                    self.match(sqlParser.TABLE)


                self.state = 880
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,86,self._ctx)
                if la_ == 1:
                    self.state = 879
                    localctx.option = self._input.LT(1)
                    _la = self._input.LA(1)
                    if not(_la==sqlParser.EXTENDED or _la==sqlParser.FORMATTED):
                        localctx.option = self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 882
                self.multipartIdentifier()
                self.state = 884
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,87,self._ctx)
                if la_ == 1:
                    self.state = 883
                    self.partitionSpec()


                self.state = 887
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,88,self._ctx)
                if la_ == 1:
                    self.state = 886
                    self.describeColName()


                pass

            elif la_ == 52:
                localctx = sqlParser.DescribeQueryContext(self, localctx)
                self.enterOuterAlt(localctx, 52)
                self.state = 889
                _la = self._input.LA(1)
                if not(_la==sqlParser.DESC or _la==sqlParser.DESCRIBE):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 891
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.QUERY:
                    self.state = 890
                    self.match(sqlParser.QUERY)


                self.state = 893
                self.query()
                pass

            elif la_ == 53:
                localctx = sqlParser.CommentNamespaceContext(self, localctx)
                self.enterOuterAlt(localctx, 53)
                self.state = 894
                self.match(sqlParser.COMMENT)
                self.state = 895
                self.match(sqlParser.ON)
                self.state = 896
                self.namespace()
                self.state = 897
                self.multipartIdentifier()
                self.state = 898
                self.match(sqlParser.IS)
                self.state = 899
                localctx.comment = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==sqlParser.NULL or _la==sqlParser.STRING):
                    localctx.comment = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 54:
                localctx = sqlParser.CommentTableContext(self, localctx)
                self.enterOuterAlt(localctx, 54)
                self.state = 901
                self.match(sqlParser.COMMENT)
                self.state = 902
                self.match(sqlParser.ON)
                self.state = 903
                self.match(sqlParser.TABLE)
                self.state = 904
                self.multipartIdentifier()
                self.state = 905
                self.match(sqlParser.IS)
                self.state = 906
                localctx.comment = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==sqlParser.NULL or _la==sqlParser.STRING):
                    localctx.comment = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 55:
                localctx = sqlParser.RefreshTableContext(self, localctx)
                self.enterOuterAlt(localctx, 55)
                self.state = 908
                self.match(sqlParser.REFRESH)
                self.state = 909
                self.match(sqlParser.TABLE)
                self.state = 910
                self.multipartIdentifier()
                pass

            elif la_ == 56:
                localctx = sqlParser.RefreshResourceContext(self, localctx)
                self.enterOuterAlt(localctx, 56)
                self.state = 911
                self.match(sqlParser.REFRESH)
                self.state = 919
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,91,self._ctx)
                if la_ == 1:
                    self.state = 912
                    self.match(sqlParser.STRING)
                    pass

                elif la_ == 2:
                    self.state = 916
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,90,self._ctx)
                    while _alt!=1 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt==1+1:
                            self.state = 913
                            self.matchWildcard() 
                        self.state = 918
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,90,self._ctx)

                    pass


                pass

            elif la_ == 57:
                localctx = sqlParser.CacheTableContext(self, localctx)
                self.enterOuterAlt(localctx, 57)
                self.state = 921
                self.match(sqlParser.CACHE)
                self.state = 923
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.LAZY:
                    self.state = 922
                    self.match(sqlParser.LAZY)


                self.state = 925
                self.match(sqlParser.TABLE)
                self.state = 926
                self.multipartIdentifier()
                self.state = 929
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.OPTIONS:
                    self.state = 927
                    self.match(sqlParser.OPTIONS)
                    self.state = 928
                    localctx.options = self.tablePropertyList()


                self.state = 935
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.T__1 or _la==sqlParser.AS or _la==sqlParser.FROM or _la==sqlParser.MAP or ((((_la - 187)) & ~0x3f) == 0 and ((1 << (_la - 187)) & ((1 << (sqlParser.REDUCE - 187)) | (1 << (sqlParser.SELECT - 187)) | (1 << (sqlParser.TABLE - 187)))) != 0) or _la==sqlParser.VALUES or _la==sqlParser.WITH:
                    self.state = 932
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==sqlParser.AS:
                        self.state = 931
                        self.match(sqlParser.AS)


                    self.state = 934
                    self.query()


                pass

            elif la_ == 58:
                localctx = sqlParser.UncacheTableContext(self, localctx)
                self.enterOuterAlt(localctx, 58)
                self.state = 937
                self.match(sqlParser.UNCACHE)
                self.state = 938
                self.match(sqlParser.TABLE)
                self.state = 941
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,96,self._ctx)
                if la_ == 1:
                    self.state = 939
                    self.match(sqlParser.IF)
                    self.state = 940
                    self.match(sqlParser.EXISTS)


                self.state = 943
                self.multipartIdentifier()
                pass

            elif la_ == 59:
                localctx = sqlParser.ClearCacheContext(self, localctx)
                self.enterOuterAlt(localctx, 59)
                self.state = 944
                self.match(sqlParser.CLEAR)
                self.state = 945
                self.match(sqlParser.CACHE)
                pass

            elif la_ == 60:
                localctx = sqlParser.LoadDataContext(self, localctx)
                self.enterOuterAlt(localctx, 60)
                self.state = 946
                self.match(sqlParser.LOAD)
                self.state = 947
                self.match(sqlParser.DATA)
                self.state = 949
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.LOCAL:
                    self.state = 948
                    self.match(sqlParser.LOCAL)


                self.state = 951
                self.match(sqlParser.INPATH)
                self.state = 952
                localctx.path = self.match(sqlParser.STRING)
                self.state = 954
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.OVERWRITE:
                    self.state = 953
                    self.match(sqlParser.OVERWRITE)


                self.state = 956
                self.match(sqlParser.INTO)
                self.state = 957
                self.match(sqlParser.TABLE)
                self.state = 958
                self.multipartIdentifier()
                self.state = 960
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.PARTITION:
                    self.state = 959
                    self.partitionSpec()


                pass

            elif la_ == 61:
                localctx = sqlParser.TruncateTableContext(self, localctx)
                self.enterOuterAlt(localctx, 61)
                self.state = 962
                self.match(sqlParser.TRUNCATE)
                self.state = 963
                self.match(sqlParser.TABLE)
                self.state = 964
                self.multipartIdentifier()
                self.state = 966
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.PARTITION:
                    self.state = 965
                    self.partitionSpec()


                pass

            elif la_ == 62:
                localctx = sqlParser.RepairTableContext(self, localctx)
                self.enterOuterAlt(localctx, 62)
                self.state = 968
                self.match(sqlParser.MSCK)
                self.state = 969
                self.match(sqlParser.REPAIR)
                self.state = 970
                self.match(sqlParser.TABLE)
                self.state = 971
                self.multipartIdentifier()
                pass

            elif la_ == 63:
                localctx = sqlParser.ManageResourceContext(self, localctx)
                self.enterOuterAlt(localctx, 63)
                self.state = 972
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==sqlParser.ADD or _la==sqlParser.LIST):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 973
                self.identifier()
                self.state = 981
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,102,self._ctx)
                if la_ == 1:
                    self.state = 974
                    self.match(sqlParser.STRING)
                    pass

                elif la_ == 2:
                    self.state = 978
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,101,self._ctx)
                    while _alt!=1 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt==1+1:
                            self.state = 975
                            self.matchWildcard() 
                        self.state = 980
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,101,self._ctx)

                    pass


                pass

            elif la_ == 64:
                localctx = sqlParser.FailNativeCommandContext(self, localctx)
                self.enterOuterAlt(localctx, 64)
                self.state = 983
                self.match(sqlParser.SET)
                self.state = 984
                self.match(sqlParser.ROLE)
                self.state = 988
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,103,self._ctx)
                while _alt!=1 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1+1:
                        self.state = 985
                        self.matchWildcard() 
                    self.state = 990
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,103,self._ctx)

                pass

            elif la_ == 65:
                localctx = sqlParser.SetConfigurationContext(self, localctx)
                self.enterOuterAlt(localctx, 65)
                self.state = 991
                self.match(sqlParser.SET)
                self.state = 995
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,104,self._ctx)
                while _alt!=1 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1+1:
                        self.state = 992
                        self.matchWildcard() 
                    self.state = 997
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,104,self._ctx)

                pass

            elif la_ == 66:
                localctx = sqlParser.ResetConfigurationContext(self, localctx)
                self.enterOuterAlt(localctx, 66)
                self.state = 998
                self.match(sqlParser.RESET)
                pass

            elif la_ == 67:
                localctx = sqlParser.FailNativeCommandContext(self, localctx)
                self.enterOuterAlt(localctx, 67)
                self.state = 999
                self.unsupportedHiveNativeCommands()
                self.state = 1003
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,105,self._ctx)
                while _alt!=1 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1+1:
                        self.state = 1000
                        self.matchWildcard() 
                    self.state = 1005
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,105,self._ctx)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnsupportedHiveNativeCommandsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.kw1 = None # Token
            self.kw2 = None # Token
            self.kw3 = None # Token
            self.kw4 = None # Token
            self.kw5 = None # Token
            self.kw6 = None # Token

        def CREATE(self):
            return self.getToken(sqlParser.CREATE, 0)

        def ROLE(self):
            return self.getToken(sqlParser.ROLE, 0)

        def DROP(self):
            return self.getToken(sqlParser.DROP, 0)

        def GRANT(self):
            return self.getToken(sqlParser.GRANT, 0)

        def REVOKE(self):
            return self.getToken(sqlParser.REVOKE, 0)

        def SHOW(self):
            return self.getToken(sqlParser.SHOW, 0)

        def PRINCIPALS(self):
            return self.getToken(sqlParser.PRINCIPALS, 0)

        def ROLES(self):
            return self.getToken(sqlParser.ROLES, 0)

        def CURRENT(self):
            return self.getToken(sqlParser.CURRENT, 0)

        def EXPORT(self):
            return self.getToken(sqlParser.EXPORT, 0)

        def TABLE(self):
            return self.getToken(sqlParser.TABLE, 0)

        def IMPORT(self):
            return self.getToken(sqlParser.IMPORT, 0)

        def COMPACTIONS(self):
            return self.getToken(sqlParser.COMPACTIONS, 0)

        def TRANSACTIONS(self):
            return self.getToken(sqlParser.TRANSACTIONS, 0)

        def INDEXES(self):
            return self.getToken(sqlParser.INDEXES, 0)

        def LOCKS(self):
            return self.getToken(sqlParser.LOCKS, 0)

        def INDEX(self):
            return self.getToken(sqlParser.INDEX, 0)

        def ALTER(self):
            return self.getToken(sqlParser.ALTER, 0)

        def LOCK(self):
            return self.getToken(sqlParser.LOCK, 0)

        def DATABASE(self):
            return self.getToken(sqlParser.DATABASE, 0)

        def UNLOCK(self):
            return self.getToken(sqlParser.UNLOCK, 0)

        def TEMPORARY(self):
            return self.getToken(sqlParser.TEMPORARY, 0)

        def MACRO(self):
            return self.getToken(sqlParser.MACRO, 0)

        def tableIdentifier(self):
            return self.getTypedRuleContext(sqlParser.TableIdentifierContext,0)


        def NOT(self):
            return self.getToken(sqlParser.NOT, 0)

        def CLUSTERED(self):
            return self.getToken(sqlParser.CLUSTERED, 0)

        def BY(self):
            return self.getToken(sqlParser.BY, 0)

        def SORTED(self):
            return self.getToken(sqlParser.SORTED, 0)

        def SKEWED(self):
            return self.getToken(sqlParser.SKEWED, 0)

        def STORED(self):
            return self.getToken(sqlParser.STORED, 0)

        def AS(self):
            return self.getToken(sqlParser.AS, 0)

        def DIRECTORIES(self):
            return self.getToken(sqlParser.DIRECTORIES, 0)

        def SET(self):
            return self.getToken(sqlParser.SET, 0)

        def LOCATION(self):
            return self.getToken(sqlParser.LOCATION, 0)

        def EXCHANGE(self):
            return self.getToken(sqlParser.EXCHANGE, 0)

        def PARTITION(self):
            return self.getToken(sqlParser.PARTITION, 0)

        def ARCHIVE(self):
            return self.getToken(sqlParser.ARCHIVE, 0)

        def UNARCHIVE(self):
            return self.getToken(sqlParser.UNARCHIVE, 0)

        def TOUCH(self):
            return self.getToken(sqlParser.TOUCH, 0)

        def COMPACT(self):
            return self.getToken(sqlParser.COMPACT, 0)

        def partitionSpec(self):
            return self.getTypedRuleContext(sqlParser.PartitionSpecContext,0)


        def CONCATENATE(self):
            return self.getToken(sqlParser.CONCATENATE, 0)

        def FILEFORMAT(self):
            return self.getToken(sqlParser.FILEFORMAT, 0)

        def REPLACE(self):
            return self.getToken(sqlParser.REPLACE, 0)

        def COLUMNS(self):
            return self.getToken(sqlParser.COLUMNS, 0)

        def START(self):
            return self.getToken(sqlParser.START, 0)

        def TRANSACTION(self):
            return self.getToken(sqlParser.TRANSACTION, 0)

        def COMMIT(self):
            return self.getToken(sqlParser.COMMIT, 0)

        def ROLLBACK(self):
            return self.getToken(sqlParser.ROLLBACK, 0)

        def DFS(self):
            return self.getToken(sqlParser.DFS, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_unsupportedHiveNativeCommands

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnsupportedHiveNativeCommands" ):
                return visitor.visitUnsupportedHiveNativeCommands(self)
            else:
                return visitor.visitChildren(self)




    def unsupportedHiveNativeCommands(self):

        localctx = sqlParser.UnsupportedHiveNativeCommandsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_unsupportedHiveNativeCommands)
        self._la = 0 # Token type
        try:
            self.state = 1176
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,114,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1008
                localctx.kw1 = self.match(sqlParser.CREATE)
                self.state = 1009
                localctx.kw2 = self.match(sqlParser.ROLE)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1010
                localctx.kw1 = self.match(sqlParser.DROP)
                self.state = 1011
                localctx.kw2 = self.match(sqlParser.ROLE)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1012
                localctx.kw1 = self.match(sqlParser.GRANT)
                self.state = 1014
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,107,self._ctx)
                if la_ == 1:
                    self.state = 1013
                    localctx.kw2 = self.match(sqlParser.ROLE)


                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1016
                localctx.kw1 = self.match(sqlParser.REVOKE)
                self.state = 1018
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,108,self._ctx)
                if la_ == 1:
                    self.state = 1017
                    localctx.kw2 = self.match(sqlParser.ROLE)


                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1020
                localctx.kw1 = self.match(sqlParser.SHOW)
                self.state = 1021
                localctx.kw2 = self.match(sqlParser.GRANT)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1022
                localctx.kw1 = self.match(sqlParser.SHOW)
                self.state = 1023
                localctx.kw2 = self.match(sqlParser.ROLE)
                self.state = 1025
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,109,self._ctx)
                if la_ == 1:
                    self.state = 1024
                    localctx.kw3 = self.match(sqlParser.GRANT)


                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 1027
                localctx.kw1 = self.match(sqlParser.SHOW)
                self.state = 1028
                localctx.kw2 = self.match(sqlParser.PRINCIPALS)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 1029
                localctx.kw1 = self.match(sqlParser.SHOW)
                self.state = 1030
                localctx.kw2 = self.match(sqlParser.ROLES)
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 1031
                localctx.kw1 = self.match(sqlParser.SHOW)
                self.state = 1032
                localctx.kw2 = self.match(sqlParser.CURRENT)
                self.state = 1033
                localctx.kw3 = self.match(sqlParser.ROLES)
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 1034
                localctx.kw1 = self.match(sqlParser.EXPORT)
                self.state = 1035
                localctx.kw2 = self.match(sqlParser.TABLE)
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 1036
                localctx.kw1 = self.match(sqlParser.IMPORT)
                self.state = 1037
                localctx.kw2 = self.match(sqlParser.TABLE)
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 1038
                localctx.kw1 = self.match(sqlParser.SHOW)
                self.state = 1039
                localctx.kw2 = self.match(sqlParser.COMPACTIONS)
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 1040
                localctx.kw1 = self.match(sqlParser.SHOW)
                self.state = 1041
                localctx.kw2 = self.match(sqlParser.CREATE)
                self.state = 1042
                localctx.kw3 = self.match(sqlParser.TABLE)
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 1043
                localctx.kw1 = self.match(sqlParser.SHOW)
                self.state = 1044
                localctx.kw2 = self.match(sqlParser.TRANSACTIONS)
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 1045
                localctx.kw1 = self.match(sqlParser.SHOW)
                self.state = 1046
                localctx.kw2 = self.match(sqlParser.INDEXES)
                pass

            elif la_ == 16:
                self.enterOuterAlt(localctx, 16)
                self.state = 1047
                localctx.kw1 = self.match(sqlParser.SHOW)
                self.state = 1048
                localctx.kw2 = self.match(sqlParser.LOCKS)
                pass

            elif la_ == 17:
                self.enterOuterAlt(localctx, 17)
                self.state = 1049
                localctx.kw1 = self.match(sqlParser.CREATE)
                self.state = 1050
                localctx.kw2 = self.match(sqlParser.INDEX)
                pass

            elif la_ == 18:
                self.enterOuterAlt(localctx, 18)
                self.state = 1051
                localctx.kw1 = self.match(sqlParser.DROP)
                self.state = 1052
                localctx.kw2 = self.match(sqlParser.INDEX)
                pass

            elif la_ == 19:
                self.enterOuterAlt(localctx, 19)
                self.state = 1053
                localctx.kw1 = self.match(sqlParser.ALTER)
                self.state = 1054
                localctx.kw2 = self.match(sqlParser.INDEX)
                pass

            elif la_ == 20:
                self.enterOuterAlt(localctx, 20)
                self.state = 1055
                localctx.kw1 = self.match(sqlParser.LOCK)
                self.state = 1056
                localctx.kw2 = self.match(sqlParser.TABLE)
                pass

            elif la_ == 21:
                self.enterOuterAlt(localctx, 21)
                self.state = 1057
                localctx.kw1 = self.match(sqlParser.LOCK)
                self.state = 1058
                localctx.kw2 = self.match(sqlParser.DATABASE)
                pass

            elif la_ == 22:
                self.enterOuterAlt(localctx, 22)
                self.state = 1059
                localctx.kw1 = self.match(sqlParser.UNLOCK)
                self.state = 1060
                localctx.kw2 = self.match(sqlParser.TABLE)
                pass

            elif la_ == 23:
                self.enterOuterAlt(localctx, 23)
                self.state = 1061
                localctx.kw1 = self.match(sqlParser.UNLOCK)
                self.state = 1062
                localctx.kw2 = self.match(sqlParser.DATABASE)
                pass

            elif la_ == 24:
                self.enterOuterAlt(localctx, 24)
                self.state = 1063
                localctx.kw1 = self.match(sqlParser.CREATE)
                self.state = 1064
                localctx.kw2 = self.match(sqlParser.TEMPORARY)
                self.state = 1065
                localctx.kw3 = self.match(sqlParser.MACRO)
                pass

            elif la_ == 25:
                self.enterOuterAlt(localctx, 25)
                self.state = 1066
                localctx.kw1 = self.match(sqlParser.DROP)
                self.state = 1067
                localctx.kw2 = self.match(sqlParser.TEMPORARY)
                self.state = 1068
                localctx.kw3 = self.match(sqlParser.MACRO)
                pass

            elif la_ == 26:
                self.enterOuterAlt(localctx, 26)
                self.state = 1069
                localctx.kw1 = self.match(sqlParser.ALTER)
                self.state = 1070
                localctx.kw2 = self.match(sqlParser.TABLE)
                self.state = 1071
                self.tableIdentifier()
                self.state = 1072
                localctx.kw3 = self.match(sqlParser.NOT)
                self.state = 1073
                localctx.kw4 = self.match(sqlParser.CLUSTERED)
                pass

            elif la_ == 27:
                self.enterOuterAlt(localctx, 27)
                self.state = 1075
                localctx.kw1 = self.match(sqlParser.ALTER)
                self.state = 1076
                localctx.kw2 = self.match(sqlParser.TABLE)
                self.state = 1077
                self.tableIdentifier()
                self.state = 1078
                localctx.kw3 = self.match(sqlParser.CLUSTERED)
                self.state = 1079
                localctx.kw4 = self.match(sqlParser.BY)
                pass

            elif la_ == 28:
                self.enterOuterAlt(localctx, 28)
                self.state = 1081
                localctx.kw1 = self.match(sqlParser.ALTER)
                self.state = 1082
                localctx.kw2 = self.match(sqlParser.TABLE)
                self.state = 1083
                self.tableIdentifier()
                self.state = 1084
                localctx.kw3 = self.match(sqlParser.NOT)
                self.state = 1085
                localctx.kw4 = self.match(sqlParser.SORTED)
                pass

            elif la_ == 29:
                self.enterOuterAlt(localctx, 29)
                self.state = 1087
                localctx.kw1 = self.match(sqlParser.ALTER)
                self.state = 1088
                localctx.kw2 = self.match(sqlParser.TABLE)
                self.state = 1089
                self.tableIdentifier()
                self.state = 1090
                localctx.kw3 = self.match(sqlParser.SKEWED)
                self.state = 1091
                localctx.kw4 = self.match(sqlParser.BY)
                pass

            elif la_ == 30:
                self.enterOuterAlt(localctx, 30)
                self.state = 1093
                localctx.kw1 = self.match(sqlParser.ALTER)
                self.state = 1094
                localctx.kw2 = self.match(sqlParser.TABLE)
                self.state = 1095
                self.tableIdentifier()
                self.state = 1096
                localctx.kw3 = self.match(sqlParser.NOT)
                self.state = 1097
                localctx.kw4 = self.match(sqlParser.SKEWED)
                pass

            elif la_ == 31:
                self.enterOuterAlt(localctx, 31)
                self.state = 1099
                localctx.kw1 = self.match(sqlParser.ALTER)
                self.state = 1100
                localctx.kw2 = self.match(sqlParser.TABLE)
                self.state = 1101
                self.tableIdentifier()
                self.state = 1102
                localctx.kw3 = self.match(sqlParser.NOT)
                self.state = 1103
                localctx.kw4 = self.match(sqlParser.STORED)
                self.state = 1104
                localctx.kw5 = self.match(sqlParser.AS)
                self.state = 1105
                localctx.kw6 = self.match(sqlParser.DIRECTORIES)
                pass

            elif la_ == 32:
                self.enterOuterAlt(localctx, 32)
                self.state = 1107
                localctx.kw1 = self.match(sqlParser.ALTER)
                self.state = 1108
                localctx.kw2 = self.match(sqlParser.TABLE)
                self.state = 1109
                self.tableIdentifier()
                self.state = 1110
                localctx.kw3 = self.match(sqlParser.SET)
                self.state = 1111
                localctx.kw4 = self.match(sqlParser.SKEWED)
                self.state = 1112
                localctx.kw5 = self.match(sqlParser.LOCATION)
                pass

            elif la_ == 33:
                self.enterOuterAlt(localctx, 33)
                self.state = 1114
                localctx.kw1 = self.match(sqlParser.ALTER)
                self.state = 1115
                localctx.kw2 = self.match(sqlParser.TABLE)
                self.state = 1116
                self.tableIdentifier()
                self.state = 1117
                localctx.kw3 = self.match(sqlParser.EXCHANGE)
                self.state = 1118
                localctx.kw4 = self.match(sqlParser.PARTITION)
                pass

            elif la_ == 34:
                self.enterOuterAlt(localctx, 34)
                self.state = 1120
                localctx.kw1 = self.match(sqlParser.ALTER)
                self.state = 1121
                localctx.kw2 = self.match(sqlParser.TABLE)
                self.state = 1122
                self.tableIdentifier()
                self.state = 1123
                localctx.kw3 = self.match(sqlParser.ARCHIVE)
                self.state = 1124
                localctx.kw4 = self.match(sqlParser.PARTITION)
                pass

            elif la_ == 35:
                self.enterOuterAlt(localctx, 35)
                self.state = 1126
                localctx.kw1 = self.match(sqlParser.ALTER)
                self.state = 1127
                localctx.kw2 = self.match(sqlParser.TABLE)
                self.state = 1128
                self.tableIdentifier()
                self.state = 1129
                localctx.kw3 = self.match(sqlParser.UNARCHIVE)
                self.state = 1130
                localctx.kw4 = self.match(sqlParser.PARTITION)
                pass

            elif la_ == 36:
                self.enterOuterAlt(localctx, 36)
                self.state = 1132
                localctx.kw1 = self.match(sqlParser.ALTER)
                self.state = 1133
                localctx.kw2 = self.match(sqlParser.TABLE)
                self.state = 1134
                self.tableIdentifier()
                self.state = 1135
                localctx.kw3 = self.match(sqlParser.TOUCH)
                pass

            elif la_ == 37:
                self.enterOuterAlt(localctx, 37)
                self.state = 1137
                localctx.kw1 = self.match(sqlParser.ALTER)
                self.state = 1138
                localctx.kw2 = self.match(sqlParser.TABLE)
                self.state = 1139
                self.tableIdentifier()
                self.state = 1141
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.PARTITION:
                    self.state = 1140
                    self.partitionSpec()


                self.state = 1143
                localctx.kw3 = self.match(sqlParser.COMPACT)
                pass

            elif la_ == 38:
                self.enterOuterAlt(localctx, 38)
                self.state = 1145
                localctx.kw1 = self.match(sqlParser.ALTER)
                self.state = 1146
                localctx.kw2 = self.match(sqlParser.TABLE)
                self.state = 1147
                self.tableIdentifier()
                self.state = 1149
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.PARTITION:
                    self.state = 1148
                    self.partitionSpec()


                self.state = 1151
                localctx.kw3 = self.match(sqlParser.CONCATENATE)
                pass

            elif la_ == 39:
                self.enterOuterAlt(localctx, 39)
                self.state = 1153
                localctx.kw1 = self.match(sqlParser.ALTER)
                self.state = 1154
                localctx.kw2 = self.match(sqlParser.TABLE)
                self.state = 1155
                self.tableIdentifier()
                self.state = 1157
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.PARTITION:
                    self.state = 1156
                    self.partitionSpec()


                self.state = 1159
                localctx.kw3 = self.match(sqlParser.SET)
                self.state = 1160
                localctx.kw4 = self.match(sqlParser.FILEFORMAT)
                pass

            elif la_ == 40:
                self.enterOuterAlt(localctx, 40)
                self.state = 1162
                localctx.kw1 = self.match(sqlParser.ALTER)
                self.state = 1163
                localctx.kw2 = self.match(sqlParser.TABLE)
                self.state = 1164
                self.tableIdentifier()
                self.state = 1166
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.PARTITION:
                    self.state = 1165
                    self.partitionSpec()


                self.state = 1168
                localctx.kw3 = self.match(sqlParser.REPLACE)
                self.state = 1169
                localctx.kw4 = self.match(sqlParser.COLUMNS)
                pass

            elif la_ == 41:
                self.enterOuterAlt(localctx, 41)
                self.state = 1171
                localctx.kw1 = self.match(sqlParser.START)
                self.state = 1172
                localctx.kw2 = self.match(sqlParser.TRANSACTION)
                pass

            elif la_ == 42:
                self.enterOuterAlt(localctx, 42)
                self.state = 1173
                localctx.kw1 = self.match(sqlParser.COMMIT)
                pass

            elif la_ == 43:
                self.enterOuterAlt(localctx, 43)
                self.state = 1174
                localctx.kw1 = self.match(sqlParser.ROLLBACK)
                pass

            elif la_ == 44:
                self.enterOuterAlt(localctx, 44)
                self.state = 1175
                localctx.kw1 = self.match(sqlParser.DFS)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateTableHeaderContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CREATE(self):
            return self.getToken(sqlParser.CREATE, 0)

        def TABLE(self):
            return self.getToken(sqlParser.TABLE, 0)

        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)


        def TEMPORARY(self):
            return self.getToken(sqlParser.TEMPORARY, 0)

        def EXTERNAL(self):
            return self.getToken(sqlParser.EXTERNAL, 0)

        def IF(self):
            return self.getToken(sqlParser.IF, 0)

        def NOT(self):
            return self.getToken(sqlParser.NOT, 0)

        def EXISTS(self):
            return self.getToken(sqlParser.EXISTS, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_createTableHeader

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateTableHeader" ):
                return visitor.visitCreateTableHeader(self)
            else:
                return visitor.visitChildren(self)




    def createTableHeader(self):

        localctx = sqlParser.CreateTableHeaderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_createTableHeader)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1178
            self.match(sqlParser.CREATE)
            self.state = 1180
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==sqlParser.TEMPORARY:
                self.state = 1179
                self.match(sqlParser.TEMPORARY)


            self.state = 1183
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==sqlParser.EXTERNAL:
                self.state = 1182
                self.match(sqlParser.EXTERNAL)


            self.state = 1185
            self.match(sqlParser.TABLE)
            self.state = 1189
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,117,self._ctx)
            if la_ == 1:
                self.state = 1186
                self.match(sqlParser.IF)
                self.state = 1187
                self.match(sqlParser.NOT)
                self.state = 1188
                self.match(sqlParser.EXISTS)


            self.state = 1191
            self.multipartIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReplaceTableHeaderContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REPLACE(self):
            return self.getToken(sqlParser.REPLACE, 0)

        def TABLE(self):
            return self.getToken(sqlParser.TABLE, 0)

        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)


        def CREATE(self):
            return self.getToken(sqlParser.CREATE, 0)

        def OR(self):
            return self.getToken(sqlParser.OR, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_replaceTableHeader

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReplaceTableHeader" ):
                return visitor.visitReplaceTableHeader(self)
            else:
                return visitor.visitChildren(self)




    def replaceTableHeader(self):

        localctx = sqlParser.ReplaceTableHeaderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_replaceTableHeader)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1195
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==sqlParser.CREATE:
                self.state = 1193
                self.match(sqlParser.CREATE)
                self.state = 1194
                self.match(sqlParser.OR)


            self.state = 1197
            self.match(sqlParser.REPLACE)
            self.state = 1198
            self.match(sqlParser.TABLE)
            self.state = 1199
            self.multipartIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BucketSpecContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CLUSTERED(self):
            return self.getToken(sqlParser.CLUSTERED, 0)

        def BY(self, i:int=None):
            if i is None:
                return self.getTokens(sqlParser.BY)
            else:
                return self.getToken(sqlParser.BY, i)

        def identifierList(self):
            return self.getTypedRuleContext(sqlParser.IdentifierListContext,0)


        def INTO(self):
            return self.getToken(sqlParser.INTO, 0)

        def INTEGER_VALUE(self):
            return self.getToken(sqlParser.INTEGER_VALUE, 0)

        def BUCKETS(self):
            return self.getToken(sqlParser.BUCKETS, 0)

        def SORTED(self):
            return self.getToken(sqlParser.SORTED, 0)

        def orderedIdentifierList(self):
            return self.getTypedRuleContext(sqlParser.OrderedIdentifierListContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_bucketSpec

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBucketSpec" ):
                return visitor.visitBucketSpec(self)
            else:
                return visitor.visitChildren(self)




    def bucketSpec(self):

        localctx = sqlParser.BucketSpecContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_bucketSpec)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1201
            self.match(sqlParser.CLUSTERED)
            self.state = 1202
            self.match(sqlParser.BY)
            self.state = 1203
            self.identifierList()
            self.state = 1207
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==sqlParser.SORTED:
                self.state = 1204
                self.match(sqlParser.SORTED)
                self.state = 1205
                self.match(sqlParser.BY)
                self.state = 1206
                self.orderedIdentifierList()


            self.state = 1209
            self.match(sqlParser.INTO)
            self.state = 1210
            self.match(sqlParser.INTEGER_VALUE)
            self.state = 1211
            self.match(sqlParser.BUCKETS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SkewSpecContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SKEWED(self):
            return self.getToken(sqlParser.SKEWED, 0)

        def BY(self):
            return self.getToken(sqlParser.BY, 0)

        def identifierList(self):
            return self.getTypedRuleContext(sqlParser.IdentifierListContext,0)


        def ON(self):
            return self.getToken(sqlParser.ON, 0)

        def constantList(self):
            return self.getTypedRuleContext(sqlParser.ConstantListContext,0)


        def nestedConstantList(self):
            return self.getTypedRuleContext(sqlParser.NestedConstantListContext,0)


        def STORED(self):
            return self.getToken(sqlParser.STORED, 0)

        def AS(self):
            return self.getToken(sqlParser.AS, 0)

        def DIRECTORIES(self):
            return self.getToken(sqlParser.DIRECTORIES, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_skewSpec

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSkewSpec" ):
                return visitor.visitSkewSpec(self)
            else:
                return visitor.visitChildren(self)




    def skewSpec(self):

        localctx = sqlParser.SkewSpecContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_skewSpec)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1213
            self.match(sqlParser.SKEWED)
            self.state = 1214
            self.match(sqlParser.BY)
            self.state = 1215
            self.identifierList()
            self.state = 1216
            self.match(sqlParser.ON)
            self.state = 1219
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,120,self._ctx)
            if la_ == 1:
                self.state = 1217
                self.constantList()
                pass

            elif la_ == 2:
                self.state = 1218
                self.nestedConstantList()
                pass


            self.state = 1224
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,121,self._ctx)
            if la_ == 1:
                self.state = 1221
                self.match(sqlParser.STORED)
                self.state = 1222
                self.match(sqlParser.AS)
                self.state = 1223
                self.match(sqlParser.DIRECTORIES)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LocationSpecContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LOCATION(self):
            return self.getToken(sqlParser.LOCATION, 0)

        def STRING(self):
            return self.getToken(sqlParser.STRING, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_locationSpec

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLocationSpec" ):
                return visitor.visitLocationSpec(self)
            else:
                return visitor.visitChildren(self)




    def locationSpec(self):

        localctx = sqlParser.LocationSpecContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_locationSpec)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1226
            self.match(sqlParser.LOCATION)
            self.state = 1227
            self.match(sqlParser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CommentSpecContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMMENT(self):
            return self.getToken(sqlParser.COMMENT, 0)

        def STRING(self):
            return self.getToken(sqlParser.STRING, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_commentSpec

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCommentSpec" ):
                return visitor.visitCommentSpec(self)
            else:
                return visitor.visitChildren(self)




    def commentSpec(self):

        localctx = sqlParser.CommentSpecContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_commentSpec)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1229
            self.match(sqlParser.COMMENT)
            self.state = 1230
            self.match(sqlParser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QueryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def queryTerm(self):
            return self.getTypedRuleContext(sqlParser.QueryTermContext,0)


        def queryOrganization(self):
            return self.getTypedRuleContext(sqlParser.QueryOrganizationContext,0)


        def ctes(self):
            return self.getTypedRuleContext(sqlParser.CtesContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_query

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQuery" ):
                return visitor.visitQuery(self)
            else:
                return visitor.visitChildren(self)




    def query(self):

        localctx = sqlParser.QueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_query)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1233
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==sqlParser.WITH:
                self.state = 1232
                self.ctes()


            self.state = 1235
            self.queryTerm(0)
            self.state = 1236
            self.queryOrganization()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InsertIntoContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return sqlParser.RULE_insertInto

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class InsertOverwriteHiveDirContext(InsertIntoContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.InsertIntoContext
            super().__init__(parser)
            self.path = None # Token
            self.copyFrom(ctx)

        def INSERT(self):
            return self.getToken(sqlParser.INSERT, 0)
        def OVERWRITE(self):
            return self.getToken(sqlParser.OVERWRITE, 0)
        def DIRECTORY(self):
            return self.getToken(sqlParser.DIRECTORY, 0)
        def STRING(self):
            return self.getToken(sqlParser.STRING, 0)
        def LOCAL(self):
            return self.getToken(sqlParser.LOCAL, 0)
        def rowFormat(self):
            return self.getTypedRuleContext(sqlParser.RowFormatContext,0)

        def createFileFormat(self):
            return self.getTypedRuleContext(sqlParser.CreateFileFormatContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInsertOverwriteHiveDir" ):
                return visitor.visitInsertOverwriteHiveDir(self)
            else:
                return visitor.visitChildren(self)


    class InsertOverwriteDirContext(InsertIntoContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.InsertIntoContext
            super().__init__(parser)
            self.path = None # Token
            self.options = None # TablePropertyListContext
            self.copyFrom(ctx)

        def INSERT(self):
            return self.getToken(sqlParser.INSERT, 0)
        def OVERWRITE(self):
            return self.getToken(sqlParser.OVERWRITE, 0)
        def DIRECTORY(self):
            return self.getToken(sqlParser.DIRECTORY, 0)
        def tableProvider(self):
            return self.getTypedRuleContext(sqlParser.TableProviderContext,0)

        def LOCAL(self):
            return self.getToken(sqlParser.LOCAL, 0)
        def OPTIONS(self):
            return self.getToken(sqlParser.OPTIONS, 0)
        def STRING(self):
            return self.getToken(sqlParser.STRING, 0)
        def tablePropertyList(self):
            return self.getTypedRuleContext(sqlParser.TablePropertyListContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInsertOverwriteDir" ):
                return visitor.visitInsertOverwriteDir(self)
            else:
                return visitor.visitChildren(self)


    class InsertOverwriteTableContext(InsertIntoContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.InsertIntoContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def INSERT(self):
            return self.getToken(sqlParser.INSERT, 0)
        def OVERWRITE(self):
            return self.getToken(sqlParser.OVERWRITE, 0)
        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def TABLE(self):
            return self.getToken(sqlParser.TABLE, 0)
        def partitionSpec(self):
            return self.getTypedRuleContext(sqlParser.PartitionSpecContext,0)

        def IF(self):
            return self.getToken(sqlParser.IF, 0)
        def NOT(self):
            return self.getToken(sqlParser.NOT, 0)
        def EXISTS(self):
            return self.getToken(sqlParser.EXISTS, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInsertOverwriteTable" ):
                return visitor.visitInsertOverwriteTable(self)
            else:
                return visitor.visitChildren(self)


    class InsertIntoTableContext(InsertIntoContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.InsertIntoContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def INSERT(self):
            return self.getToken(sqlParser.INSERT, 0)
        def INTO(self):
            return self.getToken(sqlParser.INTO, 0)
        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def TABLE(self):
            return self.getToken(sqlParser.TABLE, 0)
        def partitionSpec(self):
            return self.getTypedRuleContext(sqlParser.PartitionSpecContext,0)

        def IF(self):
            return self.getToken(sqlParser.IF, 0)
        def NOT(self):
            return self.getToken(sqlParser.NOT, 0)
        def EXISTS(self):
            return self.getToken(sqlParser.EXISTS, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInsertIntoTable" ):
                return visitor.visitInsertIntoTable(self)
            else:
                return visitor.visitChildren(self)



    def insertInto(self):

        localctx = sqlParser.InsertIntoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_insertInto)
        self._la = 0 # Token type
        try:
            self.state = 1293
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,135,self._ctx)
            if la_ == 1:
                localctx = sqlParser.InsertOverwriteTableContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1238
                self.match(sqlParser.INSERT)
                self.state = 1239
                self.match(sqlParser.OVERWRITE)
                self.state = 1241
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,123,self._ctx)
                if la_ == 1:
                    self.state = 1240
                    self.match(sqlParser.TABLE)


                self.state = 1243
                self.multipartIdentifier()
                self.state = 1250
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.PARTITION:
                    self.state = 1244
                    self.partitionSpec()
                    self.state = 1248
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==sqlParser.IF:
                        self.state = 1245
                        self.match(sqlParser.IF)
                        self.state = 1246
                        self.match(sqlParser.NOT)
                        self.state = 1247
                        self.match(sqlParser.EXISTS)




                pass

            elif la_ == 2:
                localctx = sqlParser.InsertIntoTableContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1252
                self.match(sqlParser.INSERT)
                self.state = 1253
                self.match(sqlParser.INTO)
                self.state = 1255
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,126,self._ctx)
                if la_ == 1:
                    self.state = 1254
                    self.match(sqlParser.TABLE)


                self.state = 1257
                self.multipartIdentifier()
                self.state = 1259
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.PARTITION:
                    self.state = 1258
                    self.partitionSpec()


                self.state = 1264
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.IF:
                    self.state = 1261
                    self.match(sqlParser.IF)
                    self.state = 1262
                    self.match(sqlParser.NOT)
                    self.state = 1263
                    self.match(sqlParser.EXISTS)


                pass

            elif la_ == 3:
                localctx = sqlParser.InsertOverwriteHiveDirContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1266
                self.match(sqlParser.INSERT)
                self.state = 1267
                self.match(sqlParser.OVERWRITE)
                self.state = 1269
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.LOCAL:
                    self.state = 1268
                    self.match(sqlParser.LOCAL)


                self.state = 1271
                self.match(sqlParser.DIRECTORY)
                self.state = 1272
                localctx.path = self.match(sqlParser.STRING)
                self.state = 1274
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.ROW:
                    self.state = 1273
                    self.rowFormat()


                self.state = 1277
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.STORED:
                    self.state = 1276
                    self.createFileFormat()


                pass

            elif la_ == 4:
                localctx = sqlParser.InsertOverwriteDirContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1279
                self.match(sqlParser.INSERT)
                self.state = 1280
                self.match(sqlParser.OVERWRITE)
                self.state = 1282
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.LOCAL:
                    self.state = 1281
                    self.match(sqlParser.LOCAL)


                self.state = 1284
                self.match(sqlParser.DIRECTORY)
                self.state = 1286
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.STRING:
                    self.state = 1285
                    localctx.path = self.match(sqlParser.STRING)


                self.state = 1288
                self.tableProvider()
                self.state = 1291
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.OPTIONS:
                    self.state = 1289
                    self.match(sqlParser.OPTIONS)
                    self.state = 1290
                    localctx.options = self.tablePropertyList()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PartitionSpecLocationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def partitionSpec(self):
            return self.getTypedRuleContext(sqlParser.PartitionSpecContext,0)


        def locationSpec(self):
            return self.getTypedRuleContext(sqlParser.LocationSpecContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_partitionSpecLocation

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPartitionSpecLocation" ):
                return visitor.visitPartitionSpecLocation(self)
            else:
                return visitor.visitChildren(self)




    def partitionSpecLocation(self):

        localctx = sqlParser.PartitionSpecLocationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_partitionSpecLocation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1295
            self.partitionSpec()
            self.state = 1297
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==sqlParser.LOCATION:
                self.state = 1296
                self.locationSpec()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PartitionSpecContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PARTITION(self):
            return self.getToken(sqlParser.PARTITION, 0)

        def partitionVal(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.PartitionValContext)
            else:
                return self.getTypedRuleContext(sqlParser.PartitionValContext,i)


        def getRuleIndex(self):
            return sqlParser.RULE_partitionSpec

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPartitionSpec" ):
                return visitor.visitPartitionSpec(self)
            else:
                return visitor.visitChildren(self)




    def partitionSpec(self):

        localctx = sqlParser.PartitionSpecContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_partitionSpec)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1299
            self.match(sqlParser.PARTITION)
            self.state = 1300
            self.match(sqlParser.T__1)
            self.state = 1301
            self.partitionVal()
            self.state = 1306
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==sqlParser.T__3:
                self.state = 1302
                self.match(sqlParser.T__3)
                self.state = 1303
                self.partitionVal()
                self.state = 1308
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1309
            self.match(sqlParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PartitionValContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(sqlParser.IdentifierContext,0)


        def EQ(self):
            return self.getToken(sqlParser.EQ, 0)

        def constant(self):
            return self.getTypedRuleContext(sqlParser.ConstantContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_partitionVal

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPartitionVal" ):
                return visitor.visitPartitionVal(self)
            else:
                return visitor.visitChildren(self)




    def partitionVal(self):

        localctx = sqlParser.PartitionValContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_partitionVal)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1311
            self.identifier()
            self.state = 1314
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==sqlParser.EQ:
                self.state = 1312
                self.match(sqlParser.EQ)
                self.state = 1313
                self.constant()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NamespaceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAMESPACE(self):
            return self.getToken(sqlParser.NAMESPACE, 0)

        def DATABASE(self):
            return self.getToken(sqlParser.DATABASE, 0)

        def SCHEMA(self):
            return self.getToken(sqlParser.SCHEMA, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_namespace

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNamespace" ):
                return visitor.visitNamespace(self)
            else:
                return visitor.visitChildren(self)




    def namespace(self):

        localctx = sqlParser.NamespaceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_namespace)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1316
            _la = self._input.LA(1)
            if not(_la==sqlParser.DATABASE or _la==sqlParser.NAMESPACE or _la==sqlParser.SCHEMA):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DescribeFuncNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def qualifiedName(self):
            return self.getTypedRuleContext(sqlParser.QualifiedNameContext,0)


        def STRING(self):
            return self.getToken(sqlParser.STRING, 0)

        def comparisonOperator(self):
            return self.getTypedRuleContext(sqlParser.ComparisonOperatorContext,0)


        def arithmeticOperator(self):
            return self.getTypedRuleContext(sqlParser.ArithmeticOperatorContext,0)


        def predicateOperator(self):
            return self.getTypedRuleContext(sqlParser.PredicateOperatorContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_describeFuncName

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDescribeFuncName" ):
                return visitor.visitDescribeFuncName(self)
            else:
                return visitor.visitChildren(self)




    def describeFuncName(self):

        localctx = sqlParser.DescribeFuncNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_describeFuncName)
        try:
            self.state = 1323
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,139,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1318
                self.qualifiedName()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1319
                self.match(sqlParser.STRING)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1320
                self.comparisonOperator()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1321
                self.arithmeticOperator()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1322
                self.predicateOperator()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DescribeColNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._identifier = None # IdentifierContext
            self.nameParts = list() # of IdentifierContexts

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(sqlParser.IdentifierContext,i)


        def getRuleIndex(self):
            return sqlParser.RULE_describeColName

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDescribeColName" ):
                return visitor.visitDescribeColName(self)
            else:
                return visitor.visitChildren(self)




    def describeColName(self):

        localctx = sqlParser.DescribeColNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_describeColName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1325
            localctx._identifier = self.identifier()
            localctx.nameParts.append(localctx._identifier)
            self.state = 1330
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==sqlParser.T__4:
                self.state = 1326
                self.match(sqlParser.T__4)
                self.state = 1327
                localctx._identifier = self.identifier()
                localctx.nameParts.append(localctx._identifier)
                self.state = 1332
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CtesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WITH(self):
            return self.getToken(sqlParser.WITH, 0)

        def namedQuery(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.NamedQueryContext)
            else:
                return self.getTypedRuleContext(sqlParser.NamedQueryContext,i)


        def getRuleIndex(self):
            return sqlParser.RULE_ctes

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCtes" ):
                return visitor.visitCtes(self)
            else:
                return visitor.visitChildren(self)




    def ctes(self):

        localctx = sqlParser.CtesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_ctes)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1333
            self.match(sqlParser.WITH)
            self.state = 1334
            self.namedQuery()
            self.state = 1339
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==sqlParser.T__3:
                self.state = 1335
                self.match(sqlParser.T__3)
                self.state = 1336
                self.namedQuery()
                self.state = 1341
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NamedQueryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # ErrorCapturingIdentifierContext
            self.columnAliases = None # IdentifierListContext

        def query(self):
            return self.getTypedRuleContext(sqlParser.QueryContext,0)


        def errorCapturingIdentifier(self):
            return self.getTypedRuleContext(sqlParser.ErrorCapturingIdentifierContext,0)


        def AS(self):
            return self.getToken(sqlParser.AS, 0)

        def identifierList(self):
            return self.getTypedRuleContext(sqlParser.IdentifierListContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_namedQuery

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNamedQuery" ):
                return visitor.visitNamedQuery(self)
            else:
                return visitor.visitChildren(self)




    def namedQuery(self):

        localctx = sqlParser.NamedQueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_namedQuery)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1342
            localctx.name = self.errorCapturingIdentifier()
            self.state = 1344
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,142,self._ctx)
            if la_ == 1:
                self.state = 1343
                localctx.columnAliases = self.identifierList()


            self.state = 1347
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==sqlParser.AS:
                self.state = 1346
                self.match(sqlParser.AS)


            self.state = 1349
            self.match(sqlParser.T__1)
            self.state = 1350
            self.query()
            self.state = 1351
            self.match(sqlParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TableProviderContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def USING(self):
            return self.getToken(sqlParser.USING, 0)

        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_tableProvider

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableProvider" ):
                return visitor.visitTableProvider(self)
            else:
                return visitor.visitChildren(self)




    def tableProvider(self):

        localctx = sqlParser.TableProviderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_tableProvider)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1353
            self.match(sqlParser.USING)
            self.state = 1354
            self.multipartIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateTableClausesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.options = None # TablePropertyListContext
            self.partitioning = None # TransformListContext
            self.tableProps = None # TablePropertyListContext

        def bucketSpec(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.BucketSpecContext)
            else:
                return self.getTypedRuleContext(sqlParser.BucketSpecContext,i)


        def locationSpec(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.LocationSpecContext)
            else:
                return self.getTypedRuleContext(sqlParser.LocationSpecContext,i)


        def commentSpec(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.CommentSpecContext)
            else:
                return self.getTypedRuleContext(sqlParser.CommentSpecContext,i)


        def OPTIONS(self, i:int=None):
            if i is None:
                return self.getTokens(sqlParser.OPTIONS)
            else:
                return self.getToken(sqlParser.OPTIONS, i)

        def PARTITIONED(self, i:int=None):
            if i is None:
                return self.getTokens(sqlParser.PARTITIONED)
            else:
                return self.getToken(sqlParser.PARTITIONED, i)

        def BY(self, i:int=None):
            if i is None:
                return self.getTokens(sqlParser.BY)
            else:
                return self.getToken(sqlParser.BY, i)

        def TBLPROPERTIES(self, i:int=None):
            if i is None:
                return self.getTokens(sqlParser.TBLPROPERTIES)
            else:
                return self.getToken(sqlParser.TBLPROPERTIES, i)

        def tablePropertyList(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.TablePropertyListContext)
            else:
                return self.getTypedRuleContext(sqlParser.TablePropertyListContext,i)


        def transformList(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.TransformListContext)
            else:
                return self.getTypedRuleContext(sqlParser.TransformListContext,i)


        def getRuleIndex(self):
            return sqlParser.RULE_createTableClauses

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateTableClauses" ):
                return visitor.visitCreateTableClauses(self)
            else:
                return visitor.visitChildren(self)




    def createTableClauses(self):

        localctx = sqlParser.CreateTableClausesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_createTableClauses)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1368
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==sqlParser.CLUSTERED or _la==sqlParser.COMMENT or ((((_la - 138)) & ~0x3f) == 0 and ((1 << (_la - 138)) & ((1 << (sqlParser.LOCATION - 138)) | (1 << (sqlParser.OPTIONS - 138)) | (1 << (sqlParser.PARTITIONED - 138)))) != 0) or _la==sqlParser.TBLPROPERTIES:
                self.state = 1366
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [sqlParser.OPTIONS]:
                    self.state = 1356
                    self.match(sqlParser.OPTIONS)
                    self.state = 1357
                    localctx.options = self.tablePropertyList()
                    pass
                elif token in [sqlParser.PARTITIONED]:
                    self.state = 1358
                    self.match(sqlParser.PARTITIONED)
                    self.state = 1359
                    self.match(sqlParser.BY)
                    self.state = 1360
                    localctx.partitioning = self.transformList()
                    pass
                elif token in [sqlParser.CLUSTERED]:
                    self.state = 1361
                    self.bucketSpec()
                    pass
                elif token in [sqlParser.LOCATION]:
                    self.state = 1362
                    self.locationSpec()
                    pass
                elif token in [sqlParser.COMMENT]:
                    self.state = 1363
                    self.commentSpec()
                    pass
                elif token in [sqlParser.TBLPROPERTIES]:
                    self.state = 1364
                    self.match(sqlParser.TBLPROPERTIES)
                    self.state = 1365
                    localctx.tableProps = self.tablePropertyList()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1370
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TablePropertyListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tableProperty(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.TablePropertyContext)
            else:
                return self.getTypedRuleContext(sqlParser.TablePropertyContext,i)


        def getRuleIndex(self):
            return sqlParser.RULE_tablePropertyList

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTablePropertyList" ):
                return visitor.visitTablePropertyList(self)
            else:
                return visitor.visitChildren(self)




    def tablePropertyList(self):

        localctx = sqlParser.TablePropertyListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_tablePropertyList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1371
            self.match(sqlParser.T__1)
            self.state = 1372
            self.tableProperty()
            self.state = 1377
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==sqlParser.T__3:
                self.state = 1373
                self.match(sqlParser.T__3)
                self.state = 1374
                self.tableProperty()
                self.state = 1379
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1380
            self.match(sqlParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TablePropertyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.key = None # TablePropertyKeyContext
            self.value = None # TablePropertyValueContext

        def tablePropertyKey(self):
            return self.getTypedRuleContext(sqlParser.TablePropertyKeyContext,0)


        def tablePropertyValue(self):
            return self.getTypedRuleContext(sqlParser.TablePropertyValueContext,0)


        def EQ(self):
            return self.getToken(sqlParser.EQ, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_tableProperty

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableProperty" ):
                return visitor.visitTableProperty(self)
            else:
                return visitor.visitChildren(self)




    def tableProperty(self):

        localctx = sqlParser.TablePropertyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_tableProperty)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1382
            localctx.key = self.tablePropertyKey()
            self.state = 1387
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==sqlParser.FALSE or ((((_la - 241)) & ~0x3f) == 0 and ((1 << (_la - 241)) & ((1 << (sqlParser.TRUE - 241)) | (1 << (sqlParser.EQ - 241)) | (1 << (sqlParser.STRING - 241)) | (1 << (sqlParser.INTEGER_VALUE - 241)) | (1 << (sqlParser.DECIMAL_VALUE - 241)))) != 0):
                self.state = 1384
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.EQ:
                    self.state = 1383
                    self.match(sqlParser.EQ)


                self.state = 1386
                localctx.value = self.tablePropertyValue()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TablePropertyKeyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(sqlParser.IdentifierContext,i)


        def STRING(self):
            return self.getToken(sqlParser.STRING, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_tablePropertyKey

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTablePropertyKey" ):
                return visitor.visitTablePropertyKey(self)
            else:
                return visitor.visitChildren(self)




    def tablePropertyKey(self):

        localctx = sqlParser.TablePropertyKeyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_tablePropertyKey)
        self._la = 0 # Token type
        try:
            self.state = 1398
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,150,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1389
                self.identifier()
                self.state = 1394
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==sqlParser.T__4:
                    self.state = 1390
                    self.match(sqlParser.T__4)
                    self.state = 1391
                    self.identifier()
                    self.state = 1396
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1397
                self.match(sqlParser.STRING)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TablePropertyValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTEGER_VALUE(self):
            return self.getToken(sqlParser.INTEGER_VALUE, 0)

        def DECIMAL_VALUE(self):
            return self.getToken(sqlParser.DECIMAL_VALUE, 0)

        def booleanValue(self):
            return self.getTypedRuleContext(sqlParser.BooleanValueContext,0)


        def STRING(self):
            return self.getToken(sqlParser.STRING, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_tablePropertyValue

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTablePropertyValue" ):
                return visitor.visitTablePropertyValue(self)
            else:
                return visitor.visitChildren(self)




    def tablePropertyValue(self):

        localctx = sqlParser.TablePropertyValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_tablePropertyValue)
        try:
            self.state = 1404
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [sqlParser.INTEGER_VALUE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1400
                self.match(sqlParser.INTEGER_VALUE)
                pass
            elif token in [sqlParser.DECIMAL_VALUE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1401
                self.match(sqlParser.DECIMAL_VALUE)
                pass
            elif token in [sqlParser.FALSE, sqlParser.TRUE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1402
                self.booleanValue()
                pass
            elif token in [sqlParser.STRING]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1403
                self.match(sqlParser.STRING)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstantListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constant(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.ConstantContext)
            else:
                return self.getTypedRuleContext(sqlParser.ConstantContext,i)


        def getRuleIndex(self):
            return sqlParser.RULE_constantList

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstantList" ):
                return visitor.visitConstantList(self)
            else:
                return visitor.visitChildren(self)




    def constantList(self):

        localctx = sqlParser.ConstantListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_constantList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1406
            self.match(sqlParser.T__1)
            self.state = 1407
            self.constant()
            self.state = 1412
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==sqlParser.T__3:
                self.state = 1408
                self.match(sqlParser.T__3)
                self.state = 1409
                self.constant()
                self.state = 1414
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1415
            self.match(sqlParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NestedConstantListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constantList(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.ConstantListContext)
            else:
                return self.getTypedRuleContext(sqlParser.ConstantListContext,i)


        def getRuleIndex(self):
            return sqlParser.RULE_nestedConstantList

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNestedConstantList" ):
                return visitor.visitNestedConstantList(self)
            else:
                return visitor.visitChildren(self)




    def nestedConstantList(self):

        localctx = sqlParser.NestedConstantListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_nestedConstantList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1417
            self.match(sqlParser.T__1)
            self.state = 1418
            self.constantList()
            self.state = 1423
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==sqlParser.T__3:
                self.state = 1419
                self.match(sqlParser.T__3)
                self.state = 1420
                self.constantList()
                self.state = 1425
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1426
            self.match(sqlParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CreateFileFormatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STORED(self):
            return self.getToken(sqlParser.STORED, 0)

        def AS(self):
            return self.getToken(sqlParser.AS, 0)

        def fileFormat(self):
            return self.getTypedRuleContext(sqlParser.FileFormatContext,0)


        def BY(self):
            return self.getToken(sqlParser.BY, 0)

        def storageHandler(self):
            return self.getTypedRuleContext(sqlParser.StorageHandlerContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_createFileFormat

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreateFileFormat" ):
                return visitor.visitCreateFileFormat(self)
            else:
                return visitor.visitChildren(self)




    def createFileFormat(self):

        localctx = sqlParser.CreateFileFormatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_createFileFormat)
        try:
            self.state = 1434
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,154,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1428
                self.match(sqlParser.STORED)
                self.state = 1429
                self.match(sqlParser.AS)
                self.state = 1430
                self.fileFormat()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1431
                self.match(sqlParser.STORED)
                self.state = 1432
                self.match(sqlParser.BY)
                self.state = 1433
                self.storageHandler()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FileFormatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return sqlParser.RULE_fileFormat

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class TableFileFormatContext(FileFormatContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.FileFormatContext
            super().__init__(parser)
            self.inFmt = None # Token
            self.outFmt = None # Token
            self.copyFrom(ctx)

        def INPUTFORMAT(self):
            return self.getToken(sqlParser.INPUTFORMAT, 0)
        def OUTPUTFORMAT(self):
            return self.getToken(sqlParser.OUTPUTFORMAT, 0)
        def STRING(self, i:int=None):
            if i is None:
                return self.getTokens(sqlParser.STRING)
            else:
                return self.getToken(sqlParser.STRING, i)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableFileFormat" ):
                return visitor.visitTableFileFormat(self)
            else:
                return visitor.visitChildren(self)


    class GenericFileFormatContext(FileFormatContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.FileFormatContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(sqlParser.IdentifierContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGenericFileFormat" ):
                return visitor.visitGenericFileFormat(self)
            else:
                return visitor.visitChildren(self)



    def fileFormat(self):

        localctx = sqlParser.FileFormatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_fileFormat)
        try:
            self.state = 1441
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,155,self._ctx)
            if la_ == 1:
                localctx = sqlParser.TableFileFormatContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1436
                self.match(sqlParser.INPUTFORMAT)
                self.state = 1437
                localctx.inFmt = self.match(sqlParser.STRING)
                self.state = 1438
                self.match(sqlParser.OUTPUTFORMAT)
                self.state = 1439
                localctx.outFmt = self.match(sqlParser.STRING)
                pass

            elif la_ == 2:
                localctx = sqlParser.GenericFileFormatContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1440
                self.identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StorageHandlerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(sqlParser.STRING, 0)

        def WITH(self):
            return self.getToken(sqlParser.WITH, 0)

        def SERDEPROPERTIES(self):
            return self.getToken(sqlParser.SERDEPROPERTIES, 0)

        def tablePropertyList(self):
            return self.getTypedRuleContext(sqlParser.TablePropertyListContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_storageHandler

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStorageHandler" ):
                return visitor.visitStorageHandler(self)
            else:
                return visitor.visitChildren(self)




    def storageHandler(self):

        localctx = sqlParser.StorageHandlerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_storageHandler)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1443
            self.match(sqlParser.STRING)
            self.state = 1447
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,156,self._ctx)
            if la_ == 1:
                self.state = 1444
                self.match(sqlParser.WITH)
                self.state = 1445
                self.match(sqlParser.SERDEPROPERTIES)
                self.state = 1446
                self.tablePropertyList()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ResourceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(sqlParser.IdentifierContext,0)


        def STRING(self):
            return self.getToken(sqlParser.STRING, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_resource

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitResource" ):
                return visitor.visitResource(self)
            else:
                return visitor.visitChildren(self)




    def resource(self):

        localctx = sqlParser.ResourceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_resource)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1449
            self.identifier()
            self.state = 1450
            self.match(sqlParser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DmlStatementNoWithContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return sqlParser.RULE_dmlStatementNoWith

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class DeleteFromTableContext(DmlStatementNoWithContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.DmlStatementNoWithContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DELETE(self):
            return self.getToken(sqlParser.DELETE, 0)
        def FROM(self):
            return self.getToken(sqlParser.FROM, 0)
        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def tableAlias(self):
            return self.getTypedRuleContext(sqlParser.TableAliasContext,0)

        def whereClause(self):
            return self.getTypedRuleContext(sqlParser.WhereClauseContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeleteFromTable" ):
                return visitor.visitDeleteFromTable(self)
            else:
                return visitor.visitChildren(self)


    class SingleInsertQueryContext(DmlStatementNoWithContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.DmlStatementNoWithContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def insertInto(self):
            return self.getTypedRuleContext(sqlParser.InsertIntoContext,0)

        def queryTerm(self):
            return self.getTypedRuleContext(sqlParser.QueryTermContext,0)

        def queryOrganization(self):
            return self.getTypedRuleContext(sqlParser.QueryOrganizationContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSingleInsertQuery" ):
                return visitor.visitSingleInsertQuery(self)
            else:
                return visitor.visitChildren(self)


    class MultiInsertQueryContext(DmlStatementNoWithContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.DmlStatementNoWithContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def fromClause(self):
            return self.getTypedRuleContext(sqlParser.FromClauseContext,0)

        def multiInsertQueryBody(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.MultiInsertQueryBodyContext)
            else:
                return self.getTypedRuleContext(sqlParser.MultiInsertQueryBodyContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultiInsertQuery" ):
                return visitor.visitMultiInsertQuery(self)
            else:
                return visitor.visitChildren(self)


    class UpdateTableContext(DmlStatementNoWithContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.DmlStatementNoWithContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def UPDATE(self):
            return self.getToken(sqlParser.UPDATE, 0)
        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def tableAlias(self):
            return self.getTypedRuleContext(sqlParser.TableAliasContext,0)

        def setClause(self):
            return self.getTypedRuleContext(sqlParser.SetClauseContext,0)

        def whereClause(self):
            return self.getTypedRuleContext(sqlParser.WhereClauseContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUpdateTable" ):
                return visitor.visitUpdateTable(self)
            else:
                return visitor.visitChildren(self)


    class MergeIntoTableContext(DmlStatementNoWithContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.DmlStatementNoWithContext
            super().__init__(parser)
            self.target = None # MultipartIdentifierContext
            self.targetAlias = None # TableAliasContext
            self.source = None # MultipartIdentifierContext
            self.sourceQuery = None # QueryContext
            self.sourceAlias = None # TableAliasContext
            self.mergeCondition = None # BooleanExpressionContext
            self.copyFrom(ctx)

        def MERGE(self):
            return self.getToken(sqlParser.MERGE, 0)
        def INTO(self):
            return self.getToken(sqlParser.INTO, 0)
        def USING(self):
            return self.getToken(sqlParser.USING, 0)
        def ON(self):
            return self.getToken(sqlParser.ON, 0)
        def multipartIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.MultipartIdentifierContext)
            else:
                return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,i)

        def tableAlias(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.TableAliasContext)
            else:
                return self.getTypedRuleContext(sqlParser.TableAliasContext,i)

        def booleanExpression(self):
            return self.getTypedRuleContext(sqlParser.BooleanExpressionContext,0)

        def query(self):
            return self.getTypedRuleContext(sqlParser.QueryContext,0)

        def matchedClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.MatchedClauseContext)
            else:
                return self.getTypedRuleContext(sqlParser.MatchedClauseContext,i)

        def notMatchedClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.NotMatchedClauseContext)
            else:
                return self.getTypedRuleContext(sqlParser.NotMatchedClauseContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMergeIntoTable" ):
                return visitor.visitMergeIntoTable(self)
            else:
                return visitor.visitChildren(self)



    def dmlStatementNoWith(self):

        localctx = sqlParser.DmlStatementNoWithContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_dmlStatementNoWith)
        self._la = 0 # Token type
        try:
            self.state = 1503
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [sqlParser.INSERT]:
                localctx = sqlParser.SingleInsertQueryContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1452
                self.insertInto()
                self.state = 1453
                self.queryTerm(0)
                self.state = 1454
                self.queryOrganization()
                pass
            elif token in [sqlParser.FROM]:
                localctx = sqlParser.MultiInsertQueryContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1456
                self.fromClause()
                self.state = 1458 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 1457
                    self.multiInsertQueryBody()
                    self.state = 1460 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==sqlParser.INSERT):
                        break

                pass
            elif token in [sqlParser.DELETE]:
                localctx = sqlParser.DeleteFromTableContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1462
                self.match(sqlParser.DELETE)
                self.state = 1463
                self.match(sqlParser.FROM)
                self.state = 1464
                self.multipartIdentifier()
                self.state = 1465
                self.tableAlias()
                self.state = 1467
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.WHERE:
                    self.state = 1466
                    self.whereClause()


                pass
            elif token in [sqlParser.UPDATE]:
                localctx = sqlParser.UpdateTableContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1469
                self.match(sqlParser.UPDATE)
                self.state = 1470
                self.multipartIdentifier()
                self.state = 1471
                self.tableAlias()
                self.state = 1472
                self.setClause()
                self.state = 1474
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.WHERE:
                    self.state = 1473
                    self.whereClause()


                pass
            elif token in [sqlParser.MERGE]:
                localctx = sqlParser.MergeIntoTableContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 1476
                self.match(sqlParser.MERGE)
                self.state = 1477
                self.match(sqlParser.INTO)
                self.state = 1478
                localctx.target = self.multipartIdentifier()
                self.state = 1479
                localctx.targetAlias = self.tableAlias()
                self.state = 1480
                self.match(sqlParser.USING)
                self.state = 1486
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,160,self._ctx)
                if la_ == 1:
                    self.state = 1481
                    localctx.source = self.multipartIdentifier()
                    pass

                elif la_ == 2:
                    self.state = 1482
                    self.match(sqlParser.T__1)
                    self.state = 1483
                    localctx.sourceQuery = self.query()
                    self.state = 1484
                    self.match(sqlParser.T__2)
                    pass


                self.state = 1488
                localctx.sourceAlias = self.tableAlias()
                self.state = 1489
                self.match(sqlParser.ON)
                self.state = 1490
                localctx.mergeCondition = self.booleanExpression(0)
                self.state = 1494
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,161,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 1491
                        self.matchedClause() 
                    self.state = 1496
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,161,self._ctx)

                self.state = 1500
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==sqlParser.WHEN:
                    self.state = 1497
                    self.notMatchedClause()
                    self.state = 1502
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QueryOrganizationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._sortItem = None # SortItemContext
            self.order = list() # of SortItemContexts
            self._expression = None # ExpressionContext
            self.clusterBy = list() # of ExpressionContexts
            self.distributeBy = list() # of ExpressionContexts
            self.sort = list() # of SortItemContexts
            self.limit = None # ExpressionContext

        def ORDER(self):
            return self.getToken(sqlParser.ORDER, 0)

        def BY(self, i:int=None):
            if i is None:
                return self.getTokens(sqlParser.BY)
            else:
                return self.getToken(sqlParser.BY, i)

        def CLUSTER(self):
            return self.getToken(sqlParser.CLUSTER, 0)

        def DISTRIBUTE(self):
            return self.getToken(sqlParser.DISTRIBUTE, 0)

        def SORT(self):
            return self.getToken(sqlParser.SORT, 0)

        def windowClause(self):
            return self.getTypedRuleContext(sqlParser.WindowClauseContext,0)


        def LIMIT(self):
            return self.getToken(sqlParser.LIMIT, 0)

        def sortItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.SortItemContext)
            else:
                return self.getTypedRuleContext(sqlParser.SortItemContext,i)


        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(sqlParser.ExpressionContext,i)


        def ALL(self):
            return self.getToken(sqlParser.ALL, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_queryOrganization

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQueryOrganization" ):
                return visitor.visitQueryOrganization(self)
            else:
                return visitor.visitChildren(self)




    def queryOrganization(self):

        localctx = sqlParser.QueryOrganizationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_queryOrganization)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1515
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,165,self._ctx)
            if la_ == 1:
                self.state = 1505
                self.match(sqlParser.ORDER)
                self.state = 1506
                self.match(sqlParser.BY)
                self.state = 1507
                localctx._sortItem = self.sortItem()
                localctx.order.append(localctx._sortItem)
                self.state = 1512
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,164,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 1508
                        self.match(sqlParser.T__3)
                        self.state = 1509
                        localctx._sortItem = self.sortItem()
                        localctx.order.append(localctx._sortItem) 
                    self.state = 1514
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,164,self._ctx)



            self.state = 1527
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,167,self._ctx)
            if la_ == 1:
                self.state = 1517
                self.match(sqlParser.CLUSTER)
                self.state = 1518
                self.match(sqlParser.BY)
                self.state = 1519
                localctx._expression = self.expression()
                localctx.clusterBy.append(localctx._expression)
                self.state = 1524
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,166,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 1520
                        self.match(sqlParser.T__3)
                        self.state = 1521
                        localctx._expression = self.expression()
                        localctx.clusterBy.append(localctx._expression) 
                    self.state = 1526
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,166,self._ctx)



            self.state = 1539
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,169,self._ctx)
            if la_ == 1:
                self.state = 1529
                self.match(sqlParser.DISTRIBUTE)
                self.state = 1530
                self.match(sqlParser.BY)
                self.state = 1531
                localctx._expression = self.expression()
                localctx.distributeBy.append(localctx._expression)
                self.state = 1536
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,168,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 1532
                        self.match(sqlParser.T__3)
                        self.state = 1533
                        localctx._expression = self.expression()
                        localctx.distributeBy.append(localctx._expression) 
                    self.state = 1538
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,168,self._ctx)



            self.state = 1551
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,171,self._ctx)
            if la_ == 1:
                self.state = 1541
                self.match(sqlParser.SORT)
                self.state = 1542
                self.match(sqlParser.BY)
                self.state = 1543
                localctx._sortItem = self.sortItem()
                localctx.sort.append(localctx._sortItem)
                self.state = 1548
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,170,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 1544
                        self.match(sqlParser.T__3)
                        self.state = 1545
                        localctx._sortItem = self.sortItem()
                        localctx.sort.append(localctx._sortItem) 
                    self.state = 1550
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,170,self._ctx)



            self.state = 1554
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,172,self._ctx)
            if la_ == 1:
                self.state = 1553
                self.windowClause()


            self.state = 1561
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,174,self._ctx)
            if la_ == 1:
                self.state = 1556
                self.match(sqlParser.LIMIT)
                self.state = 1559
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,173,self._ctx)
                if la_ == 1:
                    self.state = 1557
                    self.match(sqlParser.ALL)
                    pass

                elif la_ == 2:
                    self.state = 1558
                    localctx.limit = self.expression()
                    pass




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultiInsertQueryBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def insertInto(self):
            return self.getTypedRuleContext(sqlParser.InsertIntoContext,0)


        def fromStatementBody(self):
            return self.getTypedRuleContext(sqlParser.FromStatementBodyContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_multiInsertQueryBody

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultiInsertQueryBody" ):
                return visitor.visitMultiInsertQueryBody(self)
            else:
                return visitor.visitChildren(self)




    def multiInsertQueryBody(self):

        localctx = sqlParser.MultiInsertQueryBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_multiInsertQueryBody)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1563
            self.insertInto()
            self.state = 1564
            self.fromStatementBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QueryTermContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return sqlParser.RULE_queryTerm

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class QueryTermDefaultContext(QueryTermContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.QueryTermContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def queryPrimary(self):
            return self.getTypedRuleContext(sqlParser.QueryPrimaryContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQueryTermDefault" ):
                return visitor.visitQueryTermDefault(self)
            else:
                return visitor.visitChildren(self)


    class SetOperationContext(QueryTermContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.QueryTermContext
            super().__init__(parser)
            self.left = None # QueryTermContext
            self.operator = None # Token
            self.right = None # QueryTermContext
            self.copyFrom(ctx)

        def queryTerm(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.QueryTermContext)
            else:
                return self.getTypedRuleContext(sqlParser.QueryTermContext,i)

        def INTERSECT(self):
            return self.getToken(sqlParser.INTERSECT, 0)
        def UNION(self):
            return self.getToken(sqlParser.UNION, 0)
        def EXCEPT(self):
            return self.getToken(sqlParser.EXCEPT, 0)
        def SETMINUS(self):
            return self.getToken(sqlParser.SETMINUS, 0)
        def setQuantifier(self):
            return self.getTypedRuleContext(sqlParser.SetQuantifierContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSetOperation" ):
                return visitor.visitSetOperation(self)
            else:
                return visitor.visitChildren(self)



    def queryTerm(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = sqlParser.QueryTermContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 80
        self.enterRecursionRule(localctx, 80, self.RULE_queryTerm, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            localctx = sqlParser.QueryTermDefaultContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx

            self.state = 1567
            self.queryPrimary()
            self._ctx.stop = self._input.LT(-1)
            self.state = 1592
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,179,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 1590
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,178,self._ctx)
                    if la_ == 1:
                        localctx = sqlParser.SetOperationContext(self, sqlParser.QueryTermContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_queryTerm)
                        self.state = 1569
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 1570
                        if not self.legacy_setops_precedence_enbled:
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.legacy_setops_precedence_enbled")
                        self.state = 1571
                        localctx.operator = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==sqlParser.EXCEPT or _la==sqlParser.INTERSECT or _la==sqlParser.SETMINUS or _la==sqlParser.UNION):
                            localctx.operator = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 1573
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==sqlParser.ALL or _la==sqlParser.DISTINCT:
                            self.state = 1572
                            self.setQuantifier()


                        self.state = 1575
                        localctx.right = self.queryTerm(4)
                        pass

                    elif la_ == 2:
                        localctx = sqlParser.SetOperationContext(self, sqlParser.QueryTermContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_queryTerm)
                        self.state = 1576
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 1577
                        if not not self.legacy_setops_precedence_enbled:
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "not self.legacy_setops_precedence_enbled")
                        self.state = 1578
                        localctx.operator = self.match(sqlParser.INTERSECT)
                        self.state = 1580
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==sqlParser.ALL or _la==sqlParser.DISTINCT:
                            self.state = 1579
                            self.setQuantifier()


                        self.state = 1582
                        localctx.right = self.queryTerm(3)
                        pass

                    elif la_ == 3:
                        localctx = sqlParser.SetOperationContext(self, sqlParser.QueryTermContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_queryTerm)
                        self.state = 1583
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 1584
                        if not not self.legacy_setops_precedence_enbled:
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "not self.legacy_setops_precedence_enbled")
                        self.state = 1585
                        localctx.operator = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==sqlParser.EXCEPT or _la==sqlParser.SETMINUS or _la==sqlParser.UNION):
                            localctx.operator = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 1587
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==sqlParser.ALL or _la==sqlParser.DISTINCT:
                            self.state = 1586
                            self.setQuantifier()


                        self.state = 1589
                        localctx.right = self.queryTerm(2)
                        pass

             
                self.state = 1594
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,179,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class QueryPrimaryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return sqlParser.RULE_queryPrimary

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class SubqueryContext(QueryPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.QueryPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def query(self):
            return self.getTypedRuleContext(sqlParser.QueryContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubquery" ):
                return visitor.visitSubquery(self)
            else:
                return visitor.visitChildren(self)


    class QueryPrimaryDefaultContext(QueryPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.QueryPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def querySpecification(self):
            return self.getTypedRuleContext(sqlParser.QuerySpecificationContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQueryPrimaryDefault" ):
                return visitor.visitQueryPrimaryDefault(self)
            else:
                return visitor.visitChildren(self)


    class InlineTableDefault1Context(QueryPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.QueryPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def inlineTable(self):
            return self.getTypedRuleContext(sqlParser.InlineTableContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInlineTableDefault1" ):
                return visitor.visitInlineTableDefault1(self)
            else:
                return visitor.visitChildren(self)


    class FromStmtContext(QueryPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.QueryPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def fromStatement(self):
            return self.getTypedRuleContext(sqlParser.FromStatementContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFromStmt" ):
                return visitor.visitFromStmt(self)
            else:
                return visitor.visitChildren(self)


    class TableContext(QueryPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.QueryPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def TABLE(self):
            return self.getToken(sqlParser.TABLE, 0)
        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTable" ):
                return visitor.visitTable(self)
            else:
                return visitor.visitChildren(self)



    def queryPrimary(self):

        localctx = sqlParser.QueryPrimaryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_queryPrimary)
        try:
            self.state = 1604
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [sqlParser.MAP, sqlParser.REDUCE, sqlParser.SELECT]:
                localctx = sqlParser.QueryPrimaryDefaultContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1595
                self.querySpecification()
                pass
            elif token in [sqlParser.FROM]:
                localctx = sqlParser.FromStmtContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1596
                self.fromStatement()
                pass
            elif token in [sqlParser.TABLE]:
                localctx = sqlParser.TableContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1597
                self.match(sqlParser.TABLE)
                self.state = 1598
                self.multipartIdentifier()
                pass
            elif token in [sqlParser.VALUES]:
                localctx = sqlParser.InlineTableDefault1Context(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1599
                self.inlineTable()
                pass
            elif token in [sqlParser.T__1]:
                localctx = sqlParser.SubqueryContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 1600
                self.match(sqlParser.T__1)
                self.state = 1601
                self.query()
                self.state = 1602
                self.match(sqlParser.T__2)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SortItemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ordering = None # Token
            self.nullOrder = None # Token

        def expression(self):
            return self.getTypedRuleContext(sqlParser.ExpressionContext,0)


        def NULLS(self):
            return self.getToken(sqlParser.NULLS, 0)

        def ASC(self):
            return self.getToken(sqlParser.ASC, 0)

        def DESC(self):
            return self.getToken(sqlParser.DESC, 0)

        def LAST(self):
            return self.getToken(sqlParser.LAST, 0)

        def FIRST(self):
            return self.getToken(sqlParser.FIRST, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_sortItem

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSortItem" ):
                return visitor.visitSortItem(self)
            else:
                return visitor.visitChildren(self)




    def sortItem(self):

        localctx = sqlParser.SortItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_sortItem)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1606
            self.expression()
            self.state = 1608
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,181,self._ctx)
            if la_ == 1:
                self.state = 1607
                localctx.ordering = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==sqlParser.ASC or _la==sqlParser.DESC):
                    localctx.ordering = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 1612
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,182,self._ctx)
            if la_ == 1:
                self.state = 1610
                self.match(sqlParser.NULLS)
                self.state = 1611
                localctx.nullOrder = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==sqlParser.FIRST or _la==sqlParser.LAST):
                    localctx.nullOrder = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FromStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fromClause(self):
            return self.getTypedRuleContext(sqlParser.FromClauseContext,0)


        def fromStatementBody(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.FromStatementBodyContext)
            else:
                return self.getTypedRuleContext(sqlParser.FromStatementBodyContext,i)


        def getRuleIndex(self):
            return sqlParser.RULE_fromStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFromStatement" ):
                return visitor.visitFromStatement(self)
            else:
                return visitor.visitChildren(self)




    def fromStatement(self):

        localctx = sqlParser.FromStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_fromStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1614
            self.fromClause()
            self.state = 1616 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1615
                    self.fromStatementBody()

                else:
                    raise NoViableAltException(self)
                self.state = 1618 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,183,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FromStatementBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def transformClause(self):
            return self.getTypedRuleContext(sqlParser.TransformClauseContext,0)


        def queryOrganization(self):
            return self.getTypedRuleContext(sqlParser.QueryOrganizationContext,0)


        def whereClause(self):
            return self.getTypedRuleContext(sqlParser.WhereClauseContext,0)


        def selectClause(self):
            return self.getTypedRuleContext(sqlParser.SelectClauseContext,0)


        def lateralView(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.LateralViewContext)
            else:
                return self.getTypedRuleContext(sqlParser.LateralViewContext,i)


        def aggregationClause(self):
            return self.getTypedRuleContext(sqlParser.AggregationClauseContext,0)


        def havingClause(self):
            return self.getTypedRuleContext(sqlParser.HavingClauseContext,0)


        def windowClause(self):
            return self.getTypedRuleContext(sqlParser.WindowClauseContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_fromStatementBody

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFromStatementBody" ):
                return visitor.visitFromStatementBody(self)
            else:
                return visitor.visitChildren(self)




    def fromStatementBody(self):

        localctx = sqlParser.FromStatementBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_fromStatementBody)
        try:
            self.state = 1647
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,190,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1620
                self.transformClause()
                self.state = 1622
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,184,self._ctx)
                if la_ == 1:
                    self.state = 1621
                    self.whereClause()


                self.state = 1624
                self.queryOrganization()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1626
                self.selectClause()
                self.state = 1630
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,185,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 1627
                        self.lateralView() 
                    self.state = 1632
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,185,self._ctx)

                self.state = 1634
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,186,self._ctx)
                if la_ == 1:
                    self.state = 1633
                    self.whereClause()


                self.state = 1637
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,187,self._ctx)
                if la_ == 1:
                    self.state = 1636
                    self.aggregationClause()


                self.state = 1640
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,188,self._ctx)
                if la_ == 1:
                    self.state = 1639
                    self.havingClause()


                self.state = 1643
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,189,self._ctx)
                if la_ == 1:
                    self.state = 1642
                    self.windowClause()


                self.state = 1645
                self.queryOrganization()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QuerySpecificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return sqlParser.RULE_querySpecification

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RegularQuerySpecificationContext(QuerySpecificationContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.QuerySpecificationContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def selectClause(self):
            return self.getTypedRuleContext(sqlParser.SelectClauseContext,0)

        def fromClause(self):
            return self.getTypedRuleContext(sqlParser.FromClauseContext,0)

        def lateralView(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.LateralViewContext)
            else:
                return self.getTypedRuleContext(sqlParser.LateralViewContext,i)

        def whereClause(self):
            return self.getTypedRuleContext(sqlParser.WhereClauseContext,0)

        def aggregationClause(self):
            return self.getTypedRuleContext(sqlParser.AggregationClauseContext,0)

        def havingClause(self):
            return self.getTypedRuleContext(sqlParser.HavingClauseContext,0)

        def windowClause(self):
            return self.getTypedRuleContext(sqlParser.WindowClauseContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRegularQuerySpecification" ):
                return visitor.visitRegularQuerySpecification(self)
            else:
                return visitor.visitChildren(self)


    class TransformQuerySpecificationContext(QuerySpecificationContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.QuerySpecificationContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def transformClause(self):
            return self.getTypedRuleContext(sqlParser.TransformClauseContext,0)

        def fromClause(self):
            return self.getTypedRuleContext(sqlParser.FromClauseContext,0)

        def whereClause(self):
            return self.getTypedRuleContext(sqlParser.WhereClauseContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTransformQuerySpecification" ):
                return visitor.visitTransformQuerySpecification(self)
            else:
                return visitor.visitChildren(self)



    def querySpecification(self):

        localctx = sqlParser.QuerySpecificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_querySpecification)
        try:
            self.state = 1678
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,199,self._ctx)
            if la_ == 1:
                localctx = sqlParser.TransformQuerySpecificationContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1649
                self.transformClause()
                self.state = 1651
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,191,self._ctx)
                if la_ == 1:
                    self.state = 1650
                    self.fromClause()


                self.state = 1654
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,192,self._ctx)
                if la_ == 1:
                    self.state = 1653
                    self.whereClause()


                pass

            elif la_ == 2:
                localctx = sqlParser.RegularQuerySpecificationContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1656
                self.selectClause()
                self.state = 1658
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,193,self._ctx)
                if la_ == 1:
                    self.state = 1657
                    self.fromClause()


                self.state = 1663
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,194,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 1660
                        self.lateralView() 
                    self.state = 1665
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,194,self._ctx)

                self.state = 1667
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,195,self._ctx)
                if la_ == 1:
                    self.state = 1666
                    self.whereClause()


                self.state = 1670
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,196,self._ctx)
                if la_ == 1:
                    self.state = 1669
                    self.aggregationClause()


                self.state = 1673
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,197,self._ctx)
                if la_ == 1:
                    self.state = 1672
                    self.havingClause()


                self.state = 1676
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,198,self._ctx)
                if la_ == 1:
                    self.state = 1675
                    self.windowClause()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TransformClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.kind = None # Token
            self.inRowFormat = None # RowFormatContext
            self.recordWriter = None # Token
            self.script = None # Token
            self.outRowFormat = None # RowFormatContext
            self.recordReader = None # Token

        def USING(self):
            return self.getToken(sqlParser.USING, 0)

        def STRING(self, i:int=None):
            if i is None:
                return self.getTokens(sqlParser.STRING)
            else:
                return self.getToken(sqlParser.STRING, i)

        def SELECT(self):
            return self.getToken(sqlParser.SELECT, 0)

        def namedExpressionSeq(self):
            return self.getTypedRuleContext(sqlParser.NamedExpressionSeqContext,0)


        def TRANSFORM(self):
            return self.getToken(sqlParser.TRANSFORM, 0)

        def MAP(self):
            return self.getToken(sqlParser.MAP, 0)

        def REDUCE(self):
            return self.getToken(sqlParser.REDUCE, 0)

        def RECORDWRITER(self):
            return self.getToken(sqlParser.RECORDWRITER, 0)

        def AS(self):
            return self.getToken(sqlParser.AS, 0)

        def RECORDREADER(self):
            return self.getToken(sqlParser.RECORDREADER, 0)

        def rowFormat(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.RowFormatContext)
            else:
                return self.getTypedRuleContext(sqlParser.RowFormatContext,i)


        def identifierSeq(self):
            return self.getTypedRuleContext(sqlParser.IdentifierSeqContext,0)


        def colTypeList(self):
            return self.getTypedRuleContext(sqlParser.ColTypeListContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_transformClause

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTransformClause" ):
                return visitor.visitTransformClause(self)
            else:
                return visitor.visitChildren(self)




    def transformClause(self):

        localctx = sqlParser.TransformClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_transformClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1690
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [sqlParser.SELECT]:
                self.state = 1680
                self.match(sqlParser.SELECT)
                self.state = 1681
                localctx.kind = self.match(sqlParser.TRANSFORM)
                self.state = 1682
                self.match(sqlParser.T__1)
                self.state = 1683
                self.namedExpressionSeq()
                self.state = 1684
                self.match(sqlParser.T__2)
                pass
            elif token in [sqlParser.MAP]:
                self.state = 1686
                localctx.kind = self.match(sqlParser.MAP)
                self.state = 1687
                self.namedExpressionSeq()
                pass
            elif token in [sqlParser.REDUCE]:
                self.state = 1688
                localctx.kind = self.match(sqlParser.REDUCE)
                self.state = 1689
                self.namedExpressionSeq()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 1693
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==sqlParser.ROW:
                self.state = 1692
                localctx.inRowFormat = self.rowFormat()


            self.state = 1697
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==sqlParser.RECORDWRITER:
                self.state = 1695
                self.match(sqlParser.RECORDWRITER)
                self.state = 1696
                localctx.recordWriter = self.match(sqlParser.STRING)


            self.state = 1699
            self.match(sqlParser.USING)
            self.state = 1700
            localctx.script = self.match(sqlParser.STRING)
            self.state = 1713
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,205,self._ctx)
            if la_ == 1:
                self.state = 1701
                self.match(sqlParser.AS)
                self.state = 1711
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,204,self._ctx)
                if la_ == 1:
                    self.state = 1702
                    self.identifierSeq()
                    pass

                elif la_ == 2:
                    self.state = 1703
                    self.colTypeList()
                    pass

                elif la_ == 3:
                    self.state = 1704
                    self.match(sqlParser.T__1)
                    self.state = 1707
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,203,self._ctx)
                    if la_ == 1:
                        self.state = 1705
                        self.identifierSeq()
                        pass

                    elif la_ == 2:
                        self.state = 1706
                        self.colTypeList()
                        pass


                    self.state = 1709
                    self.match(sqlParser.T__2)
                    pass




            self.state = 1716
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,206,self._ctx)
            if la_ == 1:
                self.state = 1715
                localctx.outRowFormat = self.rowFormat()


            self.state = 1720
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,207,self._ctx)
            if la_ == 1:
                self.state = 1718
                self.match(sqlParser.RECORDREADER)
                self.state = 1719
                localctx.recordReader = self.match(sqlParser.STRING)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SelectClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._hint = None # HintContext
            self.hints = list() # of HintContexts

        def SELECT(self):
            return self.getToken(sqlParser.SELECT, 0)

        def namedExpressionSeq(self):
            return self.getTypedRuleContext(sqlParser.NamedExpressionSeqContext,0)


        def setQuantifier(self):
            return self.getTypedRuleContext(sqlParser.SetQuantifierContext,0)


        def hint(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.HintContext)
            else:
                return self.getTypedRuleContext(sqlParser.HintContext,i)


        def getRuleIndex(self):
            return sqlParser.RULE_selectClause

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSelectClause" ):
                return visitor.visitSelectClause(self)
            else:
                return visitor.visitChildren(self)




    def selectClause(self):

        localctx = sqlParser.SelectClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_selectClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1722
            self.match(sqlParser.SELECT)
            self.state = 1726
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,208,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1723
                    localctx._hint = self.hint()
                    localctx.hints.append(localctx._hint) 
                self.state = 1728
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,208,self._ctx)

            self.state = 1730
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,209,self._ctx)
            if la_ == 1:
                self.state = 1729
                self.setQuantifier()


            self.state = 1732
            self.namedExpressionSeq()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SET(self):
            return self.getToken(sqlParser.SET, 0)

        def assignmentList(self):
            return self.getTypedRuleContext(sqlParser.AssignmentListContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_setClause

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSetClause" ):
                return visitor.visitSetClause(self)
            else:
                return visitor.visitChildren(self)




    def setClause(self):

        localctx = sqlParser.SetClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_setClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1734
            self.match(sqlParser.SET)
            self.state = 1735
            self.assignmentList()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MatchedClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.matchedCond = None # BooleanExpressionContext

        def WHEN(self):
            return self.getToken(sqlParser.WHEN, 0)

        def MATCHED(self):
            return self.getToken(sqlParser.MATCHED, 0)

        def THEN(self):
            return self.getToken(sqlParser.THEN, 0)

        def matchedAction(self):
            return self.getTypedRuleContext(sqlParser.MatchedActionContext,0)


        def AND(self):
            return self.getToken(sqlParser.AND, 0)

        def booleanExpression(self):
            return self.getTypedRuleContext(sqlParser.BooleanExpressionContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_matchedClause

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMatchedClause" ):
                return visitor.visitMatchedClause(self)
            else:
                return visitor.visitChildren(self)




    def matchedClause(self):

        localctx = sqlParser.MatchedClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_matchedClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1737
            self.match(sqlParser.WHEN)
            self.state = 1738
            self.match(sqlParser.MATCHED)
            self.state = 1741
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==sqlParser.AND:
                self.state = 1739
                self.match(sqlParser.AND)
                self.state = 1740
                localctx.matchedCond = self.booleanExpression(0)


            self.state = 1743
            self.match(sqlParser.THEN)
            self.state = 1744
            self.matchedAction()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NotMatchedClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.notMatchedCond = None # BooleanExpressionContext

        def WHEN(self):
            return self.getToken(sqlParser.WHEN, 0)

        def NOT(self):
            return self.getToken(sqlParser.NOT, 0)

        def MATCHED(self):
            return self.getToken(sqlParser.MATCHED, 0)

        def THEN(self):
            return self.getToken(sqlParser.THEN, 0)

        def notMatchedAction(self):
            return self.getTypedRuleContext(sqlParser.NotMatchedActionContext,0)


        def AND(self):
            return self.getToken(sqlParser.AND, 0)

        def booleanExpression(self):
            return self.getTypedRuleContext(sqlParser.BooleanExpressionContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_notMatchedClause

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNotMatchedClause" ):
                return visitor.visitNotMatchedClause(self)
            else:
                return visitor.visitChildren(self)




    def notMatchedClause(self):

        localctx = sqlParser.NotMatchedClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_notMatchedClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1746
            self.match(sqlParser.WHEN)
            self.state = 1747
            self.match(sqlParser.NOT)
            self.state = 1748
            self.match(sqlParser.MATCHED)
            self.state = 1751
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==sqlParser.AND:
                self.state = 1749
                self.match(sqlParser.AND)
                self.state = 1750
                localctx.notMatchedCond = self.booleanExpression(0)


            self.state = 1753
            self.match(sqlParser.THEN)
            self.state = 1754
            self.notMatchedAction()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MatchedActionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DELETE(self):
            return self.getToken(sqlParser.DELETE, 0)

        def UPDATE(self):
            return self.getToken(sqlParser.UPDATE, 0)

        def SET(self):
            return self.getToken(sqlParser.SET, 0)

        def ASTERISK(self):
            return self.getToken(sqlParser.ASTERISK, 0)

        def assignmentList(self):
            return self.getTypedRuleContext(sqlParser.AssignmentListContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_matchedAction

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMatchedAction" ):
                return visitor.visitMatchedAction(self)
            else:
                return visitor.visitChildren(self)




    def matchedAction(self):

        localctx = sqlParser.MatchedActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_matchedAction)
        try:
            self.state = 1763
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,212,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1756
                self.match(sqlParser.DELETE)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1757
                self.match(sqlParser.UPDATE)
                self.state = 1758
                self.match(sqlParser.SET)
                self.state = 1759
                self.match(sqlParser.ASTERISK)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1760
                self.match(sqlParser.UPDATE)
                self.state = 1761
                self.match(sqlParser.SET)
                self.state = 1762
                self.assignmentList()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NotMatchedActionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.columns = None # MultipartIdentifierListContext

        def INSERT(self):
            return self.getToken(sqlParser.INSERT, 0)

        def ASTERISK(self):
            return self.getToken(sqlParser.ASTERISK, 0)

        def VALUES(self):
            return self.getToken(sqlParser.VALUES, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(sqlParser.ExpressionContext,i)


        def multipartIdentifierList(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierListContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_notMatchedAction

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNotMatchedAction" ):
                return visitor.visitNotMatchedAction(self)
            else:
                return visitor.visitChildren(self)




    def notMatchedAction(self):

        localctx = sqlParser.NotMatchedActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_notMatchedAction)
        self._la = 0 # Token type
        try:
            self.state = 1783
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,214,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1765
                self.match(sqlParser.INSERT)
                self.state = 1766
                self.match(sqlParser.ASTERISK)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1767
                self.match(sqlParser.INSERT)
                self.state = 1768
                self.match(sqlParser.T__1)
                self.state = 1769
                localctx.columns = self.multipartIdentifierList()
                self.state = 1770
                self.match(sqlParser.T__2)
                self.state = 1771
                self.match(sqlParser.VALUES)
                self.state = 1772
                self.match(sqlParser.T__1)
                self.state = 1773
                self.expression()
                self.state = 1778
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==sqlParser.T__3:
                    self.state = 1774
                    self.match(sqlParser.T__3)
                    self.state = 1775
                    self.expression()
                    self.state = 1780
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1781
                self.match(sqlParser.T__2)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignmentListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.AssignmentContext)
            else:
                return self.getTypedRuleContext(sqlParser.AssignmentContext,i)


        def getRuleIndex(self):
            return sqlParser.RULE_assignmentList

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignmentList" ):
                return visitor.visitAssignmentList(self)
            else:
                return visitor.visitChildren(self)




    def assignmentList(self):

        localctx = sqlParser.AssignmentListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_assignmentList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1785
            self.assignment()
            self.state = 1790
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==sqlParser.T__3:
                self.state = 1786
                self.match(sqlParser.T__3)
                self.state = 1787
                self.assignment()
                self.state = 1792
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.key = None # MultipartIdentifierContext
            self.value = None # ExpressionContext

        def EQ(self):
            return self.getToken(sqlParser.EQ, 0)

        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)


        def expression(self):
            return self.getTypedRuleContext(sqlParser.ExpressionContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_assignment

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignment" ):
                return visitor.visitAssignment(self)
            else:
                return visitor.visitChildren(self)




    def assignment(self):

        localctx = sqlParser.AssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_assignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1793
            localctx.key = self.multipartIdentifier()
            self.state = 1794
            self.match(sqlParser.EQ)
            self.state = 1795
            localctx.value = self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WhereClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHERE(self):
            return self.getToken(sqlParser.WHERE, 0)

        def booleanExpression(self):
            return self.getTypedRuleContext(sqlParser.BooleanExpressionContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_whereClause

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhereClause" ):
                return visitor.visitWhereClause(self)
            else:
                return visitor.visitChildren(self)




    def whereClause(self):

        localctx = sqlParser.WhereClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_whereClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1797
            self.match(sqlParser.WHERE)
            self.state = 1798
            self.booleanExpression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HavingClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HAVING(self):
            return self.getToken(sqlParser.HAVING, 0)

        def booleanExpression(self):
            return self.getTypedRuleContext(sqlParser.BooleanExpressionContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_havingClause

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHavingClause" ):
                return visitor.visitHavingClause(self)
            else:
                return visitor.visitChildren(self)




    def havingClause(self):

        localctx = sqlParser.HavingClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_havingClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1800
            self.match(sqlParser.HAVING)
            self.state = 1801
            self.booleanExpression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HintContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._hintStatement = None # HintStatementContext
            self.hintStatements = list() # of HintStatementContexts

        def hintStatement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.HintStatementContext)
            else:
                return self.getTypedRuleContext(sqlParser.HintStatementContext,i)


        def getRuleIndex(self):
            return sqlParser.RULE_hint

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHint" ):
                return visitor.visitHint(self)
            else:
                return visitor.visitChildren(self)




    def hint(self):

        localctx = sqlParser.HintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_hint)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1803
            self.match(sqlParser.T__5)
            self.state = 1804
            localctx._hintStatement = self.hintStatement()
            localctx.hintStatements.append(localctx._hintStatement)
            self.state = 1811
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,217,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1806
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,216,self._ctx)
                    if la_ == 1:
                        self.state = 1805
                        self.match(sqlParser.T__3)


                    self.state = 1808
                    localctx._hintStatement = self.hintStatement()
                    localctx.hintStatements.append(localctx._hintStatement) 
                self.state = 1813
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,217,self._ctx)

            self.state = 1814
            self.match(sqlParser.T__6)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HintStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.hintName = None # IdentifierContext
            self._primaryExpression = None # PrimaryExpressionContext
            self.parameters = list() # of PrimaryExpressionContexts

        def identifier(self):
            return self.getTypedRuleContext(sqlParser.IdentifierContext,0)


        def primaryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.PrimaryExpressionContext)
            else:
                return self.getTypedRuleContext(sqlParser.PrimaryExpressionContext,i)


        def getRuleIndex(self):
            return sqlParser.RULE_hintStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHintStatement" ):
                return visitor.visitHintStatement(self)
            else:
                return visitor.visitChildren(self)




    def hintStatement(self):

        localctx = sqlParser.HintStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_hintStatement)
        self._la = 0 # Token type
        try:
            self.state = 1829
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,219,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1816
                localctx.hintName = self.identifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1817
                localctx.hintName = self.identifier()
                self.state = 1818
                self.match(sqlParser.T__1)
                self.state = 1819
                localctx._primaryExpression = self.primaryExpression(0)
                localctx.parameters.append(localctx._primaryExpression)
                self.state = 1824
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==sqlParser.T__3:
                    self.state = 1820
                    self.match(sqlParser.T__3)
                    self.state = 1821
                    localctx._primaryExpression = self.primaryExpression(0)
                    localctx.parameters.append(localctx._primaryExpression)
                    self.state = 1826
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1827
                self.match(sqlParser.T__2)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FromClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FROM(self):
            return self.getToken(sqlParser.FROM, 0)

        def relation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.RelationContext)
            else:
                return self.getTypedRuleContext(sqlParser.RelationContext,i)


        def lateralView(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.LateralViewContext)
            else:
                return self.getTypedRuleContext(sqlParser.LateralViewContext,i)


        def pivotClause(self):
            return self.getTypedRuleContext(sqlParser.PivotClauseContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_fromClause

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFromClause" ):
                return visitor.visitFromClause(self)
            else:
                return visitor.visitChildren(self)




    def fromClause(self):

        localctx = sqlParser.FromClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_fromClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1831
            self.match(sqlParser.FROM)
            self.state = 1832
            self.relation()
            self.state = 1837
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,220,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1833
                    self.match(sqlParser.T__3)
                    self.state = 1834
                    self.relation() 
                self.state = 1839
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,220,self._ctx)

            self.state = 1843
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,221,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1840
                    self.lateralView() 
                self.state = 1845
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,221,self._ctx)

            self.state = 1847
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,222,self._ctx)
            if la_ == 1:
                self.state = 1846
                self.pivotClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggregationClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._expression = None # ExpressionContext
            self.groupingExpressions = list() # of ExpressionContexts
            self.kind = None # Token

        def GROUP(self):
            return self.getToken(sqlParser.GROUP, 0)

        def BY(self):
            return self.getToken(sqlParser.BY, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(sqlParser.ExpressionContext,i)


        def WITH(self):
            return self.getToken(sqlParser.WITH, 0)

        def SETS(self):
            return self.getToken(sqlParser.SETS, 0)

        def groupingSet(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.GroupingSetContext)
            else:
                return self.getTypedRuleContext(sqlParser.GroupingSetContext,i)


        def ROLLUP(self):
            return self.getToken(sqlParser.ROLLUP, 0)

        def CUBE(self):
            return self.getToken(sqlParser.CUBE, 0)

        def GROUPING(self):
            return self.getToken(sqlParser.GROUPING, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_aggregationClause

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAggregationClause" ):
                return visitor.visitAggregationClause(self)
            else:
                return visitor.visitChildren(self)




    def aggregationClause(self):

        localctx = sqlParser.AggregationClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_aggregationClause)
        self._la = 0 # Token type
        try:
            self.state = 1893
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,227,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1849
                self.match(sqlParser.GROUP)
                self.state = 1850
                self.match(sqlParser.BY)
                self.state = 1851
                localctx._expression = self.expression()
                localctx.groupingExpressions.append(localctx._expression)
                self.state = 1856
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,223,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 1852
                        self.match(sqlParser.T__3)
                        self.state = 1853
                        localctx._expression = self.expression()
                        localctx.groupingExpressions.append(localctx._expression) 
                    self.state = 1858
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,223,self._ctx)

                self.state = 1876
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,225,self._ctx)
                if la_ == 1:
                    self.state = 1859
                    self.match(sqlParser.WITH)
                    self.state = 1860
                    localctx.kind = self.match(sqlParser.ROLLUP)

                elif la_ == 2:
                    self.state = 1861
                    self.match(sqlParser.WITH)
                    self.state = 1862
                    localctx.kind = self.match(sqlParser.CUBE)

                elif la_ == 3:
                    self.state = 1863
                    localctx.kind = self.match(sqlParser.GROUPING)
                    self.state = 1864
                    self.match(sqlParser.SETS)
                    self.state = 1865
                    self.match(sqlParser.T__1)
                    self.state = 1866
                    self.groupingSet()
                    self.state = 1871
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==sqlParser.T__3:
                        self.state = 1867
                        self.match(sqlParser.T__3)
                        self.state = 1868
                        self.groupingSet()
                        self.state = 1873
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 1874
                    self.match(sqlParser.T__2)


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1878
                self.match(sqlParser.GROUP)
                self.state = 1879
                self.match(sqlParser.BY)
                self.state = 1880
                localctx.kind = self.match(sqlParser.GROUPING)
                self.state = 1881
                self.match(sqlParser.SETS)
                self.state = 1882
                self.match(sqlParser.T__1)
                self.state = 1883
                self.groupingSet()
                self.state = 1888
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==sqlParser.T__3:
                    self.state = 1884
                    self.match(sqlParser.T__3)
                    self.state = 1885
                    self.groupingSet()
                    self.state = 1890
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1891
                self.match(sqlParser.T__2)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GroupingSetContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(sqlParser.ExpressionContext,i)


        def getRuleIndex(self):
            return sqlParser.RULE_groupingSet

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGroupingSet" ):
                return visitor.visitGroupingSet(self)
            else:
                return visitor.visitChildren(self)




    def groupingSet(self):

        localctx = sqlParser.GroupingSetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_groupingSet)
        self._la = 0 # Token type
        try:
            self.state = 1908
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,230,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1895
                self.match(sqlParser.T__1)
                self.state = 1904
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,229,self._ctx)
                if la_ == 1:
                    self.state = 1896
                    self.expression()
                    self.state = 1901
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==sqlParser.T__3:
                        self.state = 1897
                        self.match(sqlParser.T__3)
                        self.state = 1898
                        self.expression()
                        self.state = 1903
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)



                self.state = 1906
                self.match(sqlParser.T__2)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1907
                self.expression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PivotClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.aggregates = None # NamedExpressionSeqContext
            self._pivotValue = None # PivotValueContext
            self.pivotValues = list() # of PivotValueContexts

        def PIVOT(self):
            return self.getToken(sqlParser.PIVOT, 0)

        def FOR(self):
            return self.getToken(sqlParser.FOR, 0)

        def pivotColumn(self):
            return self.getTypedRuleContext(sqlParser.PivotColumnContext,0)


        def IN(self):
            return self.getToken(sqlParser.IN, 0)

        def namedExpressionSeq(self):
            return self.getTypedRuleContext(sqlParser.NamedExpressionSeqContext,0)


        def pivotValue(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.PivotValueContext)
            else:
                return self.getTypedRuleContext(sqlParser.PivotValueContext,i)


        def getRuleIndex(self):
            return sqlParser.RULE_pivotClause

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPivotClause" ):
                return visitor.visitPivotClause(self)
            else:
                return visitor.visitChildren(self)




    def pivotClause(self):

        localctx = sqlParser.PivotClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_pivotClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1910
            self.match(sqlParser.PIVOT)
            self.state = 1911
            self.match(sqlParser.T__1)
            self.state = 1912
            localctx.aggregates = self.namedExpressionSeq()
            self.state = 1913
            self.match(sqlParser.FOR)
            self.state = 1914
            self.pivotColumn()
            self.state = 1915
            self.match(sqlParser.IN)
            self.state = 1916
            self.match(sqlParser.T__1)
            self.state = 1917
            localctx._pivotValue = self.pivotValue()
            localctx.pivotValues.append(localctx._pivotValue)
            self.state = 1922
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==sqlParser.T__3:
                self.state = 1918
                self.match(sqlParser.T__3)
                self.state = 1919
                localctx._pivotValue = self.pivotValue()
                localctx.pivotValues.append(localctx._pivotValue)
                self.state = 1924
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1925
            self.match(sqlParser.T__2)
            self.state = 1926
            self.match(sqlParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PivotColumnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._identifier = None # IdentifierContext
            self.identifiers = list() # of IdentifierContexts

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(sqlParser.IdentifierContext,i)


        def getRuleIndex(self):
            return sqlParser.RULE_pivotColumn

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPivotColumn" ):
                return visitor.visitPivotColumn(self)
            else:
                return visitor.visitChildren(self)




    def pivotColumn(self):

        localctx = sqlParser.PivotColumnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_pivotColumn)
        self._la = 0 # Token type
        try:
            self.state = 1940
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,233,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1928
                localctx._identifier = self.identifier()
                localctx.identifiers.append(localctx._identifier)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1929
                self.match(sqlParser.T__1)
                self.state = 1930
                localctx._identifier = self.identifier()
                localctx.identifiers.append(localctx._identifier)
                self.state = 1935
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==sqlParser.T__3:
                    self.state = 1931
                    self.match(sqlParser.T__3)
                    self.state = 1932
                    localctx._identifier = self.identifier()
                    localctx.identifiers.append(localctx._identifier)
                    self.state = 1937
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1938
                self.match(sqlParser.T__2)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PivotValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(sqlParser.ExpressionContext,0)


        def identifier(self):
            return self.getTypedRuleContext(sqlParser.IdentifierContext,0)


        def AS(self):
            return self.getToken(sqlParser.AS, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_pivotValue

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPivotValue" ):
                return visitor.visitPivotValue(self)
            else:
                return visitor.visitChildren(self)




    def pivotValue(self):

        localctx = sqlParser.PivotValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_pivotValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1942
            self.expression()
            self.state = 1947
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,235,self._ctx)
            if la_ == 1:
                self.state = 1944
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,234,self._ctx)
                if la_ == 1:
                    self.state = 1943
                    self.match(sqlParser.AS)


                self.state = 1946
                self.identifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LateralViewContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.tblName = None # IdentifierContext
            self._identifier = None # IdentifierContext
            self.colName = list() # of IdentifierContexts

        def LATERAL(self):
            return self.getToken(sqlParser.LATERAL, 0)

        def VIEW(self):
            return self.getToken(sqlParser.VIEW, 0)

        def qualifiedName(self):
            return self.getTypedRuleContext(sqlParser.QualifiedNameContext,0)


        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(sqlParser.IdentifierContext,i)


        def OUTER(self):
            return self.getToken(sqlParser.OUTER, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(sqlParser.ExpressionContext,i)


        def AS(self):
            return self.getToken(sqlParser.AS, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_lateralView

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLateralView" ):
                return visitor.visitLateralView(self)
            else:
                return visitor.visitChildren(self)




    def lateralView(self):

        localctx = sqlParser.LateralViewContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_lateralView)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1949
            self.match(sqlParser.LATERAL)
            self.state = 1950
            self.match(sqlParser.VIEW)
            self.state = 1952
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,236,self._ctx)
            if la_ == 1:
                self.state = 1951
                self.match(sqlParser.OUTER)


            self.state = 1954
            self.qualifiedName()
            self.state = 1955
            self.match(sqlParser.T__1)
            self.state = 1964
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,238,self._ctx)
            if la_ == 1:
                self.state = 1956
                self.expression()
                self.state = 1961
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==sqlParser.T__3:
                    self.state = 1957
                    self.match(sqlParser.T__3)
                    self.state = 1958
                    self.expression()
                    self.state = 1963
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 1966
            self.match(sqlParser.T__2)
            self.state = 1967
            localctx.tblName = self.identifier()
            self.state = 1979
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,241,self._ctx)
            if la_ == 1:
                self.state = 1969
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,239,self._ctx)
                if la_ == 1:
                    self.state = 1968
                    self.match(sqlParser.AS)


                self.state = 1971
                localctx._identifier = self.identifier()
                localctx.colName.append(localctx._identifier)
                self.state = 1976
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,240,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 1972
                        self.match(sqlParser.T__3)
                        self.state = 1973
                        localctx._identifier = self.identifier()
                        localctx.colName.append(localctx._identifier) 
                    self.state = 1978
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,240,self._ctx)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetQuantifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DISTINCT(self):
            return self.getToken(sqlParser.DISTINCT, 0)

        def ALL(self):
            return self.getToken(sqlParser.ALL, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_setQuantifier

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSetQuantifier" ):
                return visitor.visitSetQuantifier(self)
            else:
                return visitor.visitChildren(self)




    def setQuantifier(self):

        localctx = sqlParser.SetQuantifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_setQuantifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1981
            _la = self._input.LA(1)
            if not(_la==sqlParser.ALL or _la==sqlParser.DISTINCT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RelationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def relationPrimary(self):
            return self.getTypedRuleContext(sqlParser.RelationPrimaryContext,0)


        def joinRelation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.JoinRelationContext)
            else:
                return self.getTypedRuleContext(sqlParser.JoinRelationContext,i)


        def getRuleIndex(self):
            return sqlParser.RULE_relation

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRelation" ):
                return visitor.visitRelation(self)
            else:
                return visitor.visitChildren(self)




    def relation(self):

        localctx = sqlParser.RelationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_relation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1983
            self.relationPrimary()
            self.state = 1987
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,242,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1984
                    self.joinRelation() 
                self.state = 1989
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,242,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class JoinRelationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.right = None # RelationPrimaryContext

        def JOIN(self):
            return self.getToken(sqlParser.JOIN, 0)

        def relationPrimary(self):
            return self.getTypedRuleContext(sqlParser.RelationPrimaryContext,0)


        def joinType(self):
            return self.getTypedRuleContext(sqlParser.JoinTypeContext,0)


        def joinCriteria(self):
            return self.getTypedRuleContext(sqlParser.JoinCriteriaContext,0)


        def NATURAL(self):
            return self.getToken(sqlParser.NATURAL, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_joinRelation

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJoinRelation" ):
                return visitor.visitJoinRelation(self)
            else:
                return visitor.visitChildren(self)




    def joinRelation(self):

        localctx = sqlParser.JoinRelationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_joinRelation)
        try:
            self.state = 2001
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [sqlParser.ANTI, sqlParser.CROSS, sqlParser.FULL, sqlParser.INNER, sqlParser.JOIN, sqlParser.LEFT, sqlParser.RIGHT, sqlParser.SEMI]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1990
                self.joinType()
                self.state = 1991
                self.match(sqlParser.JOIN)
                self.state = 1992
                localctx.right = self.relationPrimary()
                self.state = 1994
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,243,self._ctx)
                if la_ == 1:
                    self.state = 1993
                    self.joinCriteria()


                pass
            elif token in [sqlParser.NATURAL]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1996
                self.match(sqlParser.NATURAL)
                self.state = 1997
                self.joinType()
                self.state = 1998
                self.match(sqlParser.JOIN)
                self.state = 1999
                localctx.right = self.relationPrimary()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class JoinTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INNER(self):
            return self.getToken(sqlParser.INNER, 0)

        def CROSS(self):
            return self.getToken(sqlParser.CROSS, 0)

        def LEFT(self):
            return self.getToken(sqlParser.LEFT, 0)

        def OUTER(self):
            return self.getToken(sqlParser.OUTER, 0)

        def SEMI(self):
            return self.getToken(sqlParser.SEMI, 0)

        def RIGHT(self):
            return self.getToken(sqlParser.RIGHT, 0)

        def FULL(self):
            return self.getToken(sqlParser.FULL, 0)

        def ANTI(self):
            return self.getToken(sqlParser.ANTI, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_joinType

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJoinType" ):
                return visitor.visitJoinType(self)
            else:
                return visitor.visitChildren(self)




    def joinType(self):

        localctx = sqlParser.JoinTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_joinType)
        self._la = 0 # Token type
        try:
            self.state = 2027
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,251,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2004
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.INNER:
                    self.state = 2003
                    self.match(sqlParser.INNER)


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2006
                self.match(sqlParser.CROSS)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2007
                self.match(sqlParser.LEFT)
                self.state = 2009
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.OUTER:
                    self.state = 2008
                    self.match(sqlParser.OUTER)


                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2012
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.LEFT:
                    self.state = 2011
                    self.match(sqlParser.LEFT)


                self.state = 2014
                self.match(sqlParser.SEMI)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 2015
                self.match(sqlParser.RIGHT)
                self.state = 2017
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.OUTER:
                    self.state = 2016
                    self.match(sqlParser.OUTER)


                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 2019
                self.match(sqlParser.FULL)
                self.state = 2021
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.OUTER:
                    self.state = 2020
                    self.match(sqlParser.OUTER)


                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 2024
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.LEFT:
                    self.state = 2023
                    self.match(sqlParser.LEFT)


                self.state = 2026
                self.match(sqlParser.ANTI)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class JoinCriteriaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ON(self):
            return self.getToken(sqlParser.ON, 0)

        def booleanExpression(self):
            return self.getTypedRuleContext(sqlParser.BooleanExpressionContext,0)


        def USING(self):
            return self.getToken(sqlParser.USING, 0)

        def identifierList(self):
            return self.getTypedRuleContext(sqlParser.IdentifierListContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_joinCriteria

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJoinCriteria" ):
                return visitor.visitJoinCriteria(self)
            else:
                return visitor.visitChildren(self)




    def joinCriteria(self):

        localctx = sqlParser.JoinCriteriaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_joinCriteria)
        try:
            self.state = 2033
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [sqlParser.ON]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2029
                self.match(sqlParser.ON)
                self.state = 2030
                self.booleanExpression(0)
                pass
            elif token in [sqlParser.USING]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2031
                self.match(sqlParser.USING)
                self.state = 2032
                self.identifierList()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SampleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TABLESAMPLE(self):
            return self.getToken(sqlParser.TABLESAMPLE, 0)

        def sampleMethod(self):
            return self.getTypedRuleContext(sqlParser.SampleMethodContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_sample

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSample" ):
                return visitor.visitSample(self)
            else:
                return visitor.visitChildren(self)




    def sample(self):

        localctx = sqlParser.SampleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_sample)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2035
            self.match(sqlParser.TABLESAMPLE)
            self.state = 2036
            self.match(sqlParser.T__1)
            self.state = 2038
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,253,self._ctx)
            if la_ == 1:
                self.state = 2037
                self.sampleMethod()


            self.state = 2040
            self.match(sqlParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SampleMethodContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return sqlParser.RULE_sampleMethod

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class SampleByRowsContext(SampleMethodContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.SampleMethodContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self):
            return self.getTypedRuleContext(sqlParser.ExpressionContext,0)

        def ROWS(self):
            return self.getToken(sqlParser.ROWS, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSampleByRows" ):
                return visitor.visitSampleByRows(self)
            else:
                return visitor.visitChildren(self)


    class SampleByPercentileContext(SampleMethodContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.SampleMethodContext
            super().__init__(parser)
            self.negativeSign = None # Token
            self.percentage = None # Token
            self.copyFrom(ctx)

        def PERCENTLIT(self):
            return self.getToken(sqlParser.PERCENTLIT, 0)
        def INTEGER_VALUE(self):
            return self.getToken(sqlParser.INTEGER_VALUE, 0)
        def DECIMAL_VALUE(self):
            return self.getToken(sqlParser.DECIMAL_VALUE, 0)
        def MINUS(self):
            return self.getToken(sqlParser.MINUS, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSampleByPercentile" ):
                return visitor.visitSampleByPercentile(self)
            else:
                return visitor.visitChildren(self)


    class SampleByBucketContext(SampleMethodContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.SampleMethodContext
            super().__init__(parser)
            self.sampleType = None # Token
            self.numerator = None # Token
            self.denominator = None # Token
            self.copyFrom(ctx)

        def OUT(self):
            return self.getToken(sqlParser.OUT, 0)
        def OF(self):
            return self.getToken(sqlParser.OF, 0)
        def BUCKET(self):
            return self.getToken(sqlParser.BUCKET, 0)
        def INTEGER_VALUE(self, i:int=None):
            if i is None:
                return self.getTokens(sqlParser.INTEGER_VALUE)
            else:
                return self.getToken(sqlParser.INTEGER_VALUE, i)
        def ON(self):
            return self.getToken(sqlParser.ON, 0)
        def identifier(self):
            return self.getTypedRuleContext(sqlParser.IdentifierContext,0)

        def qualifiedName(self):
            return self.getTypedRuleContext(sqlParser.QualifiedNameContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSampleByBucket" ):
                return visitor.visitSampleByBucket(self)
            else:
                return visitor.visitChildren(self)


    class SampleByBytesContext(SampleMethodContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.SampleMethodContext
            super().__init__(parser)
            self.bytes = None # ExpressionContext
            self.copyFrom(ctx)

        def expression(self):
            return self.getTypedRuleContext(sqlParser.ExpressionContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSampleByBytes" ):
                return visitor.visitSampleByBytes(self)
            else:
                return visitor.visitChildren(self)



    def sampleMethod(self):

        localctx = sqlParser.SampleMethodContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_sampleMethod)
        self._la = 0 # Token type
        try:
            self.state = 2066
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,257,self._ctx)
            if la_ == 1:
                localctx = sqlParser.SampleByPercentileContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 2043
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.MINUS:
                    self.state = 2042
                    localctx.negativeSign = self.match(sqlParser.MINUS)


                self.state = 2045
                localctx.percentage = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==sqlParser.INTEGER_VALUE or _la==sqlParser.DECIMAL_VALUE):
                    localctx.percentage = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2046
                self.match(sqlParser.PERCENTLIT)
                pass

            elif la_ == 2:
                localctx = sqlParser.SampleByRowsContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 2047
                self.expression()
                self.state = 2048
                self.match(sqlParser.ROWS)
                pass

            elif la_ == 3:
                localctx = sqlParser.SampleByBucketContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 2050
                localctx.sampleType = self.match(sqlParser.BUCKET)
                self.state = 2051
                localctx.numerator = self.match(sqlParser.INTEGER_VALUE)
                self.state = 2052
                self.match(sqlParser.OUT)
                self.state = 2053
                self.match(sqlParser.OF)
                self.state = 2054
                localctx.denominator = self.match(sqlParser.INTEGER_VALUE)
                self.state = 2063
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.ON:
                    self.state = 2055
                    self.match(sqlParser.ON)
                    self.state = 2061
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,255,self._ctx)
                    if la_ == 1:
                        self.state = 2056
                        self.identifier()
                        pass

                    elif la_ == 2:
                        self.state = 2057
                        self.qualifiedName()
                        self.state = 2058
                        self.match(sqlParser.T__1)
                        self.state = 2059
                        self.match(sqlParser.T__2)
                        pass




                pass

            elif la_ == 4:
                localctx = sqlParser.SampleByBytesContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 2065
                localctx.bytes = self.expression()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierSeq(self):
            return self.getTypedRuleContext(sqlParser.IdentifierSeqContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_identifierList

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifierList" ):
                return visitor.visitIdentifierList(self)
            else:
                return visitor.visitChildren(self)




    def identifierList(self):

        localctx = sqlParser.IdentifierListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_identifierList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2068
            self.match(sqlParser.T__1)
            self.state = 2069
            self.identifierSeq()
            self.state = 2070
            self.match(sqlParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierSeqContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._errorCapturingIdentifier = None # ErrorCapturingIdentifierContext
            self.ident = list() # of ErrorCapturingIdentifierContexts

        def errorCapturingIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.ErrorCapturingIdentifierContext)
            else:
                return self.getTypedRuleContext(sqlParser.ErrorCapturingIdentifierContext,i)


        def getRuleIndex(self):
            return sqlParser.RULE_identifierSeq

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifierSeq" ):
                return visitor.visitIdentifierSeq(self)
            else:
                return visitor.visitChildren(self)




    def identifierSeq(self):

        localctx = sqlParser.IdentifierSeqContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_identifierSeq)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2072
            localctx._errorCapturingIdentifier = self.errorCapturingIdentifier()
            localctx.ident.append(localctx._errorCapturingIdentifier)
            self.state = 2077
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,258,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 2073
                    self.match(sqlParser.T__3)
                    self.state = 2074
                    localctx._errorCapturingIdentifier = self.errorCapturingIdentifier()
                    localctx.ident.append(localctx._errorCapturingIdentifier) 
                self.state = 2079
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,258,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderedIdentifierListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def orderedIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.OrderedIdentifierContext)
            else:
                return self.getTypedRuleContext(sqlParser.OrderedIdentifierContext,i)


        def getRuleIndex(self):
            return sqlParser.RULE_orderedIdentifierList

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOrderedIdentifierList" ):
                return visitor.visitOrderedIdentifierList(self)
            else:
                return visitor.visitChildren(self)




    def orderedIdentifierList(self):

        localctx = sqlParser.OrderedIdentifierListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_orderedIdentifierList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2080
            self.match(sqlParser.T__1)
            self.state = 2081
            self.orderedIdentifier()
            self.state = 2086
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==sqlParser.T__3:
                self.state = 2082
                self.match(sqlParser.T__3)
                self.state = 2083
                self.orderedIdentifier()
                self.state = 2088
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2089
            self.match(sqlParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderedIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ident = None # ErrorCapturingIdentifierContext
            self.ordering = None # Token

        def errorCapturingIdentifier(self):
            return self.getTypedRuleContext(sqlParser.ErrorCapturingIdentifierContext,0)


        def ASC(self):
            return self.getToken(sqlParser.ASC, 0)

        def DESC(self):
            return self.getToken(sqlParser.DESC, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_orderedIdentifier

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOrderedIdentifier" ):
                return visitor.visitOrderedIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def orderedIdentifier(self):

        localctx = sqlParser.OrderedIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_orderedIdentifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2091
            localctx.ident = self.errorCapturingIdentifier()
            self.state = 2093
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==sqlParser.ASC or _la==sqlParser.DESC:
                self.state = 2092
                localctx.ordering = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==sqlParser.ASC or _la==sqlParser.DESC):
                    localctx.ordering = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierCommentListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierComment(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.IdentifierCommentContext)
            else:
                return self.getTypedRuleContext(sqlParser.IdentifierCommentContext,i)


        def getRuleIndex(self):
            return sqlParser.RULE_identifierCommentList

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifierCommentList" ):
                return visitor.visitIdentifierCommentList(self)
            else:
                return visitor.visitChildren(self)




    def identifierCommentList(self):

        localctx = sqlParser.IdentifierCommentListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_identifierCommentList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2095
            self.match(sqlParser.T__1)
            self.state = 2096
            self.identifierComment()
            self.state = 2101
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==sqlParser.T__3:
                self.state = 2097
                self.match(sqlParser.T__3)
                self.state = 2098
                self.identifierComment()
                self.state = 2103
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2104
            self.match(sqlParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierCommentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(sqlParser.IdentifierContext,0)


        def commentSpec(self):
            return self.getTypedRuleContext(sqlParser.CommentSpecContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_identifierComment

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifierComment" ):
                return visitor.visitIdentifierComment(self)
            else:
                return visitor.visitChildren(self)




    def identifierComment(self):

        localctx = sqlParser.IdentifierCommentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_identifierComment)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2106
            self.identifier()
            self.state = 2108
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==sqlParser.COMMENT:
                self.state = 2107
                self.commentSpec()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RelationPrimaryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return sqlParser.RULE_relationPrimary

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class AliasedRelationContext(RelationPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.RelationPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def relation(self):
            return self.getTypedRuleContext(sqlParser.RelationContext,0)

        def tableAlias(self):
            return self.getTypedRuleContext(sqlParser.TableAliasContext,0)

        def sample(self):
            return self.getTypedRuleContext(sqlParser.SampleContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAliasedRelation" ):
                return visitor.visitAliasedRelation(self)
            else:
                return visitor.visitChildren(self)


    class AliasedQueryContext(RelationPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.RelationPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def query(self):
            return self.getTypedRuleContext(sqlParser.QueryContext,0)

        def tableAlias(self):
            return self.getTypedRuleContext(sqlParser.TableAliasContext,0)

        def sample(self):
            return self.getTypedRuleContext(sqlParser.SampleContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAliasedQuery" ):
                return visitor.visitAliasedQuery(self)
            else:
                return visitor.visitChildren(self)


    class TableNameContext(RelationPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.RelationPrimaryContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)

        def tableAlias(self):
            return self.getTypedRuleContext(sqlParser.TableAliasContext,0)

        def sample(self):
            return self.getTypedRuleContext(sqlParser.SampleContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableName" ):
                return visitor.visitTableName(self)
            else:
                return visitor.visitChildren(self)



    def relationPrimary(self):

        localctx = sqlParser.RelationPrimaryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_relationPrimary)
        try:
            self.state = 2132
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,266,self._ctx)
            if la_ == 1:
                localctx = sqlParser.TableNameContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 2110
                self.multipartIdentifier()
                self.state = 2112
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,263,self._ctx)
                if la_ == 1:
                    self.state = 2111
                    self.sample()


                self.state = 2114
                self.tableAlias()
                pass

            elif la_ == 2:
                localctx = sqlParser.AliasedQueryContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 2116
                self.match(sqlParser.T__1)
                self.state = 2117
                self.query()
                self.state = 2118
                self.match(sqlParser.T__2)
                self.state = 2120
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,264,self._ctx)
                if la_ == 1:
                    self.state = 2119
                    self.sample()


                self.state = 2122
                self.tableAlias()
                pass

            elif la_ == 3:
                localctx = sqlParser.AliasedRelationContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 2124
                self.match(sqlParser.T__1)
                self.state = 2125
                self.relation()
                self.state = 2126
                self.match(sqlParser.T__2)
                self.state = 2128
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,265,self._ctx)
                if la_ == 1:
                    self.state = 2127
                    self.sample()


                self.state = 2130
                self.tableAlias()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InlineTableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VALUES(self):
            return self.getToken(sqlParser.VALUES, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(sqlParser.ExpressionContext,i)


        def tableAlias(self):
            return self.getTypedRuleContext(sqlParser.TableAliasContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_inlineTable

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInlineTable" ):
                return visitor.visitInlineTable(self)
            else:
                return visitor.visitChildren(self)




    def inlineTable(self):

        localctx = sqlParser.InlineTableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_inlineTable)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2134
            self.match(sqlParser.VALUES)
            self.state = 2135
            self.expression()
            self.state = 2140
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,267,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 2136
                    self.match(sqlParser.T__3)
                    self.state = 2137
                    self.expression() 
                self.state = 2142
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,267,self._ctx)

            self.state = 2143
            self.tableAlias()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionTableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.funcName = None # ErrorCapturingIdentifierContext

        def tableAlias(self):
            return self.getTypedRuleContext(sqlParser.TableAliasContext,0)


        def errorCapturingIdentifier(self):
            return self.getTypedRuleContext(sqlParser.ErrorCapturingIdentifierContext,0)


        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(sqlParser.ExpressionContext,i)


        def getRuleIndex(self):
            return sqlParser.RULE_functionTable

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionTable" ):
                return visitor.visitFunctionTable(self)
            else:
                return visitor.visitChildren(self)




    def functionTable(self):

        localctx = sqlParser.FunctionTableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_functionTable)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2145
            localctx.funcName = self.errorCapturingIdentifier()
            self.state = 2146
            self.match(sqlParser.T__1)
            self.state = 2155
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,269,self._ctx)
            if la_ == 1:
                self.state = 2147
                self.expression()
                self.state = 2152
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==sqlParser.T__3:
                    self.state = 2148
                    self.match(sqlParser.T__3)
                    self.state = 2149
                    self.expression()
                    self.state = 2154
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 2157
            self.match(sqlParser.T__2)
            self.state = 2158
            self.tableAlias()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TableAliasContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def strictIdentifier(self):
            return self.getTypedRuleContext(sqlParser.StrictIdentifierContext,0)


        def AS(self):
            return self.getToken(sqlParser.AS, 0)

        def identifierList(self):
            return self.getTypedRuleContext(sqlParser.IdentifierListContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_tableAlias

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableAlias" ):
                return visitor.visitTableAlias(self)
            else:
                return visitor.visitChildren(self)




    def tableAlias(self):

        localctx = sqlParser.TableAliasContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_tableAlias)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2167
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,272,self._ctx)
            if la_ == 1:
                self.state = 2161
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,270,self._ctx)
                if la_ == 1:
                    self.state = 2160
                    self.match(sqlParser.AS)


                self.state = 2163
                self.strictIdentifier()
                self.state = 2165
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,271,self._ctx)
                if la_ == 1:
                    self.state = 2164
                    self.identifierList()




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RowFormatContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return sqlParser.RULE_rowFormat

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RowFormatSerdeContext(RowFormatContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.RowFormatContext
            super().__init__(parser)
            self.name = None # Token
            self.props = None # TablePropertyListContext
            self.copyFrom(ctx)

        def ROW(self):
            return self.getToken(sqlParser.ROW, 0)
        def FORMAT(self):
            return self.getToken(sqlParser.FORMAT, 0)
        def SERDE(self):
            return self.getToken(sqlParser.SERDE, 0)
        def STRING(self):
            return self.getToken(sqlParser.STRING, 0)
        def WITH(self):
            return self.getToken(sqlParser.WITH, 0)
        def SERDEPROPERTIES(self):
            return self.getToken(sqlParser.SERDEPROPERTIES, 0)
        def tablePropertyList(self):
            return self.getTypedRuleContext(sqlParser.TablePropertyListContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRowFormatSerde" ):
                return visitor.visitRowFormatSerde(self)
            else:
                return visitor.visitChildren(self)


    class RowFormatDelimitedContext(RowFormatContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.RowFormatContext
            super().__init__(parser)
            self.fieldsTerminatedBy = None # Token
            self.escapedBy = None # Token
            self.collectionItemsTerminatedBy = None # Token
            self.keysTerminatedBy = None # Token
            self.linesSeparatedBy = None # Token
            self.nullDefinedAs = None # Token
            self.copyFrom(ctx)

        def ROW(self):
            return self.getToken(sqlParser.ROW, 0)
        def FORMAT(self):
            return self.getToken(sqlParser.FORMAT, 0)
        def DELIMITED(self):
            return self.getToken(sqlParser.DELIMITED, 0)
        def FIELDS(self):
            return self.getToken(sqlParser.FIELDS, 0)
        def TERMINATED(self, i:int=None):
            if i is None:
                return self.getTokens(sqlParser.TERMINATED)
            else:
                return self.getToken(sqlParser.TERMINATED, i)
        def BY(self, i:int=None):
            if i is None:
                return self.getTokens(sqlParser.BY)
            else:
                return self.getToken(sqlParser.BY, i)
        def COLLECTION(self):
            return self.getToken(sqlParser.COLLECTION, 0)
        def ITEMS(self):
            return self.getToken(sqlParser.ITEMS, 0)
        def MAP(self):
            return self.getToken(sqlParser.MAP, 0)
        def KEYS(self):
            return self.getToken(sqlParser.KEYS, 0)
        def LINES(self):
            return self.getToken(sqlParser.LINES, 0)
        def NULL(self):
            return self.getToken(sqlParser.NULL, 0)
        def DEFINED(self):
            return self.getToken(sqlParser.DEFINED, 0)
        def AS(self):
            return self.getToken(sqlParser.AS, 0)
        def STRING(self, i:int=None):
            if i is None:
                return self.getTokens(sqlParser.STRING)
            else:
                return self.getToken(sqlParser.STRING, i)
        def ESCAPED(self):
            return self.getToken(sqlParser.ESCAPED, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRowFormatDelimited" ):
                return visitor.visitRowFormatDelimited(self)
            else:
                return visitor.visitChildren(self)



    def rowFormat(self):

        localctx = sqlParser.RowFormatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_rowFormat)
        try:
            self.state = 2218
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,280,self._ctx)
            if la_ == 1:
                localctx = sqlParser.RowFormatSerdeContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 2169
                self.match(sqlParser.ROW)
                self.state = 2170
                self.match(sqlParser.FORMAT)
                self.state = 2171
                self.match(sqlParser.SERDE)
                self.state = 2172
                localctx.name = self.match(sqlParser.STRING)
                self.state = 2176
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,273,self._ctx)
                if la_ == 1:
                    self.state = 2173
                    self.match(sqlParser.WITH)
                    self.state = 2174
                    self.match(sqlParser.SERDEPROPERTIES)
                    self.state = 2175
                    localctx.props = self.tablePropertyList()


                pass

            elif la_ == 2:
                localctx = sqlParser.RowFormatDelimitedContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 2178
                self.match(sqlParser.ROW)
                self.state = 2179
                self.match(sqlParser.FORMAT)
                self.state = 2180
                self.match(sqlParser.DELIMITED)
                self.state = 2190
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,275,self._ctx)
                if la_ == 1:
                    self.state = 2181
                    self.match(sqlParser.FIELDS)
                    self.state = 2182
                    self.match(sqlParser.TERMINATED)
                    self.state = 2183
                    self.match(sqlParser.BY)
                    self.state = 2184
                    localctx.fieldsTerminatedBy = self.match(sqlParser.STRING)
                    self.state = 2188
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,274,self._ctx)
                    if la_ == 1:
                        self.state = 2185
                        self.match(sqlParser.ESCAPED)
                        self.state = 2186
                        self.match(sqlParser.BY)
                        self.state = 2187
                        localctx.escapedBy = self.match(sqlParser.STRING)




                self.state = 2197
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,276,self._ctx)
                if la_ == 1:
                    self.state = 2192
                    self.match(sqlParser.COLLECTION)
                    self.state = 2193
                    self.match(sqlParser.ITEMS)
                    self.state = 2194
                    self.match(sqlParser.TERMINATED)
                    self.state = 2195
                    self.match(sqlParser.BY)
                    self.state = 2196
                    localctx.collectionItemsTerminatedBy = self.match(sqlParser.STRING)


                self.state = 2204
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,277,self._ctx)
                if la_ == 1:
                    self.state = 2199
                    self.match(sqlParser.MAP)
                    self.state = 2200
                    self.match(sqlParser.KEYS)
                    self.state = 2201
                    self.match(sqlParser.TERMINATED)
                    self.state = 2202
                    self.match(sqlParser.BY)
                    self.state = 2203
                    localctx.keysTerminatedBy = self.match(sqlParser.STRING)


                self.state = 2210
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,278,self._ctx)
                if la_ == 1:
                    self.state = 2206
                    self.match(sqlParser.LINES)
                    self.state = 2207
                    self.match(sqlParser.TERMINATED)
                    self.state = 2208
                    self.match(sqlParser.BY)
                    self.state = 2209
                    localctx.linesSeparatedBy = self.match(sqlParser.STRING)


                self.state = 2216
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,279,self._ctx)
                if la_ == 1:
                    self.state = 2212
                    self.match(sqlParser.NULL)
                    self.state = 2213
                    self.match(sqlParser.DEFINED)
                    self.state = 2214
                    self.match(sqlParser.AS)
                    self.state = 2215
                    localctx.nullDefinedAs = self.match(sqlParser.STRING)


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultipartIdentifierListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def multipartIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.MultipartIdentifierContext)
            else:
                return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,i)


        def getRuleIndex(self):
            return sqlParser.RULE_multipartIdentifierList

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultipartIdentifierList" ):
                return visitor.visitMultipartIdentifierList(self)
            else:
                return visitor.visitChildren(self)




    def multipartIdentifierList(self):

        localctx = sqlParser.MultipartIdentifierListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_multipartIdentifierList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2220
            self.multipartIdentifier()
            self.state = 2225
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==sqlParser.T__3:
                self.state = 2221
                self.match(sqlParser.T__3)
                self.state = 2222
                self.multipartIdentifier()
                self.state = 2227
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultipartIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._errorCapturingIdentifier = None # ErrorCapturingIdentifierContext
            self.parts = list() # of ErrorCapturingIdentifierContexts

        def errorCapturingIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.ErrorCapturingIdentifierContext)
            else:
                return self.getTypedRuleContext(sqlParser.ErrorCapturingIdentifierContext,i)


        def getRuleIndex(self):
            return sqlParser.RULE_multipartIdentifier

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultipartIdentifier" ):
                return visitor.visitMultipartIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def multipartIdentifier(self):

        localctx = sqlParser.MultipartIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_multipartIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2228
            localctx._errorCapturingIdentifier = self.errorCapturingIdentifier()
            localctx.parts.append(localctx._errorCapturingIdentifier)
            self.state = 2233
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,282,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 2229
                    self.match(sqlParser.T__4)
                    self.state = 2230
                    localctx._errorCapturingIdentifier = self.errorCapturingIdentifier()
                    localctx.parts.append(localctx._errorCapturingIdentifier) 
                self.state = 2235
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,282,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TableIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.db = None # ErrorCapturingIdentifierContext
            self.table = None # ErrorCapturingIdentifierContext

        def errorCapturingIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.ErrorCapturingIdentifierContext)
            else:
                return self.getTypedRuleContext(sqlParser.ErrorCapturingIdentifierContext,i)


        def getRuleIndex(self):
            return sqlParser.RULE_tableIdentifier

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTableIdentifier" ):
                return visitor.visitTableIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def tableIdentifier(self):

        localctx = sqlParser.TableIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_tableIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2239
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,283,self._ctx)
            if la_ == 1:
                self.state = 2236
                localctx.db = self.errorCapturingIdentifier()
                self.state = 2237
                self.match(sqlParser.T__4)


            self.state = 2241
            localctx.table = self.errorCapturingIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.db = None # ErrorCapturingIdentifierContext
            self.function = None # ErrorCapturingIdentifierContext

        def errorCapturingIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.ErrorCapturingIdentifierContext)
            else:
                return self.getTypedRuleContext(sqlParser.ErrorCapturingIdentifierContext,i)


        def getRuleIndex(self):
            return sqlParser.RULE_functionIdentifier

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionIdentifier" ):
                return visitor.visitFunctionIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def functionIdentifier(self):

        localctx = sqlParser.FunctionIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 174, self.RULE_functionIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2246
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,284,self._ctx)
            if la_ == 1:
                self.state = 2243
                localctx.db = self.errorCapturingIdentifier()
                self.state = 2244
                self.match(sqlParser.T__4)


            self.state = 2248
            localctx.function = self.errorCapturingIdentifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NamedExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # ErrorCapturingIdentifierContext

        def expression(self):
            return self.getTypedRuleContext(sqlParser.ExpressionContext,0)


        def identifierList(self):
            return self.getTypedRuleContext(sqlParser.IdentifierListContext,0)


        def AS(self):
            return self.getToken(sqlParser.AS, 0)

        def errorCapturingIdentifier(self):
            return self.getTypedRuleContext(sqlParser.ErrorCapturingIdentifierContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_namedExpression

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNamedExpression" ):
                return visitor.visitNamedExpression(self)
            else:
                return visitor.visitChildren(self)




    def namedExpression(self):

        localctx = sqlParser.NamedExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 176, self.RULE_namedExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2250
            self.expression()
            self.state = 2258
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,287,self._ctx)
            if la_ == 1:
                self.state = 2252
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,285,self._ctx)
                if la_ == 1:
                    self.state = 2251
                    self.match(sqlParser.AS)


                self.state = 2256
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,286,self._ctx)
                if la_ == 1:
                    self.state = 2254
                    localctx.name = self.errorCapturingIdentifier()
                    pass

                elif la_ == 2:
                    self.state = 2255
                    self.identifierList()
                    pass




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NamedExpressionSeqContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def namedExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.NamedExpressionContext)
            else:
                return self.getTypedRuleContext(sqlParser.NamedExpressionContext,i)


        def getRuleIndex(self):
            return sqlParser.RULE_namedExpressionSeq

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNamedExpressionSeq" ):
                return visitor.visitNamedExpressionSeq(self)
            else:
                return visitor.visitChildren(self)




    def namedExpressionSeq(self):

        localctx = sqlParser.NamedExpressionSeqContext(self, self._ctx, self.state)
        self.enterRule(localctx, 178, self.RULE_namedExpressionSeq)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2260
            self.namedExpression()
            self.state = 2265
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,288,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 2261
                    self.match(sqlParser.T__3)
                    self.state = 2262
                    self.namedExpression() 
                self.state = 2267
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,288,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TransformListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._transform = None # TransformContext
            self.transforms = list() # of TransformContexts

        def transform(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.TransformContext)
            else:
                return self.getTypedRuleContext(sqlParser.TransformContext,i)


        def getRuleIndex(self):
            return sqlParser.RULE_transformList

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTransformList" ):
                return visitor.visitTransformList(self)
            else:
                return visitor.visitChildren(self)




    def transformList(self):

        localctx = sqlParser.TransformListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 180, self.RULE_transformList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2268
            self.match(sqlParser.T__1)
            self.state = 2269
            localctx._transform = self.transform()
            localctx.transforms.append(localctx._transform)
            self.state = 2274
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==sqlParser.T__3:
                self.state = 2270
                self.match(sqlParser.T__3)
                self.state = 2271
                localctx._transform = self.transform()
                localctx.transforms.append(localctx._transform)
                self.state = 2276
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2277
            self.match(sqlParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TransformContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return sqlParser.RULE_transform

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class IdentityTransformContext(TransformContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.TransformContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def qualifiedName(self):
            return self.getTypedRuleContext(sqlParser.QualifiedNameContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentityTransform" ):
                return visitor.visitIdentityTransform(self)
            else:
                return visitor.visitChildren(self)


    class ApplyTransformContext(TransformContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.TransformContext
            super().__init__(parser)
            self.transformName = None # IdentifierContext
            self._transformArgument = None # TransformArgumentContext
            self.argument = list() # of TransformArgumentContexts
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(sqlParser.IdentifierContext,0)

        def transformArgument(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.TransformArgumentContext)
            else:
                return self.getTypedRuleContext(sqlParser.TransformArgumentContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitApplyTransform" ):
                return visitor.visitApplyTransform(self)
            else:
                return visitor.visitChildren(self)



    def transform(self):

        localctx = sqlParser.TransformContext(self, self._ctx, self.state)
        self.enterRule(localctx, 182, self.RULE_transform)
        self._la = 0 # Token type
        try:
            self.state = 2292
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,291,self._ctx)
            if la_ == 1:
                localctx = sqlParser.IdentityTransformContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 2279
                self.qualifiedName()
                pass

            elif la_ == 2:
                localctx = sqlParser.ApplyTransformContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 2280
                localctx.transformName = self.identifier()
                self.state = 2281
                self.match(sqlParser.T__1)
                self.state = 2282
                localctx._transformArgument = self.transformArgument()
                localctx.argument.append(localctx._transformArgument)
                self.state = 2287
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==sqlParser.T__3:
                    self.state = 2283
                    self.match(sqlParser.T__3)
                    self.state = 2284
                    localctx._transformArgument = self.transformArgument()
                    localctx.argument.append(localctx._transformArgument)
                    self.state = 2289
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 2290
                self.match(sqlParser.T__2)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TransformArgumentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def qualifiedName(self):
            return self.getTypedRuleContext(sqlParser.QualifiedNameContext,0)


        def constant(self):
            return self.getTypedRuleContext(sqlParser.ConstantContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_transformArgument

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTransformArgument" ):
                return visitor.visitTransformArgument(self)
            else:
                return visitor.visitChildren(self)




    def transformArgument(self):

        localctx = sqlParser.TransformArgumentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 184, self.RULE_transformArgument)
        try:
            self.state = 2296
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,292,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2294
                self.qualifiedName()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2295
                self.constant()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booleanExpression(self):
            return self.getTypedRuleContext(sqlParser.BooleanExpressionContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_expression

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpression" ):
                return visitor.visitExpression(self)
            else:
                return visitor.visitChildren(self)




    def expression(self):

        localctx = sqlParser.ExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 186, self.RULE_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2298
            self.booleanExpression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return sqlParser.RULE_booleanExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class LogicalNotContext(BooleanExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.BooleanExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NOT(self):
            return self.getToken(sqlParser.NOT, 0)
        def booleanExpression(self):
            return self.getTypedRuleContext(sqlParser.BooleanExpressionContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicalNot" ):
                return visitor.visitLogicalNot(self)
            else:
                return visitor.visitChildren(self)


    class PredicatedContext(BooleanExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.BooleanExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def valueExpression(self):
            return self.getTypedRuleContext(sqlParser.ValueExpressionContext,0)

        def predicate(self):
            return self.getTypedRuleContext(sqlParser.PredicateContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPredicated" ):
                return visitor.visitPredicated(self)
            else:
                return visitor.visitChildren(self)


    class ExistsContext(BooleanExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.BooleanExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def EXISTS(self):
            return self.getToken(sqlParser.EXISTS, 0)
        def query(self):
            return self.getTypedRuleContext(sqlParser.QueryContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExists" ):
                return visitor.visitExists(self)
            else:
                return visitor.visitChildren(self)


    class LogicalBinaryContext(BooleanExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.BooleanExpressionContext
            super().__init__(parser)
            self.left = None # BooleanExpressionContext
            self.operator = None # Token
            self.right = None # BooleanExpressionContext
            self.copyFrom(ctx)

        def booleanExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.BooleanExpressionContext)
            else:
                return self.getTypedRuleContext(sqlParser.BooleanExpressionContext,i)

        def AND(self):
            return self.getToken(sqlParser.AND, 0)
        def OR(self):
            return self.getToken(sqlParser.OR, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicalBinary" ):
                return visitor.visitLogicalBinary(self)
            else:
                return visitor.visitChildren(self)



    def booleanExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = sqlParser.BooleanExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 188
        self.enterRecursionRule(localctx, 188, self.RULE_booleanExpression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2312
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,294,self._ctx)
            if la_ == 1:
                localctx = sqlParser.LogicalNotContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 2301
                self.match(sqlParser.NOT)
                self.state = 2302
                self.booleanExpression(5)
                pass

            elif la_ == 2:
                localctx = sqlParser.ExistsContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 2303
                self.match(sqlParser.EXISTS)
                self.state = 2304
                self.match(sqlParser.T__1)
                self.state = 2305
                self.query()
                self.state = 2306
                self.match(sqlParser.T__2)
                pass

            elif la_ == 3:
                localctx = sqlParser.PredicatedContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 2308
                self.valueExpression(0)
                self.state = 2310
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,293,self._ctx)
                if la_ == 1:
                    self.state = 2309
                    self.predicate()


                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 2322
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,296,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 2320
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,295,self._ctx)
                    if la_ == 1:
                        localctx = sqlParser.LogicalBinaryContext(self, sqlParser.BooleanExpressionContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_booleanExpression)
                        self.state = 2314
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 2315
                        localctx.operator = self.match(sqlParser.AND)
                        self.state = 2316
                        localctx.right = self.booleanExpression(3)
                        pass

                    elif la_ == 2:
                        localctx = sqlParser.LogicalBinaryContext(self, sqlParser.BooleanExpressionContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_booleanExpression)
                        self.state = 2317
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 2318
                        localctx.operator = self.match(sqlParser.OR)
                        self.state = 2319
                        localctx.right = self.booleanExpression(2)
                        pass

             
                self.state = 2324
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,296,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class PredicateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.kind = None # Token
            self.lower = None # ValueExpressionContext
            self.upper = None # ValueExpressionContext
            self.pattern = None # ValueExpressionContext
            self.quantifier = None # Token
            self.escapeChar = None # Token
            self.right = None # ValueExpressionContext

        def AND(self):
            return self.getToken(sqlParser.AND, 0)

        def BETWEEN(self):
            return self.getToken(sqlParser.BETWEEN, 0)

        def valueExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.ValueExpressionContext)
            else:
                return self.getTypedRuleContext(sqlParser.ValueExpressionContext,i)


        def NOT(self):
            return self.getToken(sqlParser.NOT, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(sqlParser.ExpressionContext,i)


        def IN(self):
            return self.getToken(sqlParser.IN, 0)

        def query(self):
            return self.getTypedRuleContext(sqlParser.QueryContext,0)


        def RLIKE(self):
            return self.getToken(sqlParser.RLIKE, 0)

        def LIKE(self):
            return self.getToken(sqlParser.LIKE, 0)

        def ANY(self):
            return self.getToken(sqlParser.ANY, 0)

        def SOME(self):
            return self.getToken(sqlParser.SOME, 0)

        def ALL(self):
            return self.getToken(sqlParser.ALL, 0)

        def ESCAPE(self):
            return self.getToken(sqlParser.ESCAPE, 0)

        def STRING(self):
            return self.getToken(sqlParser.STRING, 0)

        def IS(self):
            return self.getToken(sqlParser.IS, 0)

        def NULL(self):
            return self.getToken(sqlParser.NULL, 0)

        def TRUE(self):
            return self.getToken(sqlParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(sqlParser.FALSE, 0)

        def UNKNOWN(self):
            return self.getToken(sqlParser.UNKNOWN, 0)

        def FROM(self):
            return self.getToken(sqlParser.FROM, 0)

        def DISTINCT(self):
            return self.getToken(sqlParser.DISTINCT, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_predicate

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPredicate" ):
                return visitor.visitPredicate(self)
            else:
                return visitor.visitChildren(self)




    def predicate(self):

        localctx = sqlParser.PredicateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 190, self.RULE_predicate)
        self._la = 0 # Token type
        try:
            self.state = 2407
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,310,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2326
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.NOT:
                    self.state = 2325
                    self.match(sqlParser.NOT)


                self.state = 2328
                localctx.kind = self.match(sqlParser.BETWEEN)
                self.state = 2329
                localctx.lower = self.valueExpression(0)
                self.state = 2330
                self.match(sqlParser.AND)
                self.state = 2331
                localctx.upper = self.valueExpression(0)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2334
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.NOT:
                    self.state = 2333
                    self.match(sqlParser.NOT)


                self.state = 2336
                localctx.kind = self.match(sqlParser.IN)
                self.state = 2337
                self.match(sqlParser.T__1)
                self.state = 2338
                self.expression()
                self.state = 2343
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==sqlParser.T__3:
                    self.state = 2339
                    self.match(sqlParser.T__3)
                    self.state = 2340
                    self.expression()
                    self.state = 2345
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 2346
                self.match(sqlParser.T__2)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2349
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.NOT:
                    self.state = 2348
                    self.match(sqlParser.NOT)


                self.state = 2351
                localctx.kind = self.match(sqlParser.IN)
                self.state = 2352
                self.match(sqlParser.T__1)
                self.state = 2353
                self.query()
                self.state = 2354
                self.match(sqlParser.T__2)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2357
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.NOT:
                    self.state = 2356
                    self.match(sqlParser.NOT)


                self.state = 2359
                localctx.kind = self.match(sqlParser.RLIKE)
                self.state = 2360
                localctx.pattern = self.valueExpression(0)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 2362
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.NOT:
                    self.state = 2361
                    self.match(sqlParser.NOT)


                self.state = 2364
                localctx.kind = self.match(sqlParser.LIKE)
                self.state = 2365
                localctx.quantifier = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==sqlParser.ALL or _la==sqlParser.ANY or _la==sqlParser.SOME):
                    localctx.quantifier = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2379
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,304,self._ctx)
                if la_ == 1:
                    self.state = 2366
                    self.match(sqlParser.T__1)
                    self.state = 2367
                    self.match(sqlParser.T__2)
                    pass

                elif la_ == 2:
                    self.state = 2368
                    self.match(sqlParser.T__1)
                    self.state = 2369
                    self.expression()
                    self.state = 2374
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==sqlParser.T__3:
                        self.state = 2370
                        self.match(sqlParser.T__3)
                        self.state = 2371
                        self.expression()
                        self.state = 2376
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 2377
                    self.match(sqlParser.T__2)
                    pass


                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 2382
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.NOT:
                    self.state = 2381
                    self.match(sqlParser.NOT)


                self.state = 2384
                localctx.kind = self.match(sqlParser.LIKE)
                self.state = 2385
                localctx.pattern = self.valueExpression(0)
                self.state = 2388
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,306,self._ctx)
                if la_ == 1:
                    self.state = 2386
                    self.match(sqlParser.ESCAPE)
                    self.state = 2387
                    localctx.escapeChar = self.match(sqlParser.STRING)


                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 2390
                self.match(sqlParser.IS)
                self.state = 2392
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.NOT:
                    self.state = 2391
                    self.match(sqlParser.NOT)


                self.state = 2394
                localctx.kind = self.match(sqlParser.NULL)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 2395
                self.match(sqlParser.IS)
                self.state = 2397
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.NOT:
                    self.state = 2396
                    self.match(sqlParser.NOT)


                self.state = 2399
                localctx.kind = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==sqlParser.FALSE or _la==sqlParser.TRUE or _la==sqlParser.UNKNOWN):
                    localctx.kind = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 2400
                self.match(sqlParser.IS)
                self.state = 2402
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.NOT:
                    self.state = 2401
                    self.match(sqlParser.NOT)


                self.state = 2404
                localctx.kind = self.match(sqlParser.DISTINCT)
                self.state = 2405
                self.match(sqlParser.FROM)
                self.state = 2406
                localctx.right = self.valueExpression(0)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ValueExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return sqlParser.RULE_valueExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class ValueExpressionDefaultContext(ValueExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.ValueExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(sqlParser.PrimaryExpressionContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitValueExpressionDefault" ):
                return visitor.visitValueExpressionDefault(self)
            else:
                return visitor.visitChildren(self)


    class ComparisonContext(ValueExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.ValueExpressionContext
            super().__init__(parser)
            self.left = None # ValueExpressionContext
            self.right = None # ValueExpressionContext
            self.copyFrom(ctx)

        def comparisonOperator(self):
            return self.getTypedRuleContext(sqlParser.ComparisonOperatorContext,0)

        def valueExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.ValueExpressionContext)
            else:
                return self.getTypedRuleContext(sqlParser.ValueExpressionContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparison" ):
                return visitor.visitComparison(self)
            else:
                return visitor.visitChildren(self)


    class ArithmeticBinaryContext(ValueExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.ValueExpressionContext
            super().__init__(parser)
            self.left = None # ValueExpressionContext
            self.operator = None # Token
            self.right = None # ValueExpressionContext
            self.copyFrom(ctx)

        def valueExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.ValueExpressionContext)
            else:
                return self.getTypedRuleContext(sqlParser.ValueExpressionContext,i)

        def ASTERISK(self):
            return self.getToken(sqlParser.ASTERISK, 0)
        def SLASH(self):
            return self.getToken(sqlParser.SLASH, 0)
        def PERCENT(self):
            return self.getToken(sqlParser.PERCENT, 0)
        def DIV(self):
            return self.getToken(sqlParser.DIV, 0)
        def PLUS(self):
            return self.getToken(sqlParser.PLUS, 0)
        def MINUS(self):
            return self.getToken(sqlParser.MINUS, 0)
        def CONCAT_PIPE(self):
            return self.getToken(sqlParser.CONCAT_PIPE, 0)
        def AMPERSAND(self):
            return self.getToken(sqlParser.AMPERSAND, 0)
        def HAT(self):
            return self.getToken(sqlParser.HAT, 0)
        def PIPE(self):
            return self.getToken(sqlParser.PIPE, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArithmeticBinary" ):
                return visitor.visitArithmeticBinary(self)
            else:
                return visitor.visitChildren(self)


    class ArithmeticUnaryContext(ValueExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.ValueExpressionContext
            super().__init__(parser)
            self.operator = None # Token
            self.copyFrom(ctx)

        def valueExpression(self):
            return self.getTypedRuleContext(sqlParser.ValueExpressionContext,0)

        def MINUS(self):
            return self.getToken(sqlParser.MINUS, 0)
        def PLUS(self):
            return self.getToken(sqlParser.PLUS, 0)
        def TILDE(self):
            return self.getToken(sqlParser.TILDE, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArithmeticUnary" ):
                return visitor.visitArithmeticUnary(self)
            else:
                return visitor.visitChildren(self)



    def valueExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = sqlParser.ValueExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 192
        self.enterRecursionRule(localctx, 192, self.RULE_valueExpression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2413
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,311,self._ctx)
            if la_ == 1:
                localctx = sqlParser.ValueExpressionDefaultContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 2410
                self.primaryExpression(0)
                pass

            elif la_ == 2:
                localctx = sqlParser.ArithmeticUnaryContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 2411
                localctx.operator = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 272)) & ~0x3f) == 0 and ((1 << (_la - 272)) & ((1 << (sqlParser.PLUS - 272)) | (1 << (sqlParser.MINUS - 272)) | (1 << (sqlParser.TILDE - 272)))) != 0)):
                    localctx.operator = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2412
                self.valueExpression(7)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 2436
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,313,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 2434
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,312,self._ctx)
                    if la_ == 1:
                        localctx = sqlParser.ArithmeticBinaryContext(self, sqlParser.ValueExpressionContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_valueExpression)
                        self.state = 2415
                        if not self.precpred(self._ctx, 6):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
                        self.state = 2416
                        localctx.operator = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(((((_la - 274)) & ~0x3f) == 0 and ((1 << (_la - 274)) & ((1 << (sqlParser.ASTERISK - 274)) | (1 << (sqlParser.SLASH - 274)) | (1 << (sqlParser.PERCENT - 274)) | (1 << (sqlParser.DIV - 274)))) != 0)):
                            localctx.operator = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 2417
                        localctx.right = self.valueExpression(7)
                        pass

                    elif la_ == 2:
                        localctx = sqlParser.ArithmeticBinaryContext(self, sqlParser.ValueExpressionContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_valueExpression)
                        self.state = 2418
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 2419
                        localctx.operator = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(((((_la - 272)) & ~0x3f) == 0 and ((1 << (_la - 272)) & ((1 << (sqlParser.PLUS - 272)) | (1 << (sqlParser.MINUS - 272)) | (1 << (sqlParser.CONCAT_PIPE - 272)))) != 0)):
                            localctx.operator = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 2420
                        localctx.right = self.valueExpression(6)
                        pass

                    elif la_ == 3:
                        localctx = sqlParser.ArithmeticBinaryContext(self, sqlParser.ValueExpressionContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_valueExpression)
                        self.state = 2421
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                        self.state = 2422
                        localctx.operator = self.match(sqlParser.AMPERSAND)
                        self.state = 2423
                        localctx.right = self.valueExpression(5)
                        pass

                    elif la_ == 4:
                        localctx = sqlParser.ArithmeticBinaryContext(self, sqlParser.ValueExpressionContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_valueExpression)
                        self.state = 2424
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 2425
                        localctx.operator = self.match(sqlParser.HAT)
                        self.state = 2426
                        localctx.right = self.valueExpression(4)
                        pass

                    elif la_ == 5:
                        localctx = sqlParser.ArithmeticBinaryContext(self, sqlParser.ValueExpressionContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_valueExpression)
                        self.state = 2427
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 2428
                        localctx.operator = self.match(sqlParser.PIPE)
                        self.state = 2429
                        localctx.right = self.valueExpression(3)
                        pass

                    elif la_ == 6:
                        localctx = sqlParser.ComparisonContext(self, sqlParser.ValueExpressionContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_valueExpression)
                        self.state = 2430
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 2431
                        self.comparisonOperator()
                        self.state = 2432
                        localctx.right = self.valueExpression(2)
                        pass

             
                self.state = 2438
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,313,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class PrimaryExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return sqlParser.RULE_primaryExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class StructContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.PrimaryExpressionContext
            super().__init__(parser)
            self._namedExpression = None # NamedExpressionContext
            self.argument = list() # of NamedExpressionContexts
            self.copyFrom(ctx)

        def STRUCT(self):
            return self.getToken(sqlParser.STRUCT, 0)
        def namedExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.NamedExpressionContext)
            else:
                return self.getTypedRuleContext(sqlParser.NamedExpressionContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStruct" ):
                return visitor.visitStruct(self)
            else:
                return visitor.visitChildren(self)


    class DereferenceContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.PrimaryExpressionContext
            super().__init__(parser)
            self.base = None # PrimaryExpressionContext
            self.fieldName = None # IdentifierContext
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(sqlParser.PrimaryExpressionContext,0)

        def identifier(self):
            return self.getTypedRuleContext(sqlParser.IdentifierContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDereference" ):
                return visitor.visitDereference(self)
            else:
                return visitor.visitChildren(self)


    class SimpleCaseContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.PrimaryExpressionContext
            super().__init__(parser)
            self.value = None # ExpressionContext
            self.elseExpression = None # ExpressionContext
            self.copyFrom(ctx)

        def CASE(self):
            return self.getToken(sqlParser.CASE, 0)
        def END(self):
            return self.getToken(sqlParser.END, 0)
        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(sqlParser.ExpressionContext,i)

        def whenClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.WhenClauseContext)
            else:
                return self.getTypedRuleContext(sqlParser.WhenClauseContext,i)

        def ELSE(self):
            return self.getToken(sqlParser.ELSE, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleCase" ):
                return visitor.visitSimpleCase(self)
            else:
                return visitor.visitChildren(self)


    class ColumnReferenceContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(sqlParser.IdentifierContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumnReference" ):
                return visitor.visitColumnReference(self)
            else:
                return visitor.visitChildren(self)


    class RowConstructorContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def namedExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.NamedExpressionContext)
            else:
                return self.getTypedRuleContext(sqlParser.NamedExpressionContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRowConstructor" ):
                return visitor.visitRowConstructor(self)
            else:
                return visitor.visitChildren(self)


    class LastContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LAST(self):
            return self.getToken(sqlParser.LAST, 0)
        def expression(self):
            return self.getTypedRuleContext(sqlParser.ExpressionContext,0)

        def IGNORE(self):
            return self.getToken(sqlParser.IGNORE, 0)
        def NULLS(self):
            return self.getToken(sqlParser.NULLS, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLast" ):
                return visitor.visitLast(self)
            else:
                return visitor.visitChildren(self)


    class StarContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ASTERISK(self):
            return self.getToken(sqlParser.ASTERISK, 0)
        def qualifiedName(self):
            return self.getTypedRuleContext(sqlParser.QualifiedNameContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStar" ):
                return visitor.visitStar(self)
            else:
                return visitor.visitChildren(self)


    class OverlayContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.PrimaryExpressionContext
            super().__init__(parser)
            self.qpdinput = None # ValueExpressionContext
            self.replace = None # ValueExpressionContext
            self.position = None # ValueExpressionContext
            self.length = None # ValueExpressionContext
            self.copyFrom(ctx)

        def OVERLAY(self):
            return self.getToken(sqlParser.OVERLAY, 0)
        def PLACING(self):
            return self.getToken(sqlParser.PLACING, 0)
        def FROM(self):
            return self.getToken(sqlParser.FROM, 0)
        def valueExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.ValueExpressionContext)
            else:
                return self.getTypedRuleContext(sqlParser.ValueExpressionContext,i)

        def FOR(self):
            return self.getToken(sqlParser.FOR, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOverlay" ):
                return visitor.visitOverlay(self)
            else:
                return visitor.visitChildren(self)


    class SubscriptContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.PrimaryExpressionContext
            super().__init__(parser)
            self.value = None # PrimaryExpressionContext
            self.index = None # ValueExpressionContext
            self.copyFrom(ctx)

        def primaryExpression(self):
            return self.getTypedRuleContext(sqlParser.PrimaryExpressionContext,0)

        def valueExpression(self):
            return self.getTypedRuleContext(sqlParser.ValueExpressionContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubscript" ):
                return visitor.visitSubscript(self)
            else:
                return visitor.visitChildren(self)


    class SubqueryExpressionContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def query(self):
            return self.getTypedRuleContext(sqlParser.QueryContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubqueryExpression" ):
                return visitor.visitSubqueryExpression(self)
            else:
                return visitor.visitChildren(self)


    class SubstringContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.PrimaryExpressionContext
            super().__init__(parser)
            self.qpdstr = None # ValueExpressionContext
            self.pos = None # ValueExpressionContext
            self.qpdlen = None # ValueExpressionContext
            self.copyFrom(ctx)

        def SUBSTR(self):
            return self.getToken(sqlParser.SUBSTR, 0)
        def SUBSTRING(self):
            return self.getToken(sqlParser.SUBSTRING, 0)
        def valueExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.ValueExpressionContext)
            else:
                return self.getTypedRuleContext(sqlParser.ValueExpressionContext,i)

        def FROM(self):
            return self.getToken(sqlParser.FROM, 0)
        def FOR(self):
            return self.getToken(sqlParser.FOR, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubstring" ):
                return visitor.visitSubstring(self)
            else:
                return visitor.visitChildren(self)


    class CurrentDatetimeContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.PrimaryExpressionContext
            super().__init__(parser)
            self.name = None # Token
            self.copyFrom(ctx)

        def CURRENT_DATE(self):
            return self.getToken(sqlParser.CURRENT_DATE, 0)
        def CURRENT_TIMESTAMP(self):
            return self.getToken(sqlParser.CURRENT_TIMESTAMP, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCurrentDatetime" ):
                return visitor.visitCurrentDatetime(self)
            else:
                return visitor.visitChildren(self)


    class CastContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def CAST(self):
            return self.getToken(sqlParser.CAST, 0)
        def expression(self):
            return self.getTypedRuleContext(sqlParser.ExpressionContext,0)

        def AS(self):
            return self.getToken(sqlParser.AS, 0)
        def dataType(self):
            return self.getTypedRuleContext(sqlParser.DataTypeContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCast" ):
                return visitor.visitCast(self)
            else:
                return visitor.visitChildren(self)


    class ConstantDefaultContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def constant(self):
            return self.getTypedRuleContext(sqlParser.ConstantContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstantDefault" ):
                return visitor.visitConstantDefault(self)
            else:
                return visitor.visitChildren(self)


    class LambdaContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(sqlParser.IdentifierContext,i)

        def expression(self):
            return self.getTypedRuleContext(sqlParser.ExpressionContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLambda" ):
                return visitor.visitLambda(self)
            else:
                return visitor.visitChildren(self)


    class ParenthesizedExpressionContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self):
            return self.getTypedRuleContext(sqlParser.ExpressionContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParenthesizedExpression" ):
                return visitor.visitParenthesizedExpression(self)
            else:
                return visitor.visitChildren(self)


    class ExtractContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.PrimaryExpressionContext
            super().__init__(parser)
            self.field = None # IdentifierContext
            self.source = None # ValueExpressionContext
            self.copyFrom(ctx)

        def EXTRACT(self):
            return self.getToken(sqlParser.EXTRACT, 0)
        def FROM(self):
            return self.getToken(sqlParser.FROM, 0)
        def identifier(self):
            return self.getTypedRuleContext(sqlParser.IdentifierContext,0)

        def valueExpression(self):
            return self.getTypedRuleContext(sqlParser.ValueExpressionContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExtract" ):
                return visitor.visitExtract(self)
            else:
                return visitor.visitChildren(self)


    class TrimContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.PrimaryExpressionContext
            super().__init__(parser)
            self.trimOption = None # Token
            self.trimStr = None # ValueExpressionContext
            self.srcStr = None # ValueExpressionContext
            self.copyFrom(ctx)

        def TRIM(self):
            return self.getToken(sqlParser.TRIM, 0)
        def FROM(self):
            return self.getToken(sqlParser.FROM, 0)
        def valueExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.ValueExpressionContext)
            else:
                return self.getTypedRuleContext(sqlParser.ValueExpressionContext,i)

        def BOTH(self):
            return self.getToken(sqlParser.BOTH, 0)
        def LEADING(self):
            return self.getToken(sqlParser.LEADING, 0)
        def TRAILING(self):
            return self.getToken(sqlParser.TRAILING, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTrim" ):
                return visitor.visitTrim(self)
            else:
                return visitor.visitChildren(self)


    class FunctionCallContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.PrimaryExpressionContext
            super().__init__(parser)
            self._expression = None # ExpressionContext
            self.argument = list() # of ExpressionContexts
            self.where = None # BooleanExpressionContext
            self.copyFrom(ctx)

        def functionName(self):
            return self.getTypedRuleContext(sqlParser.FunctionNameContext,0)

        def FILTER(self):
            return self.getToken(sqlParser.FILTER, 0)
        def WHERE(self):
            return self.getToken(sqlParser.WHERE, 0)
        def OVER(self):
            return self.getToken(sqlParser.OVER, 0)
        def windowSpec(self):
            return self.getTypedRuleContext(sqlParser.WindowSpecContext,0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(sqlParser.ExpressionContext,i)

        def booleanExpression(self):
            return self.getTypedRuleContext(sqlParser.BooleanExpressionContext,0)

        def setQuantifier(self):
            return self.getTypedRuleContext(sqlParser.SetQuantifierContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionCall" ):
                return visitor.visitFunctionCall(self)
            else:
                return visitor.visitChildren(self)


    class SearchedCaseContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.PrimaryExpressionContext
            super().__init__(parser)
            self.elseExpression = None # ExpressionContext
            self.copyFrom(ctx)

        def CASE(self):
            return self.getToken(sqlParser.CASE, 0)
        def END(self):
            return self.getToken(sqlParser.END, 0)
        def whenClause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.WhenClauseContext)
            else:
                return self.getTypedRuleContext(sqlParser.WhenClauseContext,i)

        def ELSE(self):
            return self.getToken(sqlParser.ELSE, 0)
        def expression(self):
            return self.getTypedRuleContext(sqlParser.ExpressionContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSearchedCase" ):
                return visitor.visitSearchedCase(self)
            else:
                return visitor.visitChildren(self)


    class PositionContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.PrimaryExpressionContext
            super().__init__(parser)
            self.substr = None # ValueExpressionContext
            self.qpdstr = None # ValueExpressionContext
            self.copyFrom(ctx)

        def POSITION(self):
            return self.getToken(sqlParser.POSITION, 0)
        def IN(self):
            return self.getToken(sqlParser.IN, 0)
        def valueExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.ValueExpressionContext)
            else:
                return self.getTypedRuleContext(sqlParser.ValueExpressionContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPosition" ):
                return visitor.visitPosition(self)
            else:
                return visitor.visitChildren(self)


    class FirstContext(PrimaryExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.PrimaryExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def FIRST(self):
            return self.getToken(sqlParser.FIRST, 0)
        def expression(self):
            return self.getTypedRuleContext(sqlParser.ExpressionContext,0)

        def IGNORE(self):
            return self.getToken(sqlParser.IGNORE, 0)
        def NULLS(self):
            return self.getToken(sqlParser.NULLS, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFirst" ):
                return visitor.visitFirst(self)
            else:
                return visitor.visitChildren(self)



    def primaryExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = sqlParser.PrimaryExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 194
        self.enterRecursionRule(localctx, 194, self.RULE_primaryExpression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2623
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,333,self._ctx)
            if la_ == 1:
                localctx = sqlParser.CurrentDatetimeContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 2440
                localctx.name = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==sqlParser.CURRENT_DATE or _la==sqlParser.CURRENT_TIMESTAMP):
                    localctx.name = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                localctx = sqlParser.SearchedCaseContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 2441
                self.match(sqlParser.CASE)
                self.state = 2443 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 2442
                    self.whenClause()
                    self.state = 2445 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==sqlParser.WHEN):
                        break

                self.state = 2449
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.ELSE:
                    self.state = 2447
                    self.match(sqlParser.ELSE)
                    self.state = 2448
                    localctx.elseExpression = self.expression()


                self.state = 2451
                self.match(sqlParser.END)
                pass

            elif la_ == 3:
                localctx = sqlParser.SimpleCaseContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 2453
                self.match(sqlParser.CASE)
                self.state = 2454
                localctx.value = self.expression()
                self.state = 2456 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 2455
                    self.whenClause()
                    self.state = 2458 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==sqlParser.WHEN):
                        break

                self.state = 2462
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.ELSE:
                    self.state = 2460
                    self.match(sqlParser.ELSE)
                    self.state = 2461
                    localctx.elseExpression = self.expression()


                self.state = 2464
                self.match(sqlParser.END)
                pass

            elif la_ == 4:
                localctx = sqlParser.CastContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 2466
                self.match(sqlParser.CAST)
                self.state = 2467
                self.match(sqlParser.T__1)
                self.state = 2468
                self.expression()
                self.state = 2469
                self.match(sqlParser.AS)
                self.state = 2470
                self.dataType()
                self.state = 2471
                self.match(sqlParser.T__2)
                pass

            elif la_ == 5:
                localctx = sqlParser.StructContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 2473
                self.match(sqlParser.STRUCT)
                self.state = 2474
                self.match(sqlParser.T__1)
                self.state = 2483
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,319,self._ctx)
                if la_ == 1:
                    self.state = 2475
                    localctx._namedExpression = self.namedExpression()
                    localctx.argument.append(localctx._namedExpression)
                    self.state = 2480
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==sqlParser.T__3:
                        self.state = 2476
                        self.match(sqlParser.T__3)
                        self.state = 2477
                        localctx._namedExpression = self.namedExpression()
                        localctx.argument.append(localctx._namedExpression)
                        self.state = 2482
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)



                self.state = 2485
                self.match(sqlParser.T__2)
                pass

            elif la_ == 6:
                localctx = sqlParser.FirstContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 2486
                self.match(sqlParser.FIRST)
                self.state = 2487
                self.match(sqlParser.T__1)
                self.state = 2488
                self.expression()
                self.state = 2491
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.IGNORE:
                    self.state = 2489
                    self.match(sqlParser.IGNORE)
                    self.state = 2490
                    self.match(sqlParser.NULLS)


                self.state = 2493
                self.match(sqlParser.T__2)
                pass

            elif la_ == 7:
                localctx = sqlParser.LastContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 2495
                self.match(sqlParser.LAST)
                self.state = 2496
                self.match(sqlParser.T__1)
                self.state = 2497
                self.expression()
                self.state = 2500
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.IGNORE:
                    self.state = 2498
                    self.match(sqlParser.IGNORE)
                    self.state = 2499
                    self.match(sqlParser.NULLS)


                self.state = 2502
                self.match(sqlParser.T__2)
                pass

            elif la_ == 8:
                localctx = sqlParser.PositionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 2504
                self.match(sqlParser.POSITION)
                self.state = 2505
                self.match(sqlParser.T__1)
                self.state = 2506
                localctx.substr = self.valueExpression(0)
                self.state = 2507
                self.match(sqlParser.IN)
                self.state = 2508
                localctx.qpdstr = self.valueExpression(0)
                self.state = 2509
                self.match(sqlParser.T__2)
                pass

            elif la_ == 9:
                localctx = sqlParser.ConstantDefaultContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 2511
                self.constant()
                pass

            elif la_ == 10:
                localctx = sqlParser.StarContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 2512
                self.match(sqlParser.ASTERISK)
                pass

            elif la_ == 11:
                localctx = sqlParser.StarContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 2513
                self.qualifiedName()
                self.state = 2514
                self.match(sqlParser.T__4)
                self.state = 2515
                self.match(sqlParser.ASTERISK)
                pass

            elif la_ == 12:
                localctx = sqlParser.RowConstructorContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 2517
                self.match(sqlParser.T__1)
                self.state = 2518
                self.namedExpression()
                self.state = 2521 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 2519
                    self.match(sqlParser.T__3)
                    self.state = 2520
                    self.namedExpression()
                    self.state = 2523 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==sqlParser.T__3):
                        break

                self.state = 2525
                self.match(sqlParser.T__2)
                pass

            elif la_ == 13:
                localctx = sqlParser.SubqueryExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 2527
                self.match(sqlParser.T__1)
                self.state = 2528
                self.query()
                self.state = 2529
                self.match(sqlParser.T__2)
                pass

            elif la_ == 14:
                localctx = sqlParser.FunctionCallContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 2531
                self.functionName()
                self.state = 2532
                self.match(sqlParser.T__1)
                self.state = 2544
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,325,self._ctx)
                if la_ == 1:
                    self.state = 2534
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,323,self._ctx)
                    if la_ == 1:
                        self.state = 2533
                        self.setQuantifier()


                    self.state = 2536
                    localctx._expression = self.expression()
                    localctx.argument.append(localctx._expression)
                    self.state = 2541
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==sqlParser.T__3:
                        self.state = 2537
                        self.match(sqlParser.T__3)
                        self.state = 2538
                        localctx._expression = self.expression()
                        localctx.argument.append(localctx._expression)
                        self.state = 2543
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)



                self.state = 2546
                self.match(sqlParser.T__2)
                self.state = 2553
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,326,self._ctx)
                if la_ == 1:
                    self.state = 2547
                    self.match(sqlParser.FILTER)
                    self.state = 2548
                    self.match(sqlParser.T__1)
                    self.state = 2549
                    self.match(sqlParser.WHERE)
                    self.state = 2550
                    localctx.where = self.booleanExpression(0)
                    self.state = 2551
                    self.match(sqlParser.T__2)


                self.state = 2557
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,327,self._ctx)
                if la_ == 1:
                    self.state = 2555
                    self.match(sqlParser.OVER)
                    self.state = 2556
                    self.windowSpec()


                pass

            elif la_ == 15:
                localctx = sqlParser.LambdaContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 2559
                self.identifier()
                self.state = 2560
                self.match(sqlParser.T__7)
                self.state = 2561
                self.expression()
                pass

            elif la_ == 16:
                localctx = sqlParser.LambdaContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 2563
                self.match(sqlParser.T__1)
                self.state = 2564
                self.identifier()
                self.state = 2567 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 2565
                    self.match(sqlParser.T__3)
                    self.state = 2566
                    self.identifier()
                    self.state = 2569 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==sqlParser.T__3):
                        break

                self.state = 2571
                self.match(sqlParser.T__2)
                self.state = 2572
                self.match(sqlParser.T__7)
                self.state = 2573
                self.expression()
                pass

            elif la_ == 17:
                localctx = sqlParser.ColumnReferenceContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 2575
                self.identifier()
                pass

            elif la_ == 18:
                localctx = sqlParser.ParenthesizedExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 2576
                self.match(sqlParser.T__1)
                self.state = 2577
                self.expression()
                self.state = 2578
                self.match(sqlParser.T__2)
                pass

            elif la_ == 19:
                localctx = sqlParser.ExtractContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 2580
                self.match(sqlParser.EXTRACT)
                self.state = 2581
                self.match(sqlParser.T__1)
                self.state = 2582
                localctx.field = self.identifier()
                self.state = 2583
                self.match(sqlParser.FROM)
                self.state = 2584
                localctx.source = self.valueExpression(0)
                self.state = 2585
                self.match(sqlParser.T__2)
                pass

            elif la_ == 20:
                localctx = sqlParser.SubstringContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 2587
                _la = self._input.LA(1)
                if not(_la==sqlParser.SUBSTR or _la==sqlParser.SUBSTRING):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2588
                self.match(sqlParser.T__1)
                self.state = 2589
                localctx.qpdstr = self.valueExpression(0)
                self.state = 2590
                _la = self._input.LA(1)
                if not(_la==sqlParser.T__3 or _la==sqlParser.FROM):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2591
                localctx.pos = self.valueExpression(0)
                self.state = 2594
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.T__3 or _la==sqlParser.FOR:
                    self.state = 2592
                    _la = self._input.LA(1)
                    if not(_la==sqlParser.T__3 or _la==sqlParser.FOR):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 2593
                    localctx.qpdlen = self.valueExpression(0)


                self.state = 2596
                self.match(sqlParser.T__2)
                pass

            elif la_ == 21:
                localctx = sqlParser.TrimContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 2598
                self.match(sqlParser.TRIM)
                self.state = 2599
                self.match(sqlParser.T__1)
                self.state = 2601
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,330,self._ctx)
                if la_ == 1:
                    self.state = 2600
                    localctx.trimOption = self._input.LT(1)
                    _la = self._input.LA(1)
                    if not(_la==sqlParser.BOTH or _la==sqlParser.LEADING or _la==sqlParser.TRAILING):
                        localctx.trimOption = self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 2604
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,331,self._ctx)
                if la_ == 1:
                    self.state = 2603
                    localctx.trimStr = self.valueExpression(0)


                self.state = 2606
                self.match(sqlParser.FROM)
                self.state = 2607
                localctx.srcStr = self.valueExpression(0)
                self.state = 2608
                self.match(sqlParser.T__2)
                pass

            elif la_ == 22:
                localctx = sqlParser.OverlayContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 2610
                self.match(sqlParser.OVERLAY)
                self.state = 2611
                self.match(sqlParser.T__1)
                self.state = 2612
                localctx.qpdinput = self.valueExpression(0)
                self.state = 2613
                self.match(sqlParser.PLACING)
                self.state = 2614
                localctx.replace = self.valueExpression(0)
                self.state = 2615
                self.match(sqlParser.FROM)
                self.state = 2616
                localctx.position = self.valueExpression(0)
                self.state = 2619
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.FOR:
                    self.state = 2617
                    self.match(sqlParser.FOR)
                    self.state = 2618
                    localctx.length = self.valueExpression(0)


                self.state = 2621
                self.match(sqlParser.T__2)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 2635
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,335,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 2633
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,334,self._ctx)
                    if la_ == 1:
                        localctx = sqlParser.SubscriptContext(self, sqlParser.PrimaryExpressionContext(self, _parentctx, _parentState))
                        localctx.value = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 2625
                        if not self.precpred(self._ctx, 8):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
                        self.state = 2626
                        self.match(sqlParser.T__8)
                        self.state = 2627
                        localctx.index = self.valueExpression(0)
                        self.state = 2628
                        self.match(sqlParser.T__9)
                        pass

                    elif la_ == 2:
                        localctx = sqlParser.DereferenceContext(self, sqlParser.PrimaryExpressionContext(self, _parentctx, _parentState))
                        localctx.base = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_primaryExpression)
                        self.state = 2630
                        if not self.precpred(self._ctx, 6):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
                        self.state = 2631
                        self.match(sqlParser.T__4)
                        self.state = 2632
                        localctx.fieldName = self.identifier()
                        pass

             
                self.state = 2637
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,335,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class ConstantContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return sqlParser.RULE_constant

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class NullLiteralContext(ConstantContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.ConstantContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NULL(self):
            return self.getToken(sqlParser.NULL, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNullLiteral" ):
                return visitor.visitNullLiteral(self)
            else:
                return visitor.visitChildren(self)


    class StringLiteralContext(ConstantContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.ConstantContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def STRING(self, i:int=None):
            if i is None:
                return self.getTokens(sqlParser.STRING)
            else:
                return self.getToken(sqlParser.STRING, i)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringLiteral" ):
                return visitor.visitStringLiteral(self)
            else:
                return visitor.visitChildren(self)


    class TypeConstructorContext(ConstantContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.ConstantContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(sqlParser.IdentifierContext,0)

        def STRING(self):
            return self.getToken(sqlParser.STRING, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTypeConstructor" ):
                return visitor.visitTypeConstructor(self)
            else:
                return visitor.visitChildren(self)


    class IntervalLiteralContext(ConstantContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.ConstantContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def interval(self):
            return self.getTypedRuleContext(sqlParser.IntervalContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntervalLiteral" ):
                return visitor.visitIntervalLiteral(self)
            else:
                return visitor.visitChildren(self)


    class NumericLiteralContext(ConstantContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.ConstantContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def number(self):
            return self.getTypedRuleContext(sqlParser.NumberContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumericLiteral" ):
                return visitor.visitNumericLiteral(self)
            else:
                return visitor.visitChildren(self)


    class BooleanLiteralContext(ConstantContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.ConstantContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def booleanValue(self):
            return self.getTypedRuleContext(sqlParser.BooleanValueContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanLiteral" ):
                return visitor.visitBooleanLiteral(self)
            else:
                return visitor.visitChildren(self)



    def constant(self):

        localctx = sqlParser.ConstantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 196, self.RULE_constant)
        try:
            self.state = 2650
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,337,self._ctx)
            if la_ == 1:
                localctx = sqlParser.NullLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 2638
                self.match(sqlParser.NULL)
                pass

            elif la_ == 2:
                localctx = sqlParser.IntervalLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 2639
                self.interval()
                pass

            elif la_ == 3:
                localctx = sqlParser.TypeConstructorContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 2640
                self.identifier()
                self.state = 2641
                self.match(sqlParser.STRING)
                pass

            elif la_ == 4:
                localctx = sqlParser.NumericLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 2643
                self.number()
                pass

            elif la_ == 5:
                localctx = sqlParser.BooleanLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 2644
                self.booleanValue()
                pass

            elif la_ == 6:
                localctx = sqlParser.StringLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 2646 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 2645
                        self.match(sqlParser.STRING)

                    else:
                        raise NoViableAltException(self)
                    self.state = 2648 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,336,self._ctx)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQ(self):
            return self.getToken(sqlParser.EQ, 0)

        def NEQ(self):
            return self.getToken(sqlParser.NEQ, 0)

        def NEQJ(self):
            return self.getToken(sqlParser.NEQJ, 0)

        def LT(self):
            return self.getToken(sqlParser.LT, 0)

        def LTE(self):
            return self.getToken(sqlParser.LTE, 0)

        def GT(self):
            return self.getToken(sqlParser.GT, 0)

        def GTE(self):
            return self.getToken(sqlParser.GTE, 0)

        def NSEQ(self):
            return self.getToken(sqlParser.NSEQ, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_comparisonOperator

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparisonOperator" ):
                return visitor.visitComparisonOperator(self)
            else:
                return visitor.visitChildren(self)




    def comparisonOperator(self):

        localctx = sqlParser.ComparisonOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 198, self.RULE_comparisonOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2652
            _la = self._input.LA(1)
            if not(((((_la - 264)) & ~0x3f) == 0 and ((1 << (_la - 264)) & ((1 << (sqlParser.EQ - 264)) | (1 << (sqlParser.NSEQ - 264)) | (1 << (sqlParser.NEQ - 264)) | (1 << (sqlParser.NEQJ - 264)) | (1 << (sqlParser.LT - 264)) | (1 << (sqlParser.LTE - 264)) | (1 << (sqlParser.GT - 264)) | (1 << (sqlParser.GTE - 264)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArithmeticOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLUS(self):
            return self.getToken(sqlParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(sqlParser.MINUS, 0)

        def ASTERISK(self):
            return self.getToken(sqlParser.ASTERISK, 0)

        def SLASH(self):
            return self.getToken(sqlParser.SLASH, 0)

        def PERCENT(self):
            return self.getToken(sqlParser.PERCENT, 0)

        def DIV(self):
            return self.getToken(sqlParser.DIV, 0)

        def TILDE(self):
            return self.getToken(sqlParser.TILDE, 0)

        def AMPERSAND(self):
            return self.getToken(sqlParser.AMPERSAND, 0)

        def PIPE(self):
            return self.getToken(sqlParser.PIPE, 0)

        def CONCAT_PIPE(self):
            return self.getToken(sqlParser.CONCAT_PIPE, 0)

        def HAT(self):
            return self.getToken(sqlParser.HAT, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_arithmeticOperator

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArithmeticOperator" ):
                return visitor.visitArithmeticOperator(self)
            else:
                return visitor.visitChildren(self)




    def arithmeticOperator(self):

        localctx = sqlParser.ArithmeticOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 200, self.RULE_arithmeticOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2654
            _la = self._input.LA(1)
            if not(((((_la - 272)) & ~0x3f) == 0 and ((1 << (_la - 272)) & ((1 << (sqlParser.PLUS - 272)) | (1 << (sqlParser.MINUS - 272)) | (1 << (sqlParser.ASTERISK - 272)) | (1 << (sqlParser.SLASH - 272)) | (1 << (sqlParser.PERCENT - 272)) | (1 << (sqlParser.DIV - 272)) | (1 << (sqlParser.TILDE - 272)) | (1 << (sqlParser.AMPERSAND - 272)) | (1 << (sqlParser.PIPE - 272)) | (1 << (sqlParser.CONCAT_PIPE - 272)) | (1 << (sqlParser.HAT - 272)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PredicateOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OR(self):
            return self.getToken(sqlParser.OR, 0)

        def AND(self):
            return self.getToken(sqlParser.AND, 0)

        def IN(self):
            return self.getToken(sqlParser.IN, 0)

        def NOT(self):
            return self.getToken(sqlParser.NOT, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_predicateOperator

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPredicateOperator" ):
                return visitor.visitPredicateOperator(self)
            else:
                return visitor.visitChildren(self)




    def predicateOperator(self):

        localctx = sqlParser.PredicateOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 202, self.RULE_predicateOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2656
            _la = self._input.LA(1)
            if not(_la==sqlParser.AND or ((((_la - 113)) & ~0x3f) == 0 and ((1 << (_la - 113)) & ((1 << (sqlParser.IN - 113)) | (1 << (sqlParser.NOT - 113)) | (1 << (sqlParser.OR - 113)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRUE(self):
            return self.getToken(sqlParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(sqlParser.FALSE, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_booleanValue

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooleanValue" ):
                return visitor.visitBooleanValue(self)
            else:
                return visitor.visitChildren(self)




    def booleanValue(self):

        localctx = sqlParser.BooleanValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 204, self.RULE_booleanValue)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2658
            _la = self._input.LA(1)
            if not(_la==sqlParser.FALSE or _la==sqlParser.TRUE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntervalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTERVAL(self):
            return self.getToken(sqlParser.INTERVAL, 0)

        def errorCapturingMultiUnitsInterval(self):
            return self.getTypedRuleContext(sqlParser.ErrorCapturingMultiUnitsIntervalContext,0)


        def errorCapturingUnitToUnitInterval(self):
            return self.getTypedRuleContext(sqlParser.ErrorCapturingUnitToUnitIntervalContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_interval

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInterval" ):
                return visitor.visitInterval(self)
            else:
                return visitor.visitChildren(self)




    def interval(self):

        localctx = sqlParser.IntervalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 206, self.RULE_interval)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2660
            self.match(sqlParser.INTERVAL)
            self.state = 2663
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,338,self._ctx)
            if la_ == 1:
                self.state = 2661
                self.errorCapturingMultiUnitsInterval()

            elif la_ == 2:
                self.state = 2662
                self.errorCapturingUnitToUnitInterval()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ErrorCapturingMultiUnitsIntervalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def multiUnitsInterval(self):
            return self.getTypedRuleContext(sqlParser.MultiUnitsIntervalContext,0)


        def unitToUnitInterval(self):
            return self.getTypedRuleContext(sqlParser.UnitToUnitIntervalContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_errorCapturingMultiUnitsInterval

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitErrorCapturingMultiUnitsInterval" ):
                return visitor.visitErrorCapturingMultiUnitsInterval(self)
            else:
                return visitor.visitChildren(self)




    def errorCapturingMultiUnitsInterval(self):

        localctx = sqlParser.ErrorCapturingMultiUnitsIntervalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 208, self.RULE_errorCapturingMultiUnitsInterval)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2665
            self.multiUnitsInterval()
            self.state = 2667
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,339,self._ctx)
            if la_ == 1:
                self.state = 2666
                self.unitToUnitInterval()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultiUnitsIntervalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def intervalValue(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.IntervalValueContext)
            else:
                return self.getTypedRuleContext(sqlParser.IntervalValueContext,i)


        def intervalUnit(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.IntervalUnitContext)
            else:
                return self.getTypedRuleContext(sqlParser.IntervalUnitContext,i)


        def getRuleIndex(self):
            return sqlParser.RULE_multiUnitsInterval

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultiUnitsInterval" ):
                return visitor.visitMultiUnitsInterval(self)
            else:
                return visitor.visitChildren(self)




    def multiUnitsInterval(self):

        localctx = sqlParser.MultiUnitsIntervalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 210, self.RULE_multiUnitsInterval)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2672 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 2669
                    self.intervalValue()
                    self.state = 2670
                    self.intervalUnit()

                else:
                    raise NoViableAltException(self)
                self.state = 2674 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,340,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ErrorCapturingUnitToUnitIntervalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.body = None # UnitToUnitIntervalContext
            self.error1 = None # MultiUnitsIntervalContext
            self.error2 = None # UnitToUnitIntervalContext

        def unitToUnitInterval(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.UnitToUnitIntervalContext)
            else:
                return self.getTypedRuleContext(sqlParser.UnitToUnitIntervalContext,i)


        def multiUnitsInterval(self):
            return self.getTypedRuleContext(sqlParser.MultiUnitsIntervalContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_errorCapturingUnitToUnitInterval

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitErrorCapturingUnitToUnitInterval" ):
                return visitor.visitErrorCapturingUnitToUnitInterval(self)
            else:
                return visitor.visitChildren(self)




    def errorCapturingUnitToUnitInterval(self):

        localctx = sqlParser.ErrorCapturingUnitToUnitIntervalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 212, self.RULE_errorCapturingUnitToUnitInterval)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2676
            localctx.body = self.unitToUnitInterval()
            self.state = 2679
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,341,self._ctx)
            if la_ == 1:
                self.state = 2677
                localctx.error1 = self.multiUnitsInterval()

            elif la_ == 2:
                self.state = 2678
                localctx.error2 = self.unitToUnitInterval()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnitToUnitIntervalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.value = None # IntervalValueContext
            self.qpdfrom = None # IntervalUnitContext
            self.to = None # IntervalUnitContext

        def TO(self):
            return self.getToken(sqlParser.TO, 0)

        def intervalValue(self):
            return self.getTypedRuleContext(sqlParser.IntervalValueContext,0)


        def intervalUnit(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.IntervalUnitContext)
            else:
                return self.getTypedRuleContext(sqlParser.IntervalUnitContext,i)


        def getRuleIndex(self):
            return sqlParser.RULE_unitToUnitInterval

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnitToUnitInterval" ):
                return visitor.visitUnitToUnitInterval(self)
            else:
                return visitor.visitChildren(self)




    def unitToUnitInterval(self):

        localctx = sqlParser.UnitToUnitIntervalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 214, self.RULE_unitToUnitInterval)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2681
            localctx.value = self.intervalValue()
            self.state = 2682
            localctx.qpdfrom = self.intervalUnit()
            self.state = 2683
            self.match(sqlParser.TO)
            self.state = 2684
            localctx.to = self.intervalUnit()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntervalValueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTEGER_VALUE(self):
            return self.getToken(sqlParser.INTEGER_VALUE, 0)

        def DECIMAL_VALUE(self):
            return self.getToken(sqlParser.DECIMAL_VALUE, 0)

        def PLUS(self):
            return self.getToken(sqlParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(sqlParser.MINUS, 0)

        def STRING(self):
            return self.getToken(sqlParser.STRING, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_intervalValue

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntervalValue" ):
                return visitor.visitIntervalValue(self)
            else:
                return visitor.visitChildren(self)




    def intervalValue(self):

        localctx = sqlParser.IntervalValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 216, self.RULE_intervalValue)
        self._la = 0 # Token type
        try:
            self.state = 2691
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [sqlParser.PLUS, sqlParser.MINUS, sqlParser.INTEGER_VALUE, sqlParser.DECIMAL_VALUE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2687
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.PLUS or _la==sqlParser.MINUS:
                    self.state = 2686
                    _la = self._input.LA(1)
                    if not(_la==sqlParser.PLUS or _la==sqlParser.MINUS):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 2689
                _la = self._input.LA(1)
                if not(_la==sqlParser.INTEGER_VALUE or _la==sqlParser.DECIMAL_VALUE):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [sqlParser.STRING]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2690
                self.match(sqlParser.STRING)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntervalUnitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DAY(self):
            return self.getToken(sqlParser.DAY, 0)

        def HOUR(self):
            return self.getToken(sqlParser.HOUR, 0)

        def MINUTE(self):
            return self.getToken(sqlParser.MINUTE, 0)

        def MONTH(self):
            return self.getToken(sqlParser.MONTH, 0)

        def SECOND(self):
            return self.getToken(sqlParser.SECOND, 0)

        def YEAR(self):
            return self.getToken(sqlParser.YEAR, 0)

        def identifier(self):
            return self.getTypedRuleContext(sqlParser.IdentifierContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_intervalUnit

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntervalUnit" ):
                return visitor.visitIntervalUnit(self)
            else:
                return visitor.visitChildren(self)




    def intervalUnit(self):

        localctx = sqlParser.IntervalUnitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 218, self.RULE_intervalUnit)
        try:
            self.state = 2700
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,344,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2693
                self.match(sqlParser.DAY)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2694
                self.match(sqlParser.HOUR)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2695
                self.match(sqlParser.MINUTE)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2696
                self.match(sqlParser.MONTH)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 2697
                self.match(sqlParser.SECOND)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 2698
                self.match(sqlParser.YEAR)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 2699
                self.identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ColPositionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.position = None # Token
            self.afterCol = None # ErrorCapturingIdentifierContext

        def FIRST(self):
            return self.getToken(sqlParser.FIRST, 0)

        def AFTER(self):
            return self.getToken(sqlParser.AFTER, 0)

        def errorCapturingIdentifier(self):
            return self.getTypedRuleContext(sqlParser.ErrorCapturingIdentifierContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_colPosition

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColPosition" ):
                return visitor.visitColPosition(self)
            else:
                return visitor.visitChildren(self)




    def colPosition(self):

        localctx = sqlParser.ColPositionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 220, self.RULE_colPosition)
        try:
            self.state = 2705
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [sqlParser.FIRST]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2702
                localctx.position = self.match(sqlParser.FIRST)
                pass
            elif token in [sqlParser.AFTER]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2703
                localctx.position = self.match(sqlParser.AFTER)
                self.state = 2704
                localctx.afterCol = self.errorCapturingIdentifier()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DataTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return sqlParser.RULE_dataType

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class ComplexDataTypeContext(DataTypeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.DataTypeContext
            super().__init__(parser)
            self.qpdcomplex = None # Token
            self.copyFrom(ctx)

        def LT(self):
            return self.getToken(sqlParser.LT, 0)
        def dataType(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.DataTypeContext)
            else:
                return self.getTypedRuleContext(sqlParser.DataTypeContext,i)

        def GT(self):
            return self.getToken(sqlParser.GT, 0)
        def ARRAY(self):
            return self.getToken(sqlParser.ARRAY, 0)
        def MAP(self):
            return self.getToken(sqlParser.MAP, 0)
        def STRUCT(self):
            return self.getToken(sqlParser.STRUCT, 0)
        def NEQ(self):
            return self.getToken(sqlParser.NEQ, 0)
        def complexColTypeList(self):
            return self.getTypedRuleContext(sqlParser.ComplexColTypeListContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComplexDataType" ):
                return visitor.visitComplexDataType(self)
            else:
                return visitor.visitChildren(self)


    class PrimitiveDataTypeContext(DataTypeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.DataTypeContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(sqlParser.IdentifierContext,0)

        def INTEGER_VALUE(self, i:int=None):
            if i is None:
                return self.getTokens(sqlParser.INTEGER_VALUE)
            else:
                return self.getToken(sqlParser.INTEGER_VALUE, i)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPrimitiveDataType" ):
                return visitor.visitPrimitiveDataType(self)
            else:
                return visitor.visitChildren(self)



    def dataType(self):

        localctx = sqlParser.DataTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 222, self.RULE_dataType)
        self._la = 0 # Token type
        try:
            self.state = 2741
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,350,self._ctx)
            if la_ == 1:
                localctx = sqlParser.ComplexDataTypeContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 2707
                localctx.qpdcomplex = self.match(sqlParser.ARRAY)
                self.state = 2708
                self.match(sqlParser.LT)
                self.state = 2709
                self.dataType()
                self.state = 2710
                self.match(sqlParser.GT)
                pass

            elif la_ == 2:
                localctx = sqlParser.ComplexDataTypeContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 2712
                localctx.qpdcomplex = self.match(sqlParser.MAP)
                self.state = 2713
                self.match(sqlParser.LT)
                self.state = 2714
                self.dataType()
                self.state = 2715
                self.match(sqlParser.T__3)
                self.state = 2716
                self.dataType()
                self.state = 2717
                self.match(sqlParser.GT)
                pass

            elif la_ == 3:
                localctx = sqlParser.ComplexDataTypeContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 2719
                localctx.qpdcomplex = self.match(sqlParser.STRUCT)
                self.state = 2726
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [sqlParser.LT]:
                    self.state = 2720
                    self.match(sqlParser.LT)
                    self.state = 2722
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,346,self._ctx)
                    if la_ == 1:
                        self.state = 2721
                        self.complexColTypeList()


                    self.state = 2724
                    self.match(sqlParser.GT)
                    pass
                elif token in [sqlParser.NEQ]:
                    self.state = 2725
                    self.match(sqlParser.NEQ)
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 4:
                localctx = sqlParser.PrimitiveDataTypeContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 2728
                self.identifier()
                self.state = 2739
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,349,self._ctx)
                if la_ == 1:
                    self.state = 2729
                    self.match(sqlParser.T__1)
                    self.state = 2730
                    self.match(sqlParser.INTEGER_VALUE)
                    self.state = 2735
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==sqlParser.T__3:
                        self.state = 2731
                        self.match(sqlParser.T__3)
                        self.state = 2732
                        self.match(sqlParser.INTEGER_VALUE)
                        self.state = 2737
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 2738
                    self.match(sqlParser.T__2)


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QualifiedColTypeWithPositionListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def qualifiedColTypeWithPosition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.QualifiedColTypeWithPositionContext)
            else:
                return self.getTypedRuleContext(sqlParser.QualifiedColTypeWithPositionContext,i)


        def getRuleIndex(self):
            return sqlParser.RULE_qualifiedColTypeWithPositionList

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQualifiedColTypeWithPositionList" ):
                return visitor.visitQualifiedColTypeWithPositionList(self)
            else:
                return visitor.visitChildren(self)




    def qualifiedColTypeWithPositionList(self):

        localctx = sqlParser.QualifiedColTypeWithPositionListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 224, self.RULE_qualifiedColTypeWithPositionList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2743
            self.qualifiedColTypeWithPosition()
            self.state = 2748
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==sqlParser.T__3:
                self.state = 2744
                self.match(sqlParser.T__3)
                self.state = 2745
                self.qualifiedColTypeWithPosition()
                self.state = 2750
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QualifiedColTypeWithPositionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # MultipartIdentifierContext

        def dataType(self):
            return self.getTypedRuleContext(sqlParser.DataTypeContext,0)


        def multipartIdentifier(self):
            return self.getTypedRuleContext(sqlParser.MultipartIdentifierContext,0)


        def NOT(self):
            return self.getToken(sqlParser.NOT, 0)

        def NULL(self):
            return self.getToken(sqlParser.NULL, 0)

        def commentSpec(self):
            return self.getTypedRuleContext(sqlParser.CommentSpecContext,0)


        def colPosition(self):
            return self.getTypedRuleContext(sqlParser.ColPositionContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_qualifiedColTypeWithPosition

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQualifiedColTypeWithPosition" ):
                return visitor.visitQualifiedColTypeWithPosition(self)
            else:
                return visitor.visitChildren(self)




    def qualifiedColTypeWithPosition(self):

        localctx = sqlParser.QualifiedColTypeWithPositionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 226, self.RULE_qualifiedColTypeWithPosition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2751
            localctx.name = self.multipartIdentifier()
            self.state = 2752
            self.dataType()
            self.state = 2755
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==sqlParser.NOT:
                self.state = 2753
                self.match(sqlParser.NOT)
                self.state = 2754
                self.match(sqlParser.NULL)


            self.state = 2758
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==sqlParser.COMMENT:
                self.state = 2757
                self.commentSpec()


            self.state = 2761
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==sqlParser.AFTER or _la==sqlParser.FIRST:
                self.state = 2760
                self.colPosition()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ColTypeListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def colType(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.ColTypeContext)
            else:
                return self.getTypedRuleContext(sqlParser.ColTypeContext,i)


        def getRuleIndex(self):
            return sqlParser.RULE_colTypeList

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColTypeList" ):
                return visitor.visitColTypeList(self)
            else:
                return visitor.visitChildren(self)




    def colTypeList(self):

        localctx = sqlParser.ColTypeListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 228, self.RULE_colTypeList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2763
            self.colType()
            self.state = 2768
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,355,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 2764
                    self.match(sqlParser.T__3)
                    self.state = 2765
                    self.colType() 
                self.state = 2770
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,355,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ColTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.colName = None # ErrorCapturingIdentifierContext

        def dataType(self):
            return self.getTypedRuleContext(sqlParser.DataTypeContext,0)


        def errorCapturingIdentifier(self):
            return self.getTypedRuleContext(sqlParser.ErrorCapturingIdentifierContext,0)


        def NOT(self):
            return self.getToken(sqlParser.NOT, 0)

        def NULL(self):
            return self.getToken(sqlParser.NULL, 0)

        def commentSpec(self):
            return self.getTypedRuleContext(sqlParser.CommentSpecContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_colType

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColType" ):
                return visitor.visitColType(self)
            else:
                return visitor.visitChildren(self)




    def colType(self):

        localctx = sqlParser.ColTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 230, self.RULE_colType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2771
            localctx.colName = self.errorCapturingIdentifier()
            self.state = 2772
            self.dataType()
            self.state = 2775
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,356,self._ctx)
            if la_ == 1:
                self.state = 2773
                self.match(sqlParser.NOT)
                self.state = 2774
                self.match(sqlParser.NULL)


            self.state = 2778
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,357,self._ctx)
            if la_ == 1:
                self.state = 2777
                self.commentSpec()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComplexColTypeListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def complexColType(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.ComplexColTypeContext)
            else:
                return self.getTypedRuleContext(sqlParser.ComplexColTypeContext,i)


        def getRuleIndex(self):
            return sqlParser.RULE_complexColTypeList

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComplexColTypeList" ):
                return visitor.visitComplexColTypeList(self)
            else:
                return visitor.visitChildren(self)




    def complexColTypeList(self):

        localctx = sqlParser.ComplexColTypeListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 232, self.RULE_complexColTypeList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2780
            self.complexColType()
            self.state = 2785
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==sqlParser.T__3:
                self.state = 2781
                self.match(sqlParser.T__3)
                self.state = 2782
                self.complexColType()
                self.state = 2787
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComplexColTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(sqlParser.IdentifierContext,0)


        def dataType(self):
            return self.getTypedRuleContext(sqlParser.DataTypeContext,0)


        def NOT(self):
            return self.getToken(sqlParser.NOT, 0)

        def NULL(self):
            return self.getToken(sqlParser.NULL, 0)

        def commentSpec(self):
            return self.getTypedRuleContext(sqlParser.CommentSpecContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_complexColType

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComplexColType" ):
                return visitor.visitComplexColType(self)
            else:
                return visitor.visitChildren(self)




    def complexColType(self):

        localctx = sqlParser.ComplexColTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 234, self.RULE_complexColType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2788
            self.identifier()
            self.state = 2789
            self.match(sqlParser.T__10)
            self.state = 2790
            self.dataType()
            self.state = 2793
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==sqlParser.NOT:
                self.state = 2791
                self.match(sqlParser.NOT)
                self.state = 2792
                self.match(sqlParser.NULL)


            self.state = 2796
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==sqlParser.COMMENT:
                self.state = 2795
                self.commentSpec()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WhenClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.condition = None # ExpressionContext
            self.result = None # ExpressionContext

        def WHEN(self):
            return self.getToken(sqlParser.WHEN, 0)

        def THEN(self):
            return self.getToken(sqlParser.THEN, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(sqlParser.ExpressionContext,i)


        def getRuleIndex(self):
            return sqlParser.RULE_whenClause

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhenClause" ):
                return visitor.visitWhenClause(self)
            else:
                return visitor.visitChildren(self)




    def whenClause(self):

        localctx = sqlParser.WhenClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 236, self.RULE_whenClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2798
            self.match(sqlParser.WHEN)
            self.state = 2799
            localctx.condition = self.expression()
            self.state = 2800
            self.match(sqlParser.THEN)
            self.state = 2801
            localctx.result = self.expression()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WindowClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WINDOW(self):
            return self.getToken(sqlParser.WINDOW, 0)

        def namedWindow(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.NamedWindowContext)
            else:
                return self.getTypedRuleContext(sqlParser.NamedWindowContext,i)


        def getRuleIndex(self):
            return sqlParser.RULE_windowClause

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWindowClause" ):
                return visitor.visitWindowClause(self)
            else:
                return visitor.visitChildren(self)




    def windowClause(self):

        localctx = sqlParser.WindowClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 238, self.RULE_windowClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2803
            self.match(sqlParser.WINDOW)
            self.state = 2804
            self.namedWindow()
            self.state = 2809
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,361,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 2805
                    self.match(sqlParser.T__3)
                    self.state = 2806
                    self.namedWindow() 
                self.state = 2811
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,361,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NamedWindowContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # ErrorCapturingIdentifierContext

        def AS(self):
            return self.getToken(sqlParser.AS, 0)

        def windowSpec(self):
            return self.getTypedRuleContext(sqlParser.WindowSpecContext,0)


        def errorCapturingIdentifier(self):
            return self.getTypedRuleContext(sqlParser.ErrorCapturingIdentifierContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_namedWindow

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNamedWindow" ):
                return visitor.visitNamedWindow(self)
            else:
                return visitor.visitChildren(self)




    def namedWindow(self):

        localctx = sqlParser.NamedWindowContext(self, self._ctx, self.state)
        self.enterRule(localctx, 240, self.RULE_namedWindow)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2812
            localctx.name = self.errorCapturingIdentifier()
            self.state = 2813
            self.match(sqlParser.AS)
            self.state = 2814
            self.windowSpec()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WindowSpecContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return sqlParser.RULE_windowSpec

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class WindowRefContext(WindowSpecContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.WindowSpecContext
            super().__init__(parser)
            self.name = None # ErrorCapturingIdentifierContext
            self.copyFrom(ctx)

        def errorCapturingIdentifier(self):
            return self.getTypedRuleContext(sqlParser.ErrorCapturingIdentifierContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWindowRef" ):
                return visitor.visitWindowRef(self)
            else:
                return visitor.visitChildren(self)


    class WindowDefContext(WindowSpecContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.WindowSpecContext
            super().__init__(parser)
            self._expression = None # ExpressionContext
            self.partition = list() # of ExpressionContexts
            self.copyFrom(ctx)

        def CLUSTER(self):
            return self.getToken(sqlParser.CLUSTER, 0)
        def BY(self, i:int=None):
            if i is None:
                return self.getTokens(sqlParser.BY)
            else:
                return self.getToken(sqlParser.BY, i)
        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(sqlParser.ExpressionContext,i)

        def windowFrame(self):
            return self.getTypedRuleContext(sqlParser.WindowFrameContext,0)

        def sortItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.SortItemContext)
            else:
                return self.getTypedRuleContext(sqlParser.SortItemContext,i)

        def PARTITION(self):
            return self.getToken(sqlParser.PARTITION, 0)
        def DISTRIBUTE(self):
            return self.getToken(sqlParser.DISTRIBUTE, 0)
        def ORDER(self):
            return self.getToken(sqlParser.ORDER, 0)
        def SORT(self):
            return self.getToken(sqlParser.SORT, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWindowDef" ):
                return visitor.visitWindowDef(self)
            else:
                return visitor.visitChildren(self)



    def windowSpec(self):

        localctx = sqlParser.WindowSpecContext(self, self._ctx, self.state)
        self.enterRule(localctx, 242, self.RULE_windowSpec)
        self._la = 0 # Token type
        try:
            self.state = 2862
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,369,self._ctx)
            if la_ == 1:
                localctx = sqlParser.WindowRefContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 2816
                localctx.name = self.errorCapturingIdentifier()
                pass

            elif la_ == 2:
                localctx = sqlParser.WindowRefContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 2817
                self.match(sqlParser.T__1)
                self.state = 2818
                localctx.name = self.errorCapturingIdentifier()
                self.state = 2819
                self.match(sqlParser.T__2)
                pass

            elif la_ == 3:
                localctx = sqlParser.WindowDefContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 2821
                self.match(sqlParser.T__1)
                self.state = 2856
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [sqlParser.CLUSTER]:
                    self.state = 2822
                    self.match(sqlParser.CLUSTER)
                    self.state = 2823
                    self.match(sqlParser.BY)
                    self.state = 2824
                    localctx._expression = self.expression()
                    localctx.partition.append(localctx._expression)
                    self.state = 2829
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==sqlParser.T__3:
                        self.state = 2825
                        self.match(sqlParser.T__3)
                        self.state = 2826
                        localctx._expression = self.expression()
                        localctx.partition.append(localctx._expression)
                        self.state = 2831
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    pass
                elif token in [sqlParser.T__2, sqlParser.DISTRIBUTE, sqlParser.ORDER, sqlParser.PARTITION, sqlParser.RANGE, sqlParser.ROWS, sqlParser.SORT]:
                    self.state = 2842
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==sqlParser.DISTRIBUTE or _la==sqlParser.PARTITION:
                        self.state = 2832
                        _la = self._input.LA(1)
                        if not(_la==sqlParser.DISTRIBUTE or _la==sqlParser.PARTITION):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 2833
                        self.match(sqlParser.BY)
                        self.state = 2834
                        localctx._expression = self.expression()
                        localctx.partition.append(localctx._expression)
                        self.state = 2839
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        while _la==sqlParser.T__3:
                            self.state = 2835
                            self.match(sqlParser.T__3)
                            self.state = 2836
                            localctx._expression = self.expression()
                            localctx.partition.append(localctx._expression)
                            self.state = 2841
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)



                    self.state = 2854
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==sqlParser.ORDER or _la==sqlParser.SORT:
                        self.state = 2844
                        _la = self._input.LA(1)
                        if not(_la==sqlParser.ORDER or _la==sqlParser.SORT):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 2845
                        self.match(sqlParser.BY)
                        self.state = 2846
                        self.sortItem()
                        self.state = 2851
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        while _la==sqlParser.T__3:
                            self.state = 2847
                            self.match(sqlParser.T__3)
                            self.state = 2848
                            self.sortItem()
                            self.state = 2853
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)



                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 2859
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.RANGE or _la==sqlParser.ROWS:
                    self.state = 2858
                    self.windowFrame()


                self.state = 2861
                self.match(sqlParser.T__2)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WindowFrameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.frameType = None # Token
            self.start = None # FrameBoundContext
            self.end = None # FrameBoundContext

        def RANGE(self):
            return self.getToken(sqlParser.RANGE, 0)

        def frameBound(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.FrameBoundContext)
            else:
                return self.getTypedRuleContext(sqlParser.FrameBoundContext,i)


        def ROWS(self):
            return self.getToken(sqlParser.ROWS, 0)

        def BETWEEN(self):
            return self.getToken(sqlParser.BETWEEN, 0)

        def AND(self):
            return self.getToken(sqlParser.AND, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_windowFrame

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWindowFrame" ):
                return visitor.visitWindowFrame(self)
            else:
                return visitor.visitChildren(self)




    def windowFrame(self):

        localctx = sqlParser.WindowFrameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 244, self.RULE_windowFrame)
        try:
            self.state = 2880
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,370,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2864
                localctx.frameType = self.match(sqlParser.RANGE)
                self.state = 2865
                localctx.start = self.frameBound()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2866
                localctx.frameType = self.match(sqlParser.ROWS)
                self.state = 2867
                localctx.start = self.frameBound()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2868
                localctx.frameType = self.match(sqlParser.RANGE)
                self.state = 2869
                self.match(sqlParser.BETWEEN)
                self.state = 2870
                localctx.start = self.frameBound()
                self.state = 2871
                self.match(sqlParser.AND)
                self.state = 2872
                localctx.end = self.frameBound()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2874
                localctx.frameType = self.match(sqlParser.ROWS)
                self.state = 2875
                self.match(sqlParser.BETWEEN)
                self.state = 2876
                localctx.start = self.frameBound()
                self.state = 2877
                self.match(sqlParser.AND)
                self.state = 2878
                localctx.end = self.frameBound()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FrameBoundContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.boundType = None # Token

        def UNBOUNDED(self):
            return self.getToken(sqlParser.UNBOUNDED, 0)

        def PRECEDING(self):
            return self.getToken(sqlParser.PRECEDING, 0)

        def FOLLOWING(self):
            return self.getToken(sqlParser.FOLLOWING, 0)

        def ROW(self):
            return self.getToken(sqlParser.ROW, 0)

        def CURRENT(self):
            return self.getToken(sqlParser.CURRENT, 0)

        def expression(self):
            return self.getTypedRuleContext(sqlParser.ExpressionContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_frameBound

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFrameBound" ):
                return visitor.visitFrameBound(self)
            else:
                return visitor.visitChildren(self)




    def frameBound(self):

        localctx = sqlParser.FrameBoundContext(self, self._ctx, self.state)
        self.enterRule(localctx, 246, self.RULE_frameBound)
        self._la = 0 # Token type
        try:
            self.state = 2889
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,371,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2882
                self.match(sqlParser.UNBOUNDED)
                self.state = 2883
                localctx.boundType = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==sqlParser.FOLLOWING or _la==sqlParser.PRECEDING):
                    localctx.boundType = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2884
                localctx.boundType = self.match(sqlParser.CURRENT)
                self.state = 2885
                self.match(sqlParser.ROW)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2886
                self.expression()
                self.state = 2887
                localctx.boundType = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==sqlParser.FOLLOWING or _la==sqlParser.PRECEDING):
                    localctx.boundType = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QualifiedNameListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def qualifiedName(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.QualifiedNameContext)
            else:
                return self.getTypedRuleContext(sqlParser.QualifiedNameContext,i)


        def getRuleIndex(self):
            return sqlParser.RULE_qualifiedNameList

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQualifiedNameList" ):
                return visitor.visitQualifiedNameList(self)
            else:
                return visitor.visitChildren(self)




    def qualifiedNameList(self):

        localctx = sqlParser.QualifiedNameListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 248, self.RULE_qualifiedNameList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2891
            self.qualifiedName()
            self.state = 2896
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==sqlParser.T__3:
                self.state = 2892
                self.match(sqlParser.T__3)
                self.state = 2893
                self.qualifiedName()
                self.state = 2898
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def qualifiedName(self):
            return self.getTypedRuleContext(sqlParser.QualifiedNameContext,0)


        def FILTER(self):
            return self.getToken(sqlParser.FILTER, 0)

        def LEFT(self):
            return self.getToken(sqlParser.LEFT, 0)

        def RIGHT(self):
            return self.getToken(sqlParser.RIGHT, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_functionName

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionName" ):
                return visitor.visitFunctionName(self)
            else:
                return visitor.visitChildren(self)




    def functionName(self):

        localctx = sqlParser.FunctionNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 250, self.RULE_functionName)
        try:
            self.state = 2903
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,373,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2899
                self.qualifiedName()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2900
                self.match(sqlParser.FILTER)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2901
                self.match(sqlParser.LEFT)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2902
                self.match(sqlParser.RIGHT)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QualifiedNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(sqlParser.IdentifierContext,i)


        def getRuleIndex(self):
            return sqlParser.RULE_qualifiedName

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQualifiedName" ):
                return visitor.visitQualifiedName(self)
            else:
                return visitor.visitChildren(self)




    def qualifiedName(self):

        localctx = sqlParser.QualifiedNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 252, self.RULE_qualifiedName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2905
            self.identifier()
            self.state = 2910
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,374,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 2906
                    self.match(sqlParser.T__4)
                    self.state = 2907
                    self.identifier() 
                self.state = 2912
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,374,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ErrorCapturingIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(sqlParser.IdentifierContext,0)


        def errorCapturingIdentifierExtra(self):
            return self.getTypedRuleContext(sqlParser.ErrorCapturingIdentifierExtraContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_errorCapturingIdentifier

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitErrorCapturingIdentifier" ):
                return visitor.visitErrorCapturingIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def errorCapturingIdentifier(self):

        localctx = sqlParser.ErrorCapturingIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 254, self.RULE_errorCapturingIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2913
            self.identifier()
            self.state = 2914
            self.errorCapturingIdentifierExtra()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ErrorCapturingIdentifierExtraContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return sqlParser.RULE_errorCapturingIdentifierExtra

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class ErrorIdentContext(ErrorCapturingIdentifierExtraContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.ErrorCapturingIdentifierExtraContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def MINUS(self, i:int=None):
            if i is None:
                return self.getTokens(sqlParser.MINUS)
            else:
                return self.getToken(sqlParser.MINUS, i)
        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(sqlParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(sqlParser.IdentifierContext,i)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitErrorIdent" ):
                return visitor.visitErrorIdent(self)
            else:
                return visitor.visitChildren(self)


    class RealIdentContext(ErrorCapturingIdentifierExtraContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.ErrorCapturingIdentifierExtraContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRealIdent" ):
                return visitor.visitRealIdent(self)
            else:
                return visitor.visitChildren(self)



    def errorCapturingIdentifierExtra(self):

        localctx = sqlParser.ErrorCapturingIdentifierExtraContext(self, self._ctx, self.state)
        self.enterRule(localctx, 256, self.RULE_errorCapturingIdentifierExtra)
        try:
            self.state = 2923
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,376,self._ctx)
            if la_ == 1:
                localctx = sqlParser.ErrorIdentContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 2918 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 2916
                        self.match(sqlParser.MINUS)
                        self.state = 2917
                        self.identifier()

                    else:
                        raise NoViableAltException(self)
                    self.state = 2920 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,375,self._ctx)

                pass

            elif la_ == 2:
                localctx = sqlParser.RealIdentContext(self, localctx)
                self.enterOuterAlt(localctx, 2)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def strictIdentifier(self):
            return self.getTypedRuleContext(sqlParser.StrictIdentifierContext,0)


        def strictNonReserved(self):
            return self.getTypedRuleContext(sqlParser.StrictNonReservedContext,0)


        def getRuleIndex(self):
            return sqlParser.RULE_identifier

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdentifier" ):
                return visitor.visitIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def identifier(self):

        localctx = sqlParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 258, self.RULE_identifier)
        try:
            self.state = 2928
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,377,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2925
                self.strictIdentifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2926
                if not not self.SQL_standard_keyword_behavior:
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "not self.SQL_standard_keyword_behavior")
                self.state = 2927
                self.strictNonReserved()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StrictIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return sqlParser.RULE_strictIdentifier

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class QuotedIdentifierAlternativeContext(StrictIdentifierContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StrictIdentifierContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def quotedIdentifier(self):
            return self.getTypedRuleContext(sqlParser.QuotedIdentifierContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQuotedIdentifierAlternative" ):
                return visitor.visitQuotedIdentifierAlternative(self)
            else:
                return visitor.visitChildren(self)


    class UnquotedIdentifierContext(StrictIdentifierContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.StrictIdentifierContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def IDENTIFIER(self):
            return self.getToken(sqlParser.IDENTIFIER, 0)
        def ansiNonReserved(self):
            return self.getTypedRuleContext(sqlParser.AnsiNonReservedContext,0)

        def nonReserved(self):
            return self.getTypedRuleContext(sqlParser.NonReservedContext,0)


        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnquotedIdentifier" ):
                return visitor.visitUnquotedIdentifier(self)
            else:
                return visitor.visitChildren(self)



    def strictIdentifier(self):

        localctx = sqlParser.StrictIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 260, self.RULE_strictIdentifier)
        try:
            self.state = 2936
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,378,self._ctx)
            if la_ == 1:
                localctx = sqlParser.UnquotedIdentifierContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 2930
                self.match(sqlParser.IDENTIFIER)
                pass

            elif la_ == 2:
                localctx = sqlParser.QuotedIdentifierAlternativeContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 2931
                self.quotedIdentifier()
                pass

            elif la_ == 3:
                localctx = sqlParser.UnquotedIdentifierContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 2932
                if not self.SQL_standard_keyword_behavior:
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.SQL_standard_keyword_behavior")
                self.state = 2933
                self.ansiNonReserved()
                pass

            elif la_ == 4:
                localctx = sqlParser.UnquotedIdentifierContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 2934
                if not not self.SQL_standard_keyword_behavior:
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "not self.SQL_standard_keyword_behavior")
                self.state = 2935
                self.nonReserved()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QuotedIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BACKQUOTED_IDENTIFIER(self):
            return self.getToken(sqlParser.BACKQUOTED_IDENTIFIER, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_quotedIdentifier

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQuotedIdentifier" ):
                return visitor.visitQuotedIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def quotedIdentifier(self):

        localctx = sqlParser.QuotedIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 262, self.RULE_quotedIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2938
            self.match(sqlParser.BACKQUOTED_IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return sqlParser.RULE_number

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class DecimalLiteralContext(NumberContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.NumberContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DECIMAL_VALUE(self):
            return self.getToken(sqlParser.DECIMAL_VALUE, 0)
        def MINUS(self):
            return self.getToken(sqlParser.MINUS, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDecimalLiteral" ):
                return visitor.visitDecimalLiteral(self)
            else:
                return visitor.visitChildren(self)


    class BigIntLiteralContext(NumberContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.NumberContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def BIGINT_LITERAL(self):
            return self.getToken(sqlParser.BIGINT_LITERAL, 0)
        def MINUS(self):
            return self.getToken(sqlParser.MINUS, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBigIntLiteral" ):
                return visitor.visitBigIntLiteral(self)
            else:
                return visitor.visitChildren(self)


    class TinyIntLiteralContext(NumberContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.NumberContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def TINYINT_LITERAL(self):
            return self.getToken(sqlParser.TINYINT_LITERAL, 0)
        def MINUS(self):
            return self.getToken(sqlParser.MINUS, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTinyIntLiteral" ):
                return visitor.visitTinyIntLiteral(self)
            else:
                return visitor.visitChildren(self)


    class LegacyDecimalLiteralContext(NumberContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.NumberContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def EXPONENT_VALUE(self):
            return self.getToken(sqlParser.EXPONENT_VALUE, 0)
        def DECIMAL_VALUE(self):
            return self.getToken(sqlParser.DECIMAL_VALUE, 0)
        def MINUS(self):
            return self.getToken(sqlParser.MINUS, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLegacyDecimalLiteral" ):
                return visitor.visitLegacyDecimalLiteral(self)
            else:
                return visitor.visitChildren(self)


    class BigDecimalLiteralContext(NumberContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.NumberContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def BIGDECIMAL_LITERAL(self):
            return self.getToken(sqlParser.BIGDECIMAL_LITERAL, 0)
        def MINUS(self):
            return self.getToken(sqlParser.MINUS, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBigDecimalLiteral" ):
                return visitor.visitBigDecimalLiteral(self)
            else:
                return visitor.visitChildren(self)


    class ExponentLiteralContext(NumberContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.NumberContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def EXPONENT_VALUE(self):
            return self.getToken(sqlParser.EXPONENT_VALUE, 0)
        def MINUS(self):
            return self.getToken(sqlParser.MINUS, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExponentLiteral" ):
                return visitor.visitExponentLiteral(self)
            else:
                return visitor.visitChildren(self)


    class DoubleLiteralContext(NumberContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.NumberContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DOUBLE_LITERAL(self):
            return self.getToken(sqlParser.DOUBLE_LITERAL, 0)
        def MINUS(self):
            return self.getToken(sqlParser.MINUS, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDoubleLiteral" ):
                return visitor.visitDoubleLiteral(self)
            else:
                return visitor.visitChildren(self)


    class IntegerLiteralContext(NumberContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.NumberContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def INTEGER_VALUE(self):
            return self.getToken(sqlParser.INTEGER_VALUE, 0)
        def MINUS(self):
            return self.getToken(sqlParser.MINUS, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIntegerLiteral" ):
                return visitor.visitIntegerLiteral(self)
            else:
                return visitor.visitChildren(self)


    class SmallIntLiteralContext(NumberContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a sqlParser.NumberContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def SMALLINT_LITERAL(self):
            return self.getToken(sqlParser.SMALLINT_LITERAL, 0)
        def MINUS(self):
            return self.getToken(sqlParser.MINUS, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSmallIntLiteral" ):
                return visitor.visitSmallIntLiteral(self)
            else:
                return visitor.visitChildren(self)



    def number(self):

        localctx = sqlParser.NumberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 264, self.RULE_number)
        self._la = 0 # Token type
        try:
            self.state = 2979
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,388,self._ctx)
            if la_ == 1:
                localctx = sqlParser.ExponentLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 2940
                if not not self.legacy_exponent_literal_as_decimal_enabled:
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "not self.legacy_exponent_literal_as_decimal_enabled")
                self.state = 2942
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.MINUS:
                    self.state = 2941
                    self.match(sqlParser.MINUS)


                self.state = 2944
                self.match(sqlParser.EXPONENT_VALUE)
                pass

            elif la_ == 2:
                localctx = sqlParser.DecimalLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 2945
                if not not self.legacy_exponent_literal_as_decimal_enabled:
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "not self.legacy_exponent_literal_as_decimal_enabled")
                self.state = 2947
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.MINUS:
                    self.state = 2946
                    self.match(sqlParser.MINUS)


                self.state = 2949
                self.match(sqlParser.DECIMAL_VALUE)
                pass

            elif la_ == 3:
                localctx = sqlParser.LegacyDecimalLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 2950
                if not self.legacy_exponent_literal_as_decimal_enabled:
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "self.legacy_exponent_literal_as_decimal_enabled")
                self.state = 2952
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.MINUS:
                    self.state = 2951
                    self.match(sqlParser.MINUS)


                self.state = 2954
                _la = self._input.LA(1)
                if not(_la==sqlParser.EXPONENT_VALUE or _la==sqlParser.DECIMAL_VALUE):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 4:
                localctx = sqlParser.IntegerLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 2956
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.MINUS:
                    self.state = 2955
                    self.match(sqlParser.MINUS)


                self.state = 2958
                self.match(sqlParser.INTEGER_VALUE)
                pass

            elif la_ == 5:
                localctx = sqlParser.BigIntLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 2960
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.MINUS:
                    self.state = 2959
                    self.match(sqlParser.MINUS)


                self.state = 2962
                self.match(sqlParser.BIGINT_LITERAL)
                pass

            elif la_ == 6:
                localctx = sqlParser.SmallIntLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 2964
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.MINUS:
                    self.state = 2963
                    self.match(sqlParser.MINUS)


                self.state = 2966
                self.match(sqlParser.SMALLINT_LITERAL)
                pass

            elif la_ == 7:
                localctx = sqlParser.TinyIntLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 2968
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.MINUS:
                    self.state = 2967
                    self.match(sqlParser.MINUS)


                self.state = 2970
                self.match(sqlParser.TINYINT_LITERAL)
                pass

            elif la_ == 8:
                localctx = sqlParser.DoubleLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 2972
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.MINUS:
                    self.state = 2971
                    self.match(sqlParser.MINUS)


                self.state = 2974
                self.match(sqlParser.DOUBLE_LITERAL)
                pass

            elif la_ == 9:
                localctx = sqlParser.BigDecimalLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 9)
                self.state = 2976
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==sqlParser.MINUS:
                    self.state = 2975
                    self.match(sqlParser.MINUS)


                self.state = 2978
                self.match(sqlParser.BIGDECIMAL_LITERAL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlterColumnActionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.setOrDrop = None # Token

        def TYPE(self):
            return self.getToken(sqlParser.TYPE, 0)

        def dataType(self):
            return self.getTypedRuleContext(sqlParser.DataTypeContext,0)


        def commentSpec(self):
            return self.getTypedRuleContext(sqlParser.CommentSpecContext,0)


        def colPosition(self):
            return self.getTypedRuleContext(sqlParser.ColPositionContext,0)


        def NOT(self):
            return self.getToken(sqlParser.NOT, 0)

        def NULL(self):
            return self.getToken(sqlParser.NULL, 0)

        def SET(self):
            return self.getToken(sqlParser.SET, 0)

        def DROP(self):
            return self.getToken(sqlParser.DROP, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_alterColumnAction

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlterColumnAction" ):
                return visitor.visitAlterColumnAction(self)
            else:
                return visitor.visitChildren(self)




    def alterColumnAction(self):

        localctx = sqlParser.AlterColumnActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 266, self.RULE_alterColumnAction)
        self._la = 0 # Token type
        try:
            self.state = 2988
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [sqlParser.TYPE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2981
                self.match(sqlParser.TYPE)
                self.state = 2982
                self.dataType()
                pass
            elif token in [sqlParser.COMMENT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2983
                self.commentSpec()
                pass
            elif token in [sqlParser.AFTER, sqlParser.FIRST]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2984
                self.colPosition()
                pass
            elif token in [sqlParser.DROP, sqlParser.SET]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2985
                localctx.setOrDrop = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==sqlParser.DROP or _la==sqlParser.SET):
                    localctx.setOrDrop = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2986
                self.match(sqlParser.NOT)
                self.state = 2987
                self.match(sqlParser.NULL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AnsiNonReservedContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ADD(self):
            return self.getToken(sqlParser.ADD, 0)

        def AFTER(self):
            return self.getToken(sqlParser.AFTER, 0)

        def ALTER(self):
            return self.getToken(sqlParser.ALTER, 0)

        def ANALYZE(self):
            return self.getToken(sqlParser.ANALYZE, 0)

        def ARCHIVE(self):
            return self.getToken(sqlParser.ARCHIVE, 0)

        def ARRAY(self):
            return self.getToken(sqlParser.ARRAY, 0)

        def ASC(self):
            return self.getToken(sqlParser.ASC, 0)

        def AT(self):
            return self.getToken(sqlParser.AT, 0)

        def BETWEEN(self):
            return self.getToken(sqlParser.BETWEEN, 0)

        def BUCKET(self):
            return self.getToken(sqlParser.BUCKET, 0)

        def BUCKETS(self):
            return self.getToken(sqlParser.BUCKETS, 0)

        def BY(self):
            return self.getToken(sqlParser.BY, 0)

        def CACHE(self):
            return self.getToken(sqlParser.CACHE, 0)

        def CASCADE(self):
            return self.getToken(sqlParser.CASCADE, 0)

        def CHANGE(self):
            return self.getToken(sqlParser.CHANGE, 0)

        def CLEAR(self):
            return self.getToken(sqlParser.CLEAR, 0)

        def CLUSTER(self):
            return self.getToken(sqlParser.CLUSTER, 0)

        def CLUSTERED(self):
            return self.getToken(sqlParser.CLUSTERED, 0)

        def CODEGEN(self):
            return self.getToken(sqlParser.CODEGEN, 0)

        def COLLECTION(self):
            return self.getToken(sqlParser.COLLECTION, 0)

        def COLUMNS(self):
            return self.getToken(sqlParser.COLUMNS, 0)

        def COMMENT(self):
            return self.getToken(sqlParser.COMMENT, 0)

        def COMMIT(self):
            return self.getToken(sqlParser.COMMIT, 0)

        def COMPACT(self):
            return self.getToken(sqlParser.COMPACT, 0)

        def COMPACTIONS(self):
            return self.getToken(sqlParser.COMPACTIONS, 0)

        def COMPUTE(self):
            return self.getToken(sqlParser.COMPUTE, 0)

        def CONCATENATE(self):
            return self.getToken(sqlParser.CONCATENATE, 0)

        def COST(self):
            return self.getToken(sqlParser.COST, 0)

        def CUBE(self):
            return self.getToken(sqlParser.CUBE, 0)

        def CURRENT(self):
            return self.getToken(sqlParser.CURRENT, 0)

        def DATA(self):
            return self.getToken(sqlParser.DATA, 0)

        def DATABASE(self):
            return self.getToken(sqlParser.DATABASE, 0)

        def DATABASES(self):
            return self.getToken(sqlParser.DATABASES, 0)

        def DBPROPERTIES(self):
            return self.getToken(sqlParser.DBPROPERTIES, 0)

        def DEFINED(self):
            return self.getToken(sqlParser.DEFINED, 0)

        def DELETE(self):
            return self.getToken(sqlParser.DELETE, 0)

        def DELIMITED(self):
            return self.getToken(sqlParser.DELIMITED, 0)

        def DESC(self):
            return self.getToken(sqlParser.DESC, 0)

        def DESCRIBE(self):
            return self.getToken(sqlParser.DESCRIBE, 0)

        def DFS(self):
            return self.getToken(sqlParser.DFS, 0)

        def DIRECTORIES(self):
            return self.getToken(sqlParser.DIRECTORIES, 0)

        def DIRECTORY(self):
            return self.getToken(sqlParser.DIRECTORY, 0)

        def DISTRIBUTE(self):
            return self.getToken(sqlParser.DISTRIBUTE, 0)

        def DIV(self):
            return self.getToken(sqlParser.DIV, 0)

        def DROP(self):
            return self.getToken(sqlParser.DROP, 0)

        def ESCAPED(self):
            return self.getToken(sqlParser.ESCAPED, 0)

        def EXCHANGE(self):
            return self.getToken(sqlParser.EXCHANGE, 0)

        def EXISTS(self):
            return self.getToken(sqlParser.EXISTS, 0)

        def EXPLAIN(self):
            return self.getToken(sqlParser.EXPLAIN, 0)

        def EXPORT(self):
            return self.getToken(sqlParser.EXPORT, 0)

        def EXTENDED(self):
            return self.getToken(sqlParser.EXTENDED, 0)

        def EXTERNAL(self):
            return self.getToken(sqlParser.EXTERNAL, 0)

        def EXTRACT(self):
            return self.getToken(sqlParser.EXTRACT, 0)

        def FIELDS(self):
            return self.getToken(sqlParser.FIELDS, 0)

        def FILEFORMAT(self):
            return self.getToken(sqlParser.FILEFORMAT, 0)

        def FIRST(self):
            return self.getToken(sqlParser.FIRST, 0)

        def FOLLOWING(self):
            return self.getToken(sqlParser.FOLLOWING, 0)

        def FORMAT(self):
            return self.getToken(sqlParser.FORMAT, 0)

        def FORMATTED(self):
            return self.getToken(sqlParser.FORMATTED, 0)

        def FUNCTION(self):
            return self.getToken(sqlParser.FUNCTION, 0)

        def FUNCTIONS(self):
            return self.getToken(sqlParser.FUNCTIONS, 0)

        def GLOBAL(self):
            return self.getToken(sqlParser.GLOBAL, 0)

        def GROUPING(self):
            return self.getToken(sqlParser.GROUPING, 0)

        def IF(self):
            return self.getToken(sqlParser.IF, 0)

        def IGNORE(self):
            return self.getToken(sqlParser.IGNORE, 0)

        def IMPORT(self):
            return self.getToken(sqlParser.IMPORT, 0)

        def INDEX(self):
            return self.getToken(sqlParser.INDEX, 0)

        def INDEXES(self):
            return self.getToken(sqlParser.INDEXES, 0)

        def INPATH(self):
            return self.getToken(sqlParser.INPATH, 0)

        def INPUTFORMAT(self):
            return self.getToken(sqlParser.INPUTFORMAT, 0)

        def INSERT(self):
            return self.getToken(sqlParser.INSERT, 0)

        def INTERVAL(self):
            return self.getToken(sqlParser.INTERVAL, 0)

        def ITEMS(self):
            return self.getToken(sqlParser.ITEMS, 0)

        def KEYS(self):
            return self.getToken(sqlParser.KEYS, 0)

        def LAST(self):
            return self.getToken(sqlParser.LAST, 0)

        def LATERAL(self):
            return self.getToken(sqlParser.LATERAL, 0)

        def LAZY(self):
            return self.getToken(sqlParser.LAZY, 0)

        def LIKE(self):
            return self.getToken(sqlParser.LIKE, 0)

        def LIMIT(self):
            return self.getToken(sqlParser.LIMIT, 0)

        def LINES(self):
            return self.getToken(sqlParser.LINES, 0)

        def LIST(self):
            return self.getToken(sqlParser.LIST, 0)

        def LOAD(self):
            return self.getToken(sqlParser.LOAD, 0)

        def LOCAL(self):
            return self.getToken(sqlParser.LOCAL, 0)

        def LOCATION(self):
            return self.getToken(sqlParser.LOCATION, 0)

        def LOCK(self):
            return self.getToken(sqlParser.LOCK, 0)

        def LOCKS(self):
            return self.getToken(sqlParser.LOCKS, 0)

        def LOGICAL(self):
            return self.getToken(sqlParser.LOGICAL, 0)

        def MACRO(self):
            return self.getToken(sqlParser.MACRO, 0)

        def MAP(self):
            return self.getToken(sqlParser.MAP, 0)

        def MATCHED(self):
            return self.getToken(sqlParser.MATCHED, 0)

        def MERGE(self):
            return self.getToken(sqlParser.MERGE, 0)

        def MSCK(self):
            return self.getToken(sqlParser.MSCK, 0)

        def NAMESPACE(self):
            return self.getToken(sqlParser.NAMESPACE, 0)

        def NAMESPACES(self):
            return self.getToken(sqlParser.NAMESPACES, 0)

        def NO(self):
            return self.getToken(sqlParser.NO, 0)

        def NULLS(self):
            return self.getToken(sqlParser.NULLS, 0)

        def OF(self):
            return self.getToken(sqlParser.OF, 0)

        def OPTION(self):
            return self.getToken(sqlParser.OPTION, 0)

        def OPTIONS(self):
            return self.getToken(sqlParser.OPTIONS, 0)

        def OUT(self):
            return self.getToken(sqlParser.OUT, 0)

        def OUTPUTFORMAT(self):
            return self.getToken(sqlParser.OUTPUTFORMAT, 0)

        def OVER(self):
            return self.getToken(sqlParser.OVER, 0)

        def OVERLAY(self):
            return self.getToken(sqlParser.OVERLAY, 0)

        def OVERWRITE(self):
            return self.getToken(sqlParser.OVERWRITE, 0)

        def PARTITION(self):
            return self.getToken(sqlParser.PARTITION, 0)

        def PARTITIONED(self):
            return self.getToken(sqlParser.PARTITIONED, 0)

        def PARTITIONS(self):
            return self.getToken(sqlParser.PARTITIONS, 0)

        def PERCENTLIT(self):
            return self.getToken(sqlParser.PERCENTLIT, 0)

        def PIVOT(self):
            return self.getToken(sqlParser.PIVOT, 0)

        def PLACING(self):
            return self.getToken(sqlParser.PLACING, 0)

        def POSITION(self):
            return self.getToken(sqlParser.POSITION, 0)

        def PRECEDING(self):
            return self.getToken(sqlParser.PRECEDING, 0)

        def PRINCIPALS(self):
            return self.getToken(sqlParser.PRINCIPALS, 0)

        def PROPERTIES(self):
            return self.getToken(sqlParser.PROPERTIES, 0)

        def PURGE(self):
            return self.getToken(sqlParser.PURGE, 0)

        def QUERY(self):
            return self.getToken(sqlParser.QUERY, 0)

        def RANGE(self):
            return self.getToken(sqlParser.RANGE, 0)

        def RECORDREADER(self):
            return self.getToken(sqlParser.RECORDREADER, 0)

        def RECORDWRITER(self):
            return self.getToken(sqlParser.RECORDWRITER, 0)

        def RECOVER(self):
            return self.getToken(sqlParser.RECOVER, 0)

        def REDUCE(self):
            return self.getToken(sqlParser.REDUCE, 0)

        def REFRESH(self):
            return self.getToken(sqlParser.REFRESH, 0)

        def RENAME(self):
            return self.getToken(sqlParser.RENAME, 0)

        def REPAIR(self):
            return self.getToken(sqlParser.REPAIR, 0)

        def REPLACE(self):
            return self.getToken(sqlParser.REPLACE, 0)

        def RESET(self):
            return self.getToken(sqlParser.RESET, 0)

        def RESTRICT(self):
            return self.getToken(sqlParser.RESTRICT, 0)

        def REVOKE(self):
            return self.getToken(sqlParser.REVOKE, 0)

        def RLIKE(self):
            return self.getToken(sqlParser.RLIKE, 0)

        def ROLE(self):
            return self.getToken(sqlParser.ROLE, 0)

        def ROLES(self):
            return self.getToken(sqlParser.ROLES, 0)

        def ROLLBACK(self):
            return self.getToken(sqlParser.ROLLBACK, 0)

        def ROLLUP(self):
            return self.getToken(sqlParser.ROLLUP, 0)

        def ROW(self):
            return self.getToken(sqlParser.ROW, 0)

        def ROWS(self):
            return self.getToken(sqlParser.ROWS, 0)

        def SCHEMA(self):
            return self.getToken(sqlParser.SCHEMA, 0)

        def SEPARATED(self):
            return self.getToken(sqlParser.SEPARATED, 0)

        def SERDE(self):
            return self.getToken(sqlParser.SERDE, 0)

        def SERDEPROPERTIES(self):
            return self.getToken(sqlParser.SERDEPROPERTIES, 0)

        def SET(self):
            return self.getToken(sqlParser.SET, 0)

        def SETS(self):
            return self.getToken(sqlParser.SETS, 0)

        def SHOW(self):
            return self.getToken(sqlParser.SHOW, 0)

        def SKEWED(self):
            return self.getToken(sqlParser.SKEWED, 0)

        def SORT(self):
            return self.getToken(sqlParser.SORT, 0)

        def SORTED(self):
            return self.getToken(sqlParser.SORTED, 0)

        def START(self):
            return self.getToken(sqlParser.START, 0)

        def STATISTICS(self):
            return self.getToken(sqlParser.STATISTICS, 0)

        def STORED(self):
            return self.getToken(sqlParser.STORED, 0)

        def STRATIFY(self):
            return self.getToken(sqlParser.STRATIFY, 0)

        def STRUCT(self):
            return self.getToken(sqlParser.STRUCT, 0)

        def SUBSTR(self):
            return self.getToken(sqlParser.SUBSTR, 0)

        def SUBSTRING(self):
            return self.getToken(sqlParser.SUBSTRING, 0)

        def TABLES(self):
            return self.getToken(sqlParser.TABLES, 0)

        def TABLESAMPLE(self):
            return self.getToken(sqlParser.TABLESAMPLE, 0)

        def TBLPROPERTIES(self):
            return self.getToken(sqlParser.TBLPROPERTIES, 0)

        def TEMPORARY(self):
            return self.getToken(sqlParser.TEMPORARY, 0)

        def TERMINATED(self):
            return self.getToken(sqlParser.TERMINATED, 0)

        def TOUCH(self):
            return self.getToken(sqlParser.TOUCH, 0)

        def TRANSACTION(self):
            return self.getToken(sqlParser.TRANSACTION, 0)

        def TRANSACTIONS(self):
            return self.getToken(sqlParser.TRANSACTIONS, 0)

        def TRANSFORM(self):
            return self.getToken(sqlParser.TRANSFORM, 0)

        def TRIM(self):
            return self.getToken(sqlParser.TRIM, 0)

        def TRUE(self):
            return self.getToken(sqlParser.TRUE, 0)

        def TRUNCATE(self):
            return self.getToken(sqlParser.TRUNCATE, 0)

        def UNARCHIVE(self):
            return self.getToken(sqlParser.UNARCHIVE, 0)

        def UNBOUNDED(self):
            return self.getToken(sqlParser.UNBOUNDED, 0)

        def UNCACHE(self):
            return self.getToken(sqlParser.UNCACHE, 0)

        def UNLOCK(self):
            return self.getToken(sqlParser.UNLOCK, 0)

        def UNSET(self):
            return self.getToken(sqlParser.UNSET, 0)

        def UPDATE(self):
            return self.getToken(sqlParser.UPDATE, 0)

        def USE(self):
            return self.getToken(sqlParser.USE, 0)

        def VALUES(self):
            return self.getToken(sqlParser.VALUES, 0)

        def VIEW(self):
            return self.getToken(sqlParser.VIEW, 0)

        def VIEWS(self):
            return self.getToken(sqlParser.VIEWS, 0)

        def WINDOW(self):
            return self.getToken(sqlParser.WINDOW, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_ansiNonReserved

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAnsiNonReserved" ):
                return visitor.visitAnsiNonReserved(self)
            else:
                return visitor.visitChildren(self)




    def ansiNonReserved(self):

        localctx = sqlParser.AnsiNonReservedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 268, self.RULE_ansiNonReserved)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2990
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << sqlParser.ADD) | (1 << sqlParser.AFTER) | (1 << sqlParser.ALTER) | (1 << sqlParser.ANALYZE) | (1 << sqlParser.ARCHIVE) | (1 << sqlParser.ARRAY) | (1 << sqlParser.ASC) | (1 << sqlParser.AT) | (1 << sqlParser.BETWEEN) | (1 << sqlParser.BUCKET) | (1 << sqlParser.BUCKETS) | (1 << sqlParser.BY) | (1 << sqlParser.CACHE) | (1 << sqlParser.CASCADE) | (1 << sqlParser.CHANGE) | (1 << sqlParser.CLEAR) | (1 << sqlParser.CLUSTER) | (1 << sqlParser.CLUSTERED) | (1 << sqlParser.CODEGEN) | (1 << sqlParser.COLLECTION) | (1 << sqlParser.COLUMNS) | (1 << sqlParser.COMMENT) | (1 << sqlParser.COMMIT) | (1 << sqlParser.COMPACT) | (1 << sqlParser.COMPACTIONS) | (1 << sqlParser.COMPUTE) | (1 << sqlParser.CONCATENATE) | (1 << sqlParser.COST) | (1 << sqlParser.CUBE) | (1 << sqlParser.CURRENT) | (1 << sqlParser.DATA) | (1 << sqlParser.DATABASE) | (1 << sqlParser.DATABASES))) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (sqlParser.DBPROPERTIES - 65)) | (1 << (sqlParser.DEFINED - 65)) | (1 << (sqlParser.DELETE - 65)) | (1 << (sqlParser.DELIMITED - 65)) | (1 << (sqlParser.DESC - 65)) | (1 << (sqlParser.DESCRIBE - 65)) | (1 << (sqlParser.DFS - 65)) | (1 << (sqlParser.DIRECTORIES - 65)) | (1 << (sqlParser.DIRECTORY - 65)) | (1 << (sqlParser.DISTRIBUTE - 65)) | (1 << (sqlParser.DROP - 65)) | (1 << (sqlParser.ESCAPED - 65)) | (1 << (sqlParser.EXCHANGE - 65)) | (1 << (sqlParser.EXISTS - 65)) | (1 << (sqlParser.EXPLAIN - 65)) | (1 << (sqlParser.EXPORT - 65)) | (1 << (sqlParser.EXTENDED - 65)) | (1 << (sqlParser.EXTERNAL - 65)) | (1 << (sqlParser.EXTRACT - 65)) | (1 << (sqlParser.FIELDS - 65)) | (1 << (sqlParser.FILEFORMAT - 65)) | (1 << (sqlParser.FIRST - 65)) | (1 << (sqlParser.FOLLOWING - 65)) | (1 << (sqlParser.FORMAT - 65)) | (1 << (sqlParser.FORMATTED - 65)) | (1 << (sqlParser.FUNCTION - 65)) | (1 << (sqlParser.FUNCTIONS - 65)) | (1 << (sqlParser.GLOBAL - 65)) | (1 << (sqlParser.GROUPING - 65)) | (1 << (sqlParser.IF - 65)) | (1 << (sqlParser.IGNORE - 65)) | (1 << (sqlParser.IMPORT - 65)) | (1 << (sqlParser.INDEX - 65)) | (1 << (sqlParser.INDEXES - 65)) | (1 << (sqlParser.INPATH - 65)) | (1 << (sqlParser.INPUTFORMAT - 65)) | (1 << (sqlParser.INSERT - 65)) | (1 << (sqlParser.INTERVAL - 65)) | (1 << (sqlParser.ITEMS - 65)) | (1 << (sqlParser.KEYS - 65)) | (1 << (sqlParser.LAST - 65)) | (1 << (sqlParser.LATERAL - 65)))) != 0) or ((((_la - 129)) & ~0x3f) == 0 and ((1 << (_la - 129)) & ((1 << (sqlParser.LAZY - 129)) | (1 << (sqlParser.LIKE - 129)) | (1 << (sqlParser.LIMIT - 129)) | (1 << (sqlParser.LINES - 129)) | (1 << (sqlParser.LIST - 129)) | (1 << (sqlParser.LOAD - 129)) | (1 << (sqlParser.LOCAL - 129)) | (1 << (sqlParser.LOCATION - 129)) | (1 << (sqlParser.LOCK - 129)) | (1 << (sqlParser.LOCKS - 129)) | (1 << (sqlParser.LOGICAL - 129)) | (1 << (sqlParser.MACRO - 129)) | (1 << (sqlParser.MAP - 129)) | (1 << (sqlParser.MATCHED - 129)) | (1 << (sqlParser.MERGE - 129)) | (1 << (sqlParser.MSCK - 129)) | (1 << (sqlParser.NAMESPACE - 129)) | (1 << (sqlParser.NAMESPACES - 129)) | (1 << (sqlParser.NO - 129)) | (1 << (sqlParser.NULLS - 129)) | (1 << (sqlParser.OF - 129)) | (1 << (sqlParser.OPTION - 129)) | (1 << (sqlParser.OPTIONS - 129)) | (1 << (sqlParser.OUT - 129)) | (1 << (sqlParser.OUTPUTFORMAT - 129)) | (1 << (sqlParser.OVER - 129)) | (1 << (sqlParser.OVERLAY - 129)) | (1 << (sqlParser.OVERWRITE - 129)) | (1 << (sqlParser.PARTITION - 129)) | (1 << (sqlParser.PARTITIONED - 129)) | (1 << (sqlParser.PARTITIONS - 129)) | (1 << (sqlParser.PERCENTLIT - 129)) | (1 << (sqlParser.PIVOT - 129)) | (1 << (sqlParser.PLACING - 129)) | (1 << (sqlParser.POSITION - 129)) | (1 << (sqlParser.PRECEDING - 129)) | (1 << (sqlParser.PRINCIPALS - 129)) | (1 << (sqlParser.PROPERTIES - 129)) | (1 << (sqlParser.PURGE - 129)) | (1 << (sqlParser.QUERY - 129)) | (1 << (sqlParser.RANGE - 129)) | (1 << (sqlParser.RECORDREADER - 129)) | (1 << (sqlParser.RECORDWRITER - 129)) | (1 << (sqlParser.RECOVER - 129)) | (1 << (sqlParser.REDUCE - 129)) | (1 << (sqlParser.REFRESH - 129)) | (1 << (sqlParser.RENAME - 129)) | (1 << (sqlParser.REPAIR - 129)) | (1 << (sqlParser.REPLACE - 129)))) != 0) or ((((_la - 193)) & ~0x3f) == 0 and ((1 << (_la - 193)) & ((1 << (sqlParser.RESET - 193)) | (1 << (sqlParser.RESTRICT - 193)) | (1 << (sqlParser.REVOKE - 193)) | (1 << (sqlParser.RLIKE - 193)) | (1 << (sqlParser.ROLE - 193)) | (1 << (sqlParser.ROLES - 193)) | (1 << (sqlParser.ROLLBACK - 193)) | (1 << (sqlParser.ROLLUP - 193)) | (1 << (sqlParser.ROW - 193)) | (1 << (sqlParser.ROWS - 193)) | (1 << (sqlParser.SCHEMA - 193)) | (1 << (sqlParser.SEPARATED - 193)) | (1 << (sqlParser.SERDE - 193)) | (1 << (sqlParser.SERDEPROPERTIES - 193)) | (1 << (sqlParser.SET - 193)) | (1 << (sqlParser.SETS - 193)) | (1 << (sqlParser.SHOW - 193)) | (1 << (sqlParser.SKEWED - 193)) | (1 << (sqlParser.SORT - 193)) | (1 << (sqlParser.SORTED - 193)) | (1 << (sqlParser.START - 193)) | (1 << (sqlParser.STATISTICS - 193)) | (1 << (sqlParser.STORED - 193)) | (1 << (sqlParser.STRATIFY - 193)) | (1 << (sqlParser.STRUCT - 193)) | (1 << (sqlParser.SUBSTR - 193)) | (1 << (sqlParser.SUBSTRING - 193)) | (1 << (sqlParser.TABLES - 193)) | (1 << (sqlParser.TABLESAMPLE - 193)) | (1 << (sqlParser.TBLPROPERTIES - 193)) | (1 << (sqlParser.TEMPORARY - 193)) | (1 << (sqlParser.TERMINATED - 193)) | (1 << (sqlParser.TOUCH - 193)) | (1 << (sqlParser.TRANSACTION - 193)) | (1 << (sqlParser.TRANSACTIONS - 193)) | (1 << (sqlParser.TRANSFORM - 193)) | (1 << (sqlParser.TRIM - 193)) | (1 << (sqlParser.TRUE - 193)) | (1 << (sqlParser.TRUNCATE - 193)) | (1 << (sqlParser.UNARCHIVE - 193)) | (1 << (sqlParser.UNBOUNDED - 193)) | (1 << (sqlParser.UNCACHE - 193)) | (1 << (sqlParser.UNLOCK - 193)) | (1 << (sqlParser.UNSET - 193)) | (1 << (sqlParser.UPDATE - 193)) | (1 << (sqlParser.USE - 193)) | (1 << (sqlParser.VALUES - 193)))) != 0) or ((((_la - 257)) & ~0x3f) == 0 and ((1 << (_la - 257)) & ((1 << (sqlParser.VIEW - 257)) | (1 << (sqlParser.VIEWS - 257)) | (1 << (sqlParser.WINDOW - 257)) | (1 << (sqlParser.DIV - 257)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StrictNonReservedContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ANTI(self):
            return self.getToken(sqlParser.ANTI, 0)

        def CROSS(self):
            return self.getToken(sqlParser.CROSS, 0)

        def EXCEPT(self):
            return self.getToken(sqlParser.EXCEPT, 0)

        def FULL(self):
            return self.getToken(sqlParser.FULL, 0)

        def INNER(self):
            return self.getToken(sqlParser.INNER, 0)

        def INTERSECT(self):
            return self.getToken(sqlParser.INTERSECT, 0)

        def JOIN(self):
            return self.getToken(sqlParser.JOIN, 0)

        def LEFT(self):
            return self.getToken(sqlParser.LEFT, 0)

        def NATURAL(self):
            return self.getToken(sqlParser.NATURAL, 0)

        def ON(self):
            return self.getToken(sqlParser.ON, 0)

        def RIGHT(self):
            return self.getToken(sqlParser.RIGHT, 0)

        def SEMI(self):
            return self.getToken(sqlParser.SEMI, 0)

        def SETMINUS(self):
            return self.getToken(sqlParser.SETMINUS, 0)

        def UNION(self):
            return self.getToken(sqlParser.UNION, 0)

        def USING(self):
            return self.getToken(sqlParser.USING, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_strictNonReserved

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStrictNonReserved" ):
                return visitor.visitStrictNonReserved(self)
            else:
                return visitor.visitChildren(self)




    def strictNonReserved(self):

        localctx = sqlParser.StrictNonReservedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 270, self.RULE_strictNonReserved)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2992
            _la = self._input.LA(1)
            if not(((((_la - 18)) & ~0x3f) == 0 and ((1 << (_la - 18)) & ((1 << (sqlParser.ANTI - 18)) | (1 << (sqlParser.CROSS - 18)) | (1 << (sqlParser.EXCEPT - 18)))) != 0) or ((((_la - 101)) & ~0x3f) == 0 and ((1 << (_la - 101)) & ((1 << (sqlParser.FULL - 101)) | (1 << (sqlParser.INNER - 101)) | (1 << (sqlParser.INTERSECT - 101)) | (1 << (sqlParser.JOIN - 101)) | (1 << (sqlParser.LEFT - 101)) | (1 << (sqlParser.NATURAL - 101)) | (1 << (sqlParser.ON - 101)))) != 0) or ((((_la - 196)) & ~0x3f) == 0 and ((1 << (_la - 196)) & ((1 << (sqlParser.RIGHT - 196)) | (1 << (sqlParser.SEMI - 196)) | (1 << (sqlParser.SETMINUS - 196)) | (1 << (sqlParser.UNION - 196)) | (1 << (sqlParser.USING - 196)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NonReservedContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ADD(self):
            return self.getToken(sqlParser.ADD, 0)

        def AFTER(self):
            return self.getToken(sqlParser.AFTER, 0)

        def ALL(self):
            return self.getToken(sqlParser.ALL, 0)

        def ALTER(self):
            return self.getToken(sqlParser.ALTER, 0)

        def ANALYZE(self):
            return self.getToken(sqlParser.ANALYZE, 0)

        def AND(self):
            return self.getToken(sqlParser.AND, 0)

        def ANY(self):
            return self.getToken(sqlParser.ANY, 0)

        def ARCHIVE(self):
            return self.getToken(sqlParser.ARCHIVE, 0)

        def ARRAY(self):
            return self.getToken(sqlParser.ARRAY, 0)

        def AS(self):
            return self.getToken(sqlParser.AS, 0)

        def ASC(self):
            return self.getToken(sqlParser.ASC, 0)

        def AT(self):
            return self.getToken(sqlParser.AT, 0)

        def AUTHORIZATION(self):
            return self.getToken(sqlParser.AUTHORIZATION, 0)

        def BETWEEN(self):
            return self.getToken(sqlParser.BETWEEN, 0)

        def BOTH(self):
            return self.getToken(sqlParser.BOTH, 0)

        def BUCKET(self):
            return self.getToken(sqlParser.BUCKET, 0)

        def BUCKETS(self):
            return self.getToken(sqlParser.BUCKETS, 0)

        def BY(self):
            return self.getToken(sqlParser.BY, 0)

        def CACHE(self):
            return self.getToken(sqlParser.CACHE, 0)

        def CASCADE(self):
            return self.getToken(sqlParser.CASCADE, 0)

        def CASE(self):
            return self.getToken(sqlParser.CASE, 0)

        def CAST(self):
            return self.getToken(sqlParser.CAST, 0)

        def CHANGE(self):
            return self.getToken(sqlParser.CHANGE, 0)

        def CHECK(self):
            return self.getToken(sqlParser.CHECK, 0)

        def CLEAR(self):
            return self.getToken(sqlParser.CLEAR, 0)

        def CLUSTER(self):
            return self.getToken(sqlParser.CLUSTER, 0)

        def CLUSTERED(self):
            return self.getToken(sqlParser.CLUSTERED, 0)

        def CODEGEN(self):
            return self.getToken(sqlParser.CODEGEN, 0)

        def COLLATE(self):
            return self.getToken(sqlParser.COLLATE, 0)

        def COLLECTION(self):
            return self.getToken(sqlParser.COLLECTION, 0)

        def COLUMN(self):
            return self.getToken(sqlParser.COLUMN, 0)

        def COLUMNS(self):
            return self.getToken(sqlParser.COLUMNS, 0)

        def COMMENT(self):
            return self.getToken(sqlParser.COMMENT, 0)

        def COMMIT(self):
            return self.getToken(sqlParser.COMMIT, 0)

        def COMPACT(self):
            return self.getToken(sqlParser.COMPACT, 0)

        def COMPACTIONS(self):
            return self.getToken(sqlParser.COMPACTIONS, 0)

        def COMPUTE(self):
            return self.getToken(sqlParser.COMPUTE, 0)

        def CONCATENATE(self):
            return self.getToken(sqlParser.CONCATENATE, 0)

        def CONSTRAINT(self):
            return self.getToken(sqlParser.CONSTRAINT, 0)

        def COST(self):
            return self.getToken(sqlParser.COST, 0)

        def CREATE(self):
            return self.getToken(sqlParser.CREATE, 0)

        def CUBE(self):
            return self.getToken(sqlParser.CUBE, 0)

        def CURRENT(self):
            return self.getToken(sqlParser.CURRENT, 0)

        def CURRENT_DATE(self):
            return self.getToken(sqlParser.CURRENT_DATE, 0)

        def CURRENT_TIME(self):
            return self.getToken(sqlParser.CURRENT_TIME, 0)

        def CURRENT_TIMESTAMP(self):
            return self.getToken(sqlParser.CURRENT_TIMESTAMP, 0)

        def CURRENT_USER(self):
            return self.getToken(sqlParser.CURRENT_USER, 0)

        def DATA(self):
            return self.getToken(sqlParser.DATA, 0)

        def DATABASE(self):
            return self.getToken(sqlParser.DATABASE, 0)

        def DATABASES(self):
            return self.getToken(sqlParser.DATABASES, 0)

        def DAY(self):
            return self.getToken(sqlParser.DAY, 0)

        def DBPROPERTIES(self):
            return self.getToken(sqlParser.DBPROPERTIES, 0)

        def DEFINED(self):
            return self.getToken(sqlParser.DEFINED, 0)

        def DELETE(self):
            return self.getToken(sqlParser.DELETE, 0)

        def DELIMITED(self):
            return self.getToken(sqlParser.DELIMITED, 0)

        def DESC(self):
            return self.getToken(sqlParser.DESC, 0)

        def DESCRIBE(self):
            return self.getToken(sqlParser.DESCRIBE, 0)

        def DFS(self):
            return self.getToken(sqlParser.DFS, 0)

        def DIRECTORIES(self):
            return self.getToken(sqlParser.DIRECTORIES, 0)

        def DIRECTORY(self):
            return self.getToken(sqlParser.DIRECTORY, 0)

        def DISTINCT(self):
            return self.getToken(sqlParser.DISTINCT, 0)

        def DISTRIBUTE(self):
            return self.getToken(sqlParser.DISTRIBUTE, 0)

        def DIV(self):
            return self.getToken(sqlParser.DIV, 0)

        def DROP(self):
            return self.getToken(sqlParser.DROP, 0)

        def ELSE(self):
            return self.getToken(sqlParser.ELSE, 0)

        def END(self):
            return self.getToken(sqlParser.END, 0)

        def ESCAPE(self):
            return self.getToken(sqlParser.ESCAPE, 0)

        def ESCAPED(self):
            return self.getToken(sqlParser.ESCAPED, 0)

        def EXCHANGE(self):
            return self.getToken(sqlParser.EXCHANGE, 0)

        def EXISTS(self):
            return self.getToken(sqlParser.EXISTS, 0)

        def EXPLAIN(self):
            return self.getToken(sqlParser.EXPLAIN, 0)

        def EXPORT(self):
            return self.getToken(sqlParser.EXPORT, 0)

        def EXTENDED(self):
            return self.getToken(sqlParser.EXTENDED, 0)

        def EXTERNAL(self):
            return self.getToken(sqlParser.EXTERNAL, 0)

        def EXTRACT(self):
            return self.getToken(sqlParser.EXTRACT, 0)

        def FALSE(self):
            return self.getToken(sqlParser.FALSE, 0)

        def FETCH(self):
            return self.getToken(sqlParser.FETCH, 0)

        def FILTER(self):
            return self.getToken(sqlParser.FILTER, 0)

        def FIELDS(self):
            return self.getToken(sqlParser.FIELDS, 0)

        def FILEFORMAT(self):
            return self.getToken(sqlParser.FILEFORMAT, 0)

        def FIRST(self):
            return self.getToken(sqlParser.FIRST, 0)

        def FOLLOWING(self):
            return self.getToken(sqlParser.FOLLOWING, 0)

        def FOR(self):
            return self.getToken(sqlParser.FOR, 0)

        def FOREIGN(self):
            return self.getToken(sqlParser.FOREIGN, 0)

        def FORMAT(self):
            return self.getToken(sqlParser.FORMAT, 0)

        def FORMATTED(self):
            return self.getToken(sqlParser.FORMATTED, 0)

        def FROM(self):
            return self.getToken(sqlParser.FROM, 0)

        def FUNCTION(self):
            return self.getToken(sqlParser.FUNCTION, 0)

        def FUNCTIONS(self):
            return self.getToken(sqlParser.FUNCTIONS, 0)

        def GLOBAL(self):
            return self.getToken(sqlParser.GLOBAL, 0)

        def GRANT(self):
            return self.getToken(sqlParser.GRANT, 0)

        def GROUP(self):
            return self.getToken(sqlParser.GROUP, 0)

        def GROUPING(self):
            return self.getToken(sqlParser.GROUPING, 0)

        def HAVING(self):
            return self.getToken(sqlParser.HAVING, 0)

        def HOUR(self):
            return self.getToken(sqlParser.HOUR, 0)

        def IF(self):
            return self.getToken(sqlParser.IF, 0)

        def IGNORE(self):
            return self.getToken(sqlParser.IGNORE, 0)

        def IMPORT(self):
            return self.getToken(sqlParser.IMPORT, 0)

        def IN(self):
            return self.getToken(sqlParser.IN, 0)

        def INDEX(self):
            return self.getToken(sqlParser.INDEX, 0)

        def INDEXES(self):
            return self.getToken(sqlParser.INDEXES, 0)

        def INPATH(self):
            return self.getToken(sqlParser.INPATH, 0)

        def INPUTFORMAT(self):
            return self.getToken(sqlParser.INPUTFORMAT, 0)

        def INSERT(self):
            return self.getToken(sqlParser.INSERT, 0)

        def INTERVAL(self):
            return self.getToken(sqlParser.INTERVAL, 0)

        def INTO(self):
            return self.getToken(sqlParser.INTO, 0)

        def IS(self):
            return self.getToken(sqlParser.IS, 0)

        def ITEMS(self):
            return self.getToken(sqlParser.ITEMS, 0)

        def KEYS(self):
            return self.getToken(sqlParser.KEYS, 0)

        def LAST(self):
            return self.getToken(sqlParser.LAST, 0)

        def LATERAL(self):
            return self.getToken(sqlParser.LATERAL, 0)

        def LAZY(self):
            return self.getToken(sqlParser.LAZY, 0)

        def LEADING(self):
            return self.getToken(sqlParser.LEADING, 0)

        def LIKE(self):
            return self.getToken(sqlParser.LIKE, 0)

        def LIMIT(self):
            return self.getToken(sqlParser.LIMIT, 0)

        def LINES(self):
            return self.getToken(sqlParser.LINES, 0)

        def LIST(self):
            return self.getToken(sqlParser.LIST, 0)

        def LOAD(self):
            return self.getToken(sqlParser.LOAD, 0)

        def LOCAL(self):
            return self.getToken(sqlParser.LOCAL, 0)

        def LOCATION(self):
            return self.getToken(sqlParser.LOCATION, 0)

        def LOCK(self):
            return self.getToken(sqlParser.LOCK, 0)

        def LOCKS(self):
            return self.getToken(sqlParser.LOCKS, 0)

        def LOGICAL(self):
            return self.getToken(sqlParser.LOGICAL, 0)

        def MACRO(self):
            return self.getToken(sqlParser.MACRO, 0)

        def MAP(self):
            return self.getToken(sqlParser.MAP, 0)

        def MATCHED(self):
            return self.getToken(sqlParser.MATCHED, 0)

        def MERGE(self):
            return self.getToken(sqlParser.MERGE, 0)

        def MINUTE(self):
            return self.getToken(sqlParser.MINUTE, 0)

        def MONTH(self):
            return self.getToken(sqlParser.MONTH, 0)

        def MSCK(self):
            return self.getToken(sqlParser.MSCK, 0)

        def NAMESPACE(self):
            return self.getToken(sqlParser.NAMESPACE, 0)

        def NAMESPACES(self):
            return self.getToken(sqlParser.NAMESPACES, 0)

        def NO(self):
            return self.getToken(sqlParser.NO, 0)

        def NOT(self):
            return self.getToken(sqlParser.NOT, 0)

        def NULL(self):
            return self.getToken(sqlParser.NULL, 0)

        def NULLS(self):
            return self.getToken(sqlParser.NULLS, 0)

        def OF(self):
            return self.getToken(sqlParser.OF, 0)

        def ONLY(self):
            return self.getToken(sqlParser.ONLY, 0)

        def OPTION(self):
            return self.getToken(sqlParser.OPTION, 0)

        def OPTIONS(self):
            return self.getToken(sqlParser.OPTIONS, 0)

        def OR(self):
            return self.getToken(sqlParser.OR, 0)

        def ORDER(self):
            return self.getToken(sqlParser.ORDER, 0)

        def OUT(self):
            return self.getToken(sqlParser.OUT, 0)

        def OUTER(self):
            return self.getToken(sqlParser.OUTER, 0)

        def OUTPUTFORMAT(self):
            return self.getToken(sqlParser.OUTPUTFORMAT, 0)

        def OVER(self):
            return self.getToken(sqlParser.OVER, 0)

        def OVERLAPS(self):
            return self.getToken(sqlParser.OVERLAPS, 0)

        def OVERLAY(self):
            return self.getToken(sqlParser.OVERLAY, 0)

        def OVERWRITE(self):
            return self.getToken(sqlParser.OVERWRITE, 0)

        def PARTITION(self):
            return self.getToken(sqlParser.PARTITION, 0)

        def PARTITIONED(self):
            return self.getToken(sqlParser.PARTITIONED, 0)

        def PARTITIONS(self):
            return self.getToken(sqlParser.PARTITIONS, 0)

        def PERCENTLIT(self):
            return self.getToken(sqlParser.PERCENTLIT, 0)

        def PIVOT(self):
            return self.getToken(sqlParser.PIVOT, 0)

        def PLACING(self):
            return self.getToken(sqlParser.PLACING, 0)

        def POSITION(self):
            return self.getToken(sqlParser.POSITION, 0)

        def PRECEDING(self):
            return self.getToken(sqlParser.PRECEDING, 0)

        def PRIMARY(self):
            return self.getToken(sqlParser.PRIMARY, 0)

        def PRINCIPALS(self):
            return self.getToken(sqlParser.PRINCIPALS, 0)

        def PROPERTIES(self):
            return self.getToken(sqlParser.PROPERTIES, 0)

        def PURGE(self):
            return self.getToken(sqlParser.PURGE, 0)

        def QUERY(self):
            return self.getToken(sqlParser.QUERY, 0)

        def RANGE(self):
            return self.getToken(sqlParser.RANGE, 0)

        def RECORDREADER(self):
            return self.getToken(sqlParser.RECORDREADER, 0)

        def RECORDWRITER(self):
            return self.getToken(sqlParser.RECORDWRITER, 0)

        def RECOVER(self):
            return self.getToken(sqlParser.RECOVER, 0)

        def REDUCE(self):
            return self.getToken(sqlParser.REDUCE, 0)

        def REFERENCES(self):
            return self.getToken(sqlParser.REFERENCES, 0)

        def REFRESH(self):
            return self.getToken(sqlParser.REFRESH, 0)

        def RENAME(self):
            return self.getToken(sqlParser.RENAME, 0)

        def REPAIR(self):
            return self.getToken(sqlParser.REPAIR, 0)

        def REPLACE(self):
            return self.getToken(sqlParser.REPLACE, 0)

        def RESET(self):
            return self.getToken(sqlParser.RESET, 0)

        def RESTRICT(self):
            return self.getToken(sqlParser.RESTRICT, 0)

        def REVOKE(self):
            return self.getToken(sqlParser.REVOKE, 0)

        def RLIKE(self):
            return self.getToken(sqlParser.RLIKE, 0)

        def ROLE(self):
            return self.getToken(sqlParser.ROLE, 0)

        def ROLES(self):
            return self.getToken(sqlParser.ROLES, 0)

        def ROLLBACK(self):
            return self.getToken(sqlParser.ROLLBACK, 0)

        def ROLLUP(self):
            return self.getToken(sqlParser.ROLLUP, 0)

        def ROW(self):
            return self.getToken(sqlParser.ROW, 0)

        def ROWS(self):
            return self.getToken(sqlParser.ROWS, 0)

        def SCHEMA(self):
            return self.getToken(sqlParser.SCHEMA, 0)

        def SECOND(self):
            return self.getToken(sqlParser.SECOND, 0)

        def SELECT(self):
            return self.getToken(sqlParser.SELECT, 0)

        def SEPARATED(self):
            return self.getToken(sqlParser.SEPARATED, 0)

        def SERDE(self):
            return self.getToken(sqlParser.SERDE, 0)

        def SERDEPROPERTIES(self):
            return self.getToken(sqlParser.SERDEPROPERTIES, 0)

        def SESSION_USER(self):
            return self.getToken(sqlParser.SESSION_USER, 0)

        def SET(self):
            return self.getToken(sqlParser.SET, 0)

        def SETS(self):
            return self.getToken(sqlParser.SETS, 0)

        def SHOW(self):
            return self.getToken(sqlParser.SHOW, 0)

        def SKEWED(self):
            return self.getToken(sqlParser.SKEWED, 0)

        def SOME(self):
            return self.getToken(sqlParser.SOME, 0)

        def SORT(self):
            return self.getToken(sqlParser.SORT, 0)

        def SORTED(self):
            return self.getToken(sqlParser.SORTED, 0)

        def START(self):
            return self.getToken(sqlParser.START, 0)

        def STATISTICS(self):
            return self.getToken(sqlParser.STATISTICS, 0)

        def STORED(self):
            return self.getToken(sqlParser.STORED, 0)

        def STRATIFY(self):
            return self.getToken(sqlParser.STRATIFY, 0)

        def STRUCT(self):
            return self.getToken(sqlParser.STRUCT, 0)

        def SUBSTR(self):
            return self.getToken(sqlParser.SUBSTR, 0)

        def SUBSTRING(self):
            return self.getToken(sqlParser.SUBSTRING, 0)

        def TABLE(self):
            return self.getToken(sqlParser.TABLE, 0)

        def TABLES(self):
            return self.getToken(sqlParser.TABLES, 0)

        def TABLESAMPLE(self):
            return self.getToken(sqlParser.TABLESAMPLE, 0)

        def TBLPROPERTIES(self):
            return self.getToken(sqlParser.TBLPROPERTIES, 0)

        def TEMPORARY(self):
            return self.getToken(sqlParser.TEMPORARY, 0)

        def TERMINATED(self):
            return self.getToken(sqlParser.TERMINATED, 0)

        def THEN(self):
            return self.getToken(sqlParser.THEN, 0)

        def TO(self):
            return self.getToken(sqlParser.TO, 0)

        def TOUCH(self):
            return self.getToken(sqlParser.TOUCH, 0)

        def TRAILING(self):
            return self.getToken(sqlParser.TRAILING, 0)

        def TRANSACTION(self):
            return self.getToken(sqlParser.TRANSACTION, 0)

        def TRANSACTIONS(self):
            return self.getToken(sqlParser.TRANSACTIONS, 0)

        def TRANSFORM(self):
            return self.getToken(sqlParser.TRANSFORM, 0)

        def TRIM(self):
            return self.getToken(sqlParser.TRIM, 0)

        def TRUE(self):
            return self.getToken(sqlParser.TRUE, 0)

        def TRUNCATE(self):
            return self.getToken(sqlParser.TRUNCATE, 0)

        def TYPE(self):
            return self.getToken(sqlParser.TYPE, 0)

        def UNARCHIVE(self):
            return self.getToken(sqlParser.UNARCHIVE, 0)

        def UNBOUNDED(self):
            return self.getToken(sqlParser.UNBOUNDED, 0)

        def UNCACHE(self):
            return self.getToken(sqlParser.UNCACHE, 0)

        def UNIQUE(self):
            return self.getToken(sqlParser.UNIQUE, 0)

        def UNKNOWN(self):
            return self.getToken(sqlParser.UNKNOWN, 0)

        def UNLOCK(self):
            return self.getToken(sqlParser.UNLOCK, 0)

        def UNSET(self):
            return self.getToken(sqlParser.UNSET, 0)

        def UPDATE(self):
            return self.getToken(sqlParser.UPDATE, 0)

        def USE(self):
            return self.getToken(sqlParser.USE, 0)

        def USER(self):
            return self.getToken(sqlParser.USER, 0)

        def VALUES(self):
            return self.getToken(sqlParser.VALUES, 0)

        def VIEW(self):
            return self.getToken(sqlParser.VIEW, 0)

        def VIEWS(self):
            return self.getToken(sqlParser.VIEWS, 0)

        def WHEN(self):
            return self.getToken(sqlParser.WHEN, 0)

        def WHERE(self):
            return self.getToken(sqlParser.WHERE, 0)

        def WINDOW(self):
            return self.getToken(sqlParser.WINDOW, 0)

        def WITH(self):
            return self.getToken(sqlParser.WITH, 0)

        def YEAR(self):
            return self.getToken(sqlParser.YEAR, 0)

        def getRuleIndex(self):
            return sqlParser.RULE_nonReserved

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNonReserved" ):
                return visitor.visitNonReserved(self)
            else:
                return visitor.visitChildren(self)




    def nonReserved(self):

        localctx = sqlParser.NonReservedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 272, self.RULE_nonReserved)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2994
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << sqlParser.ADD) | (1 << sqlParser.AFTER) | (1 << sqlParser.ALL) | (1 << sqlParser.ALTER) | (1 << sqlParser.ANALYZE) | (1 << sqlParser.AND) | (1 << sqlParser.ANY) | (1 << sqlParser.ARCHIVE) | (1 << sqlParser.ARRAY) | (1 << sqlParser.AS) | (1 << sqlParser.ASC) | (1 << sqlParser.AT) | (1 << sqlParser.AUTHORIZATION) | (1 << sqlParser.BETWEEN) | (1 << sqlParser.BOTH) | (1 << sqlParser.BUCKET) | (1 << sqlParser.BUCKETS) | (1 << sqlParser.BY) | (1 << sqlParser.CACHE) | (1 << sqlParser.CASCADE) | (1 << sqlParser.CASE) | (1 << sqlParser.CAST) | (1 << sqlParser.CHANGE) | (1 << sqlParser.CHECK) | (1 << sqlParser.CLEAR) | (1 << sqlParser.CLUSTER) | (1 << sqlParser.CLUSTERED) | (1 << sqlParser.CODEGEN) | (1 << sqlParser.COLLATE) | (1 << sqlParser.COLLECTION) | (1 << sqlParser.COLUMN) | (1 << sqlParser.COLUMNS) | (1 << sqlParser.COMMENT) | (1 << sqlParser.COMMIT) | (1 << sqlParser.COMPACT) | (1 << sqlParser.COMPACTIONS) | (1 << sqlParser.COMPUTE) | (1 << sqlParser.CONCATENATE) | (1 << sqlParser.CONSTRAINT) | (1 << sqlParser.COST) | (1 << sqlParser.CREATE) | (1 << sqlParser.CUBE) | (1 << sqlParser.CURRENT) | (1 << sqlParser.CURRENT_DATE) | (1 << sqlParser.CURRENT_TIME) | (1 << sqlParser.CURRENT_TIMESTAMP) | (1 << sqlParser.CURRENT_USER) | (1 << sqlParser.DATA) | (1 << sqlParser.DATABASE) | (1 << sqlParser.DATABASES))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (sqlParser.DAY - 64)) | (1 << (sqlParser.DBPROPERTIES - 64)) | (1 << (sqlParser.DEFINED - 64)) | (1 << (sqlParser.DELETE - 64)) | (1 << (sqlParser.DELIMITED - 64)) | (1 << (sqlParser.DESC - 64)) | (1 << (sqlParser.DESCRIBE - 64)) | (1 << (sqlParser.DFS - 64)) | (1 << (sqlParser.DIRECTORIES - 64)) | (1 << (sqlParser.DIRECTORY - 64)) | (1 << (sqlParser.DISTINCT - 64)) | (1 << (sqlParser.DISTRIBUTE - 64)) | (1 << (sqlParser.DROP - 64)) | (1 << (sqlParser.ELSE - 64)) | (1 << (sqlParser.END - 64)) | (1 << (sqlParser.ESCAPE - 64)) | (1 << (sqlParser.ESCAPED - 64)) | (1 << (sqlParser.EXCHANGE - 64)) | (1 << (sqlParser.EXISTS - 64)) | (1 << (sqlParser.EXPLAIN - 64)) | (1 << (sqlParser.EXPORT - 64)) | (1 << (sqlParser.EXTENDED - 64)) | (1 << (sqlParser.EXTERNAL - 64)) | (1 << (sqlParser.EXTRACT - 64)) | (1 << (sqlParser.FALSE - 64)) | (1 << (sqlParser.FETCH - 64)) | (1 << (sqlParser.FIELDS - 64)) | (1 << (sqlParser.FILTER - 64)) | (1 << (sqlParser.FILEFORMAT - 64)) | (1 << (sqlParser.FIRST - 64)) | (1 << (sqlParser.FOLLOWING - 64)) | (1 << (sqlParser.FOR - 64)) | (1 << (sqlParser.FOREIGN - 64)) | (1 << (sqlParser.FORMAT - 64)) | (1 << (sqlParser.FORMATTED - 64)) | (1 << (sqlParser.FROM - 64)) | (1 << (sqlParser.FUNCTION - 64)) | (1 << (sqlParser.FUNCTIONS - 64)) | (1 << (sqlParser.GLOBAL - 64)) | (1 << (sqlParser.GRANT - 64)) | (1 << (sqlParser.GROUP - 64)) | (1 << (sqlParser.GROUPING - 64)) | (1 << (sqlParser.HAVING - 64)) | (1 << (sqlParser.HOUR - 64)) | (1 << (sqlParser.IF - 64)) | (1 << (sqlParser.IGNORE - 64)) | (1 << (sqlParser.IMPORT - 64)) | (1 << (sqlParser.IN - 64)) | (1 << (sqlParser.INDEX - 64)) | (1 << (sqlParser.INDEXES - 64)) | (1 << (sqlParser.INPATH - 64)) | (1 << (sqlParser.INPUTFORMAT - 64)) | (1 << (sqlParser.INSERT - 64)) | (1 << (sqlParser.INTERVAL - 64)) | (1 << (sqlParser.INTO - 64)) | (1 << (sqlParser.IS - 64)) | (1 << (sqlParser.ITEMS - 64)) | (1 << (sqlParser.KEYS - 64)) | (1 << (sqlParser.LAST - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (sqlParser.LATERAL - 128)) | (1 << (sqlParser.LAZY - 128)) | (1 << (sqlParser.LEADING - 128)) | (1 << (sqlParser.LIKE - 128)) | (1 << (sqlParser.LIMIT - 128)) | (1 << (sqlParser.LINES - 128)) | (1 << (sqlParser.LIST - 128)) | (1 << (sqlParser.LOAD - 128)) | (1 << (sqlParser.LOCAL - 128)) | (1 << (sqlParser.LOCATION - 128)) | (1 << (sqlParser.LOCK - 128)) | (1 << (sqlParser.LOCKS - 128)) | (1 << (sqlParser.LOGICAL - 128)) | (1 << (sqlParser.MACRO - 128)) | (1 << (sqlParser.MAP - 128)) | (1 << (sqlParser.MATCHED - 128)) | (1 << (sqlParser.MERGE - 128)) | (1 << (sqlParser.MINUTE - 128)) | (1 << (sqlParser.MONTH - 128)) | (1 << (sqlParser.MSCK - 128)) | (1 << (sqlParser.NAMESPACE - 128)) | (1 << (sqlParser.NAMESPACES - 128)) | (1 << (sqlParser.NO - 128)) | (1 << (sqlParser.NOT - 128)) | (1 << (sqlParser.NULL - 128)) | (1 << (sqlParser.NULLS - 128)) | (1 << (sqlParser.OF - 128)) | (1 << (sqlParser.ONLY - 128)) | (1 << (sqlParser.OPTION - 128)) | (1 << (sqlParser.OPTIONS - 128)) | (1 << (sqlParser.OR - 128)) | (1 << (sqlParser.ORDER - 128)) | (1 << (sqlParser.OUT - 128)) | (1 << (sqlParser.OUTER - 128)) | (1 << (sqlParser.OUTPUTFORMAT - 128)) | (1 << (sqlParser.OVER - 128)) | (1 << (sqlParser.OVERLAPS - 128)) | (1 << (sqlParser.OVERLAY - 128)) | (1 << (sqlParser.OVERWRITE - 128)) | (1 << (sqlParser.PARTITION - 128)) | (1 << (sqlParser.PARTITIONED - 128)) | (1 << (sqlParser.PARTITIONS - 128)) | (1 << (sqlParser.PERCENTLIT - 128)) | (1 << (sqlParser.PIVOT - 128)) | (1 << (sqlParser.PLACING - 128)) | (1 << (sqlParser.POSITION - 128)) | (1 << (sqlParser.PRECEDING - 128)) | (1 << (sqlParser.PRIMARY - 128)) | (1 << (sqlParser.PRINCIPALS - 128)) | (1 << (sqlParser.PROPERTIES - 128)) | (1 << (sqlParser.PURGE - 128)) | (1 << (sqlParser.QUERY - 128)) | (1 << (sqlParser.RANGE - 128)) | (1 << (sqlParser.RECORDREADER - 128)) | (1 << (sqlParser.RECORDWRITER - 128)) | (1 << (sqlParser.RECOVER - 128)) | (1 << (sqlParser.REDUCE - 128)) | (1 << (sqlParser.REFERENCES - 128)) | (1 << (sqlParser.REFRESH - 128)) | (1 << (sqlParser.RENAME - 128)) | (1 << (sqlParser.REPAIR - 128)))) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & ((1 << (sqlParser.REPLACE - 192)) | (1 << (sqlParser.RESET - 192)) | (1 << (sqlParser.RESTRICT - 192)) | (1 << (sqlParser.REVOKE - 192)) | (1 << (sqlParser.RLIKE - 192)) | (1 << (sqlParser.ROLE - 192)) | (1 << (sqlParser.ROLES - 192)) | (1 << (sqlParser.ROLLBACK - 192)) | (1 << (sqlParser.ROLLUP - 192)) | (1 << (sqlParser.ROW - 192)) | (1 << (sqlParser.ROWS - 192)) | (1 << (sqlParser.SCHEMA - 192)) | (1 << (sqlParser.SECOND - 192)) | (1 << (sqlParser.SELECT - 192)) | (1 << (sqlParser.SEPARATED - 192)) | (1 << (sqlParser.SERDE - 192)) | (1 << (sqlParser.SERDEPROPERTIES - 192)) | (1 << (sqlParser.SESSION_USER - 192)) | (1 << (sqlParser.SET - 192)) | (1 << (sqlParser.SETS - 192)) | (1 << (sqlParser.SHOW - 192)) | (1 << (sqlParser.SKEWED - 192)) | (1 << (sqlParser.SOME - 192)) | (1 << (sqlParser.SORT - 192)) | (1 << (sqlParser.SORTED - 192)) | (1 << (sqlParser.START - 192)) | (1 << (sqlParser.STATISTICS - 192)) | (1 << (sqlParser.STORED - 192)) | (1 << (sqlParser.STRATIFY - 192)) | (1 << (sqlParser.STRUCT - 192)) | (1 << (sqlParser.SUBSTR - 192)) | (1 << (sqlParser.SUBSTRING - 192)) | (1 << (sqlParser.TABLE - 192)) | (1 << (sqlParser.TABLES - 192)) | (1 << (sqlParser.TABLESAMPLE - 192)) | (1 << (sqlParser.TBLPROPERTIES - 192)) | (1 << (sqlParser.TEMPORARY - 192)) | (1 << (sqlParser.TERMINATED - 192)) | (1 << (sqlParser.THEN - 192)) | (1 << (sqlParser.TO - 192)) | (1 << (sqlParser.TOUCH - 192)) | (1 << (sqlParser.TRAILING - 192)) | (1 << (sqlParser.TRANSACTION - 192)) | (1 << (sqlParser.TRANSACTIONS - 192)) | (1 << (sqlParser.TRANSFORM - 192)) | (1 << (sqlParser.TRIM - 192)) | (1 << (sqlParser.TRUE - 192)) | (1 << (sqlParser.TRUNCATE - 192)) | (1 << (sqlParser.TYPE - 192)) | (1 << (sqlParser.UNARCHIVE - 192)) | (1 << (sqlParser.UNBOUNDED - 192)) | (1 << (sqlParser.UNCACHE - 192)) | (1 << (sqlParser.UNIQUE - 192)) | (1 << (sqlParser.UNKNOWN - 192)) | (1 << (sqlParser.UNLOCK - 192)) | (1 << (sqlParser.UNSET - 192)) | (1 << (sqlParser.UPDATE - 192)) | (1 << (sqlParser.USE - 192)) | (1 << (sqlParser.USER - 192)))) != 0) or ((((_la - 256)) & ~0x3f) == 0 and ((1 << (_la - 256)) & ((1 << (sqlParser.VALUES - 256)) | (1 << (sqlParser.VIEW - 256)) | (1 << (sqlParser.VIEWS - 256)) | (1 << (sqlParser.WHEN - 256)) | (1 << (sqlParser.WHERE - 256)) | (1 << (sqlParser.WINDOW - 256)) | (1 << (sqlParser.WITH - 256)) | (1 << (sqlParser.YEAR - 256)) | (1 << (sqlParser.DIV - 256)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[40] = self.queryTerm_sempred
        self._predicates[94] = self.booleanExpression_sempred
        self._predicates[96] = self.valueExpression_sempred
        self._predicates[97] = self.primaryExpression_sempred
        self._predicates[129] = self.identifier_sempred
        self._predicates[130] = self.strictIdentifier_sempred
        self._predicates[132] = self.number_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def queryTerm_sempred(self, localctx:QueryTermContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 1:
                return self.legacy_setops_precedence_enbled
         

            if predIndex == 2:
                return self.precpred(self._ctx, 2)
         

            if predIndex == 3:
                return not self.legacy_setops_precedence_enbled
         

            if predIndex == 4:
                return self.precpred(self._ctx, 1)
         

            if predIndex == 5:
                return not self.legacy_setops_precedence_enbled
         

    def booleanExpression_sempred(self, localctx:BooleanExpressionContext, predIndex:int):
            if predIndex == 6:
                return self.precpred(self._ctx, 2)
         

            if predIndex == 7:
                return self.precpred(self._ctx, 1)
         

    def valueExpression_sempred(self, localctx:ValueExpressionContext, predIndex:int):
            if predIndex == 8:
                return self.precpred(self._ctx, 6)
         

            if predIndex == 9:
                return self.precpred(self._ctx, 5)
         

            if predIndex == 10:
                return self.precpred(self._ctx, 4)
         

            if predIndex == 11:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 12:
                return self.precpred(self._ctx, 2)
         

            if predIndex == 13:
                return self.precpred(self._ctx, 1)
         

    def primaryExpression_sempred(self, localctx:PrimaryExpressionContext, predIndex:int):
            if predIndex == 14:
                return self.precpred(self._ctx, 8)
         

            if predIndex == 15:
                return self.precpred(self._ctx, 6)
         

    def identifier_sempred(self, localctx:IdentifierContext, predIndex:int):
            if predIndex == 16:
                return not self.SQL_standard_keyword_behavior
         

    def strictIdentifier_sempred(self, localctx:StrictIdentifierContext, predIndex:int):
            if predIndex == 17:
                return self.SQL_standard_keyword_behavior
         

            if predIndex == 18:
                return not self.SQL_standard_keyword_behavior
         

    def number_sempred(self, localctx:NumberContext, predIndex:int):
            if predIndex == 19:
                return not self.legacy_exponent_literal_as_decimal_enabled
         

            if predIndex == 20:
                return not self.legacy_exponent_literal_as_decimal_enabled
         

            if predIndex == 21:
                return self.legacy_exponent_literal_as_decimal_enabled
         




