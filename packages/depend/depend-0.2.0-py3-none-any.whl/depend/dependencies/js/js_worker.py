"""Functions to handle JavaScript files"""
import json
from datetime import datetime
from typing import Any

import yaml
from pyarn import lockfile

from depend.dependencies.dep_types import Result


def handle_yarn_lock(req_file_data: str) -> Result:
    """
    Parse yarn lock file
    :param req_file_data: Content of yarn.lock
    :return: list of requirement and specs
    """
    res: Result = {
        "import_name": "",
        "lang_ver": [],
        "pkg_name": "",
        "pkg_ver": "",
        "pkg_lic": ["Other"],
        "pkg_err": {},
        "pkg_dep": [],
        "timestamp": datetime.utcnow().isoformat(),
    }
    if "lockfile v1" in req_file_data:
        parsed_lockfile = lockfile.Lockfile.from_str(req_file_data)
        unfiltered_content: dict = json.loads(parsed_lockfile.to_json())
    else:
        unfiltered_content = yaml.safe_load(req_file_data)
    for package in unfiltered_content.keys():
        if package.startswith("_"):
            continue
        res["pkg_dep"].append(
            str(package.split(",")[0].rsplit("@", 1)[0])
            + ";"
            + str(unfiltered_content[package].get("version", ""))
        )
    return res


def handle_json(req_file_data: str) -> Result:
    """
    Parse json files generated by npm or yarn
    :param req_file_data: Content of package.json
    :return: list of requirement and specs
    """
    package_data = json.loads(req_file_data)
    engines = package_data.get("engines", {})
    if isinstance(engines, dict):
        lang_ver = [engines.get("node", "")]
    else:
        # The documentation specifies that this entry must be a dictionary
        # This was added because of a failing case in tests
        lang_ver = []
    pkg_lic = ["Other"]
    lic_info = package_data.get("license")
    if isinstance(lic_info, str):
        pkg_lic = lic_info.split(",")
    #     The cases below are just to as to add support for older packages
    elif isinstance(lic_info, dict):
        pkg_lic = [lic_info.get("type", "Other")]
    elif lic_info and isinstance(lic_info, list):
        if isinstance(lic_info[0], dict):
            pkg_lic = list({single_lic.get("type", "Other") for single_lic in lic_info})
        elif isinstance(lic_info[0], str):
            pkg_lic = lic_info
    filter_dict: Result = {
        "import_name": "",
        "lang_ver": lang_ver,
        "pkg_name": package_data.get("name", ""),
        "pkg_ver": package_data.get("version", ""),
        "pkg_lic": pkg_lic,
        "pkg_dep": package_data.get("dependencies", {}),
        "pkg_err": {},
        "timestamp": datetime.utcnow().isoformat(),
    }
    for k, v in filter_dict.items():
        if k == "pkg_dep":
            handle_json_dep(filter_dict, k, v)
        elif k not in ["lang_ver", "pkg_lic"]:
            flatten_content(filter_dict, k, v)
    filter_dict["pkg_err"] = {}
    return filter_dict


def handle_json_dep(filter_dict: Result, k: str, v: Any) -> None:
    """
    Flattens variants of dependencies to uniform
    :param filter_dict: any dict or list
    :param k: key to check
    :param v: associated value
    """
    if any(isinstance(i, dict) for i in v.values()):
        filter_dict[k] = [i + ";" + v[i].get("version", "") for i in v.keys()]  # type: ignore
    else:
        filter_dict[k] = [";".join(i) for i in v.items()]  # type: ignore


def flatten_content(filter_dict: Result, k: str, v: Any):
    """
    Flattens a dict/list - used to handle deprecated formats
    :param filter_dict: any dict or list
    :param k: key to check
    :param v: associated value
    """
    if isinstance(v, dict):
        filter_dict[k] = ";".join(v.values())  # type: ignore
    elif isinstance(v, list):
        if any(isinstance(i, dict) for i in v):
            temp_list = [";".join(s.values()) for s in v if isinstance(s, dict)]
            filter_dict[k] = ";".join(temp_list)  # type: ignore
        else:
            filter_dict[k] = ";".join(v)  # type: ignore
    else:
        filter_dict[k] = str(filter_dict[k])  # type: ignore
